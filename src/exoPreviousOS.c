/* exoPreviousOS.c generated by valac 0.12.1, the Vala compiler
 * generated from exoPreviousOS.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define EXOGENESIS_TYPE_PREVIOUS_OS (exogenesis_previous_os_get_type ())
#define EXOGENESIS_PREVIOUS_OS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOS))
#define EXOGENESIS_PREVIOUS_OS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOSClass))
#define EXOGENESIS_IS_PREVIOUS_OS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PREVIOUS_OS))
#define EXOGENESIS_IS_PREVIOUS_OS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PREVIOUS_OS))
#define EXOGENESIS_PREVIOUS_OS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOSClass))

typedef struct _ExogenesisPreviousOS ExogenesisPreviousOS;
typedef struct _ExogenesisPreviousOSClass ExogenesisPreviousOSClass;
typedef struct _ExogenesisPreviousOSPrivate ExogenesisPreviousOSPrivate;

#define EXOGENESIS_TYPE_USER_DETAIL (exogenesis_user_detail_get_type ())
#define EXOGENESIS_USER_DETAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetail))
#define EXOGENESIS_USER_DETAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetailClass))
#define EXOGENESIS_IS_USER_DETAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_USER_DETAIL))
#define EXOGENESIS_IS_USER_DETAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_USER_DETAIL))
#define EXOGENESIS_USER_DETAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetailClass))

typedef struct _ExogenesisUserDetail ExogenesisUserDetail;
typedef struct _ExogenesisUserDetailClass ExogenesisUserDetailClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;
typedef struct _ExogenesisHDManagerPrivate ExogenesisHDManagerPrivate;

#define EXOGENESIS_TYPE_HARD_DISK (exogenesis_hard_disk_get_type ())
#define EXOGENESIS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDisk))
#define EXOGENESIS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))
#define EXOGENESIS_IS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_IS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))

typedef struct _ExogenesisHardDisk ExogenesisHardDisk;
typedef struct _ExogenesisHardDiskClass ExogenesisHardDiskClass;

#define EXOGENESIS_TYPE_PARTITION_INFO (exogenesis_partition_info_get_type ())
#define EXOGENESIS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfo))
#define EXOGENESIS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))
#define EXOGENESIS_IS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_IS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_PARTITION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))

typedef struct _ExogenesisPartitionInfo ExogenesisPartitionInfo;
typedef struct _ExogenesisPartitionInfoClass ExogenesisPartitionInfoClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define EXOGENESIS_TYPE_GENERAL_FUNCTIONS (exogenesis_general_functions_get_type ())
#define EXOGENESIS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctions))
#define EXOGENESIS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_GENERAL_FUNCTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))

typedef struct _ExogenesisGeneralFunctions ExogenesisGeneralFunctions;
typedef struct _ExogenesisGeneralFunctionsClass ExogenesisGeneralFunctionsClass;
typedef struct _ExogenesisParamSpecPreviousOS ExogenesisParamSpecPreviousOS;

struct _ExogenesisPreviousOS {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisPreviousOSPrivate * priv;
};

struct _ExogenesisPreviousOSClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisPreviousOS *self);
};

struct _ExogenesisPreviousOSPrivate {
	GeeHashMap* FSTab;
	GeeArrayList* _existingUsers;
};

struct _ExogenesisHDManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisHDManagerPrivate * priv;
	gboolean ThreadStop;
	gboolean PartitionerRunning;
	GeeArrayList* HardDisks;
};

struct _ExogenesisHDManagerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisHDManager *self);
};

struct _ExogenesisParamSpecPreviousOS {
	GParamSpec parent_instance;
};


static gpointer exogenesis_previous_os_parent_class = NULL;
extern ExogenesisHDManager* exogenesis_gHDManager;
extern ExogenesisGeneralFunctions* exogenesis_gGenFunc;

gpointer exogenesis_previous_os_ref (gpointer instance);
void exogenesis_previous_os_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_previous_os (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_previous_os (GValue* value, gpointer v_object);
void exogenesis_value_take_previous_os (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_previous_os (const GValue* value);
GType exogenesis_previous_os_get_type (void) G_GNUC_CONST;
GType exogenesis_user_detail_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_PREVIOUS_OS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOSPrivate))
enum  {
	EXOGENESIS_PREVIOUS_OS_DUMMY_PROPERTY
};
void exogenesis_previous_os_GetFSTabMountPoints (ExogenesisPreviousOS* self);
gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
GType exogenesis_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_partition_info_get_type (void) G_GNUC_CONST;
const gchar* exogenesis_partition_info_get_UUID (ExogenesisPartitionInfo* self);
static gboolean exogenesis_previous_os_InFSTab (ExogenesisPreviousOS* self, const gchar* uuid);
const gchar* exogenesis_partition_info_get_MountPoint (ExogenesisPartitionInfo* self);
static void exogenesis_previous_os_SetFSTabMountPath (ExogenesisPreviousOS* self, const gchar* fstabfilepath);
static void exogenesis_previous_os_SetLSBName (ExogenesisPreviousOS* self, const gchar* lsbfilepath, ExogenesisHardDisk** hd);
static void exogenesis_previous_os_GetExistingUsers (ExogenesisPreviousOS* self, const gchar* passwdfile);
gpointer exogenesis_general_functions_ref (gpointer instance);
void exogenesis_general_functions_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_general_functions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_general_functions (GValue* value, gpointer v_object);
void exogenesis_value_take_general_functions (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_general_functions (const GValue* value);
GType exogenesis_general_functions_get_type (void) G_GNUC_CONST;
gchar* exogenesis_general_functions_ReadTextFile (ExogenesisGeneralFunctions* self, const gchar* filename);
void exogenesis_partition_info_set_FSTabMountPoint (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_hard_disk_set_PreviousOS (ExogenesisHardDisk* self, const gchar* value);
static gboolean exogenesis_previous_os_UserExists (ExogenesisPreviousOS* self, gint uid);
ExogenesisUserDetail* exogenesis_user_detail_new (void);
ExogenesisUserDetail* exogenesis_user_detail_construct (GType object_type);
void exogenesis_user_detail_set_Username (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_Type (ExogenesisUserDetail* self, gchar value);
void exogenesis_user_detail_set_UserId (ExogenesisUserDetail* self, gint value);
void exogenesis_user_detail_set_GroupId (ExogenesisUserDetail* self, gint value);
void exogenesis_user_detail_set_Fullname (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_OfficeLocation (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_WorkPhone (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_HomePhone (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_HomeFolder (ExogenesisUserDetail* self, const gchar* value);
void exogenesis_user_detail_set_Shell (ExogenesisUserDetail* self, const gchar* value);
gint exogenesis_user_detail_get_UserId (ExogenesisUserDetail* self);
ExogenesisPreviousOS* exogenesis_previous_os_new (void);
ExogenesisPreviousOS* exogenesis_previous_os_construct (GType object_type);
GeeArrayList* exogenesis_previous_os_get_ExistingUsers (ExogenesisPreviousOS* self);
gint exogenesis_previous_os_get_ExistingUsersCount (ExogenesisPreviousOS* self);
static void exogenesis_previous_os_finalize (ExogenesisPreviousOS* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void exogenesis_previous_os_GetFSTabMountPoints (ExogenesisPreviousOS* self) {
	g_return_if_fail (self != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _hd_list;
		gint _tmp1_;
		gint _hd_size;
		gint _hd_index;
		_tmp0_ = _g_object_ref0 (exogenesis_gHDManager->HardDisks);
		_hd_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _hd_list);
		_hd_size = _tmp1_;
		_hd_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* hd;
			_hd_index = _hd_index + 1;
			if (!(_hd_index < _hd_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
			hd = (ExogenesisHardDisk*) _tmp2_;
			{
				GeeIterator* _tmp3_ = NULL;
				GeeIterator* _pi_it;
				_tmp3_ = gee_iterable_iterator ((GeeIterable*) hd);
				_pi_it = _tmp3_;
				while (TRUE) {
					gboolean _tmp4_;
					gpointer _tmp5_ = NULL;
					ExogenesisPartitionInfo* pi;
					gboolean _tmp6_ = FALSE;
					const gchar* _tmp7_ = NULL;
					_tmp4_ = gee_iterator_next (_pi_it);
					if (!_tmp4_) {
						break;
					}
					_tmp5_ = gee_iterator_get (_pi_it);
					pi = (ExogenesisPartitionInfo*) _tmp5_;
					_tmp7_ = exogenesis_partition_info_get_UUID (pi);
					if (_tmp7_ != NULL) {
						const gchar* _tmp8_ = NULL;
						gboolean _tmp9_;
						_tmp8_ = exogenesis_partition_info_get_UUID (pi);
						_tmp9_ = exogenesis_previous_os_InFSTab (self, _tmp8_);
						_tmp6_ = !_tmp9_;
					} else {
						_tmp6_ = FALSE;
					}
					if (_tmp6_) {
						const gchar* _tmp10_ = NULL;
						gchar* _tmp11_ = NULL;
						gchar* fstabfile;
						GFile* _tmp12_ = NULL;
						GFile* file;
						gboolean _tmp13_;
						const gchar* _tmp14_ = NULL;
						gchar* _tmp15_ = NULL;
						gchar* lsbfile;
						GFile* _tmp16_ = NULL;
						gboolean _tmp17_;
						gboolean _tmp21_;
						const gchar* _tmp22_ = NULL;
						gchar* _tmp23_ = NULL;
						gchar* usrpwd;
						GFile* _tmp24_ = NULL;
						gboolean _tmp25_;
						_tmp10_ = exogenesis_partition_info_get_MountPoint (pi);
						_tmp11_ = g_strdup_printf ("%s/etc/fstab", _tmp10_);
						fstabfile = _tmp11_;
						_tmp12_ = g_file_new_for_path (fstabfile);
						file = _tmp12_;
						_tmp13_ = g_file_query_exists (file, NULL);
						if (_tmp13_) {
							exogenesis_previous_os_SetFSTabMountPath (self, fstabfile);
						}
						_tmp14_ = exogenesis_partition_info_get_MountPoint (pi);
						_tmp15_ = g_strdup_printf ("%s/etc/lsb-release", _tmp14_);
						lsbfile = _tmp15_;
						_tmp16_ = g_file_new_for_path (lsbfile);
						_g_object_unref0 (file);
						file = _tmp16_;
						_tmp17_ = g_file_query_exists (file, NULL);
						if (!_tmp17_) {
							const gchar* _tmp18_ = NULL;
							gchar* _tmp19_ = NULL;
							GFile* _tmp20_ = NULL;
							_tmp18_ = exogenesis_partition_info_get_MountPoint (pi);
							_tmp19_ = g_strdup_printf ("%s/var/log/installer/lsb-release", _tmp18_);
							_g_free0 (lsbfile);
							lsbfile = _tmp19_;
							_tmp20_ = g_file_new_for_path (lsbfile);
							_g_object_unref0 (file);
							file = _tmp20_;
						}
						_tmp21_ = g_file_query_exists (file, NULL);
						if (_tmp21_) {
							exogenesis_previous_os_SetLSBName (self, lsbfile, &hd);
						}
						_tmp22_ = exogenesis_partition_info_get_MountPoint (pi);
						_tmp23_ = g_strdup_printf ("%s/etc/passwd", _tmp22_);
						usrpwd = _tmp23_;
						_tmp24_ = g_file_new_for_path (usrpwd);
						_g_object_unref0 (file);
						file = _tmp24_;
						_tmp25_ = g_file_query_exists (file, NULL);
						if (_tmp25_) {
							exogenesis_previous_os_GetExistingUsers (self, usrpwd);
						}
						_g_free0 (usrpwd);
						_g_free0 (lsbfile);
						_g_object_unref0 (file);
						_g_free0 (fstabfile);
					}
					_g_object_unref0 (pi);
				}
				_g_object_unref0 (_pi_it);
			}
			_g_object_unref0 (hd);
		}
		_g_object_unref0 (_hd_list);
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


static void exogenesis_previous_os_SetFSTabMountPath (ExogenesisPreviousOS* self, const gchar* fstabfilepath) {
	gchar* _tmp0_ = NULL;
	gchar* fstabfile;
	gchar** lines = NULL;
	gint lines_length1 = 0;
	gint _lines_size_ = 0;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fstabfilepath != NULL);
	_tmp0_ = exogenesis_general_functions_ReadTextFile (exogenesis_gGenFunc, fstabfilepath);
	fstabfile = _tmp0_;
	_tmp1_ = strlen (fstabfile);
	if (_tmp1_ > 0) {
		gchar** _tmp2_;
		gchar** _tmp3_ = NULL;
		_tmp3_ = _tmp2_ = g_strsplit (fstabfile, "\n", 0);
		lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
		lines = _tmp3_;
		lines_length1 = _vala_array_length (_tmp2_);
		_lines_size_ = _vala_array_length (_tmp2_);
		{
			gchar** line_collection;
			int line_collection_length1;
			int line_it;
			line_collection = lines;
			line_collection_length1 = lines_length1;
			for (line_it = 0; line_it < lines_length1; line_it = line_it + 1) {
				gchar* _tmp4_;
				gchar* line;
				_tmp4_ = g_strdup (line_collection[line_it]);
				line = _tmp4_;
				{
					gboolean _tmp5_;
					_tmp5_ = g_str_has_prefix (line, "#");
					if (!_tmp5_) {
						gchar** _tmp6_;
						gchar** _tmp7_ = NULL;
						gchar** values;
						gint values_length1;
						gint _values_size_;
						gchar* _tmp8_;
						gchar* uuid;
						gboolean _tmp9_;
						_tmp7_ = _tmp6_ = g_strsplit (line, " ", 0);
						values = _tmp7_;
						values_length1 = _vala_array_length (_tmp6_);
						_values_size_ = _vala_array_length (_tmp6_);
						_tmp8_ = g_strdup (values[0]);
						uuid = _tmp8_;
						_tmp9_ = string_contains (uuid, "UUID");
						if (_tmp9_) {
							gchar** _tmp10_;
							gchar** _tmp11_ = NULL;
							gchar** uuidval;
							gint uuidval_length1;
							gint _uuidval_size_;
							gboolean _tmp12_;
							_tmp11_ = _tmp10_ = g_strsplit (uuid, "=", 0);
							uuidval = _tmp11_;
							uuidval_length1 = _vala_array_length (_tmp10_);
							_uuidval_size_ = _vala_array_length (_tmp10_);
							_tmp12_ = exogenesis_previous_os_InFSTab (self, uuidval[1]);
							if (!_tmp12_) {
								gee_abstract_map_set ((GeeAbstractMap*) self->priv->FSTab, uuidval[1], values[1]);
							}
							{
								GeeArrayList* _tmp13_;
								GeeArrayList* _hd_list;
								gint _tmp14_;
								gint _hd_size;
								gint _hd_index;
								_tmp13_ = _g_object_ref0 (exogenesis_gHDManager->HardDisks);
								_hd_list = _tmp13_;
								_tmp14_ = gee_collection_get_size ((GeeCollection*) _hd_list);
								_hd_size = _tmp14_;
								_hd_index = -1;
								while (TRUE) {
									gpointer _tmp15_ = NULL;
									ExogenesisHardDisk* hd;
									_hd_index = _hd_index + 1;
									if (!(_hd_index < _hd_size)) {
										break;
									}
									_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
									hd = (ExogenesisHardDisk*) _tmp15_;
									{
										GeeIterator* _tmp16_ = NULL;
										GeeIterator* _pi_it;
										_tmp16_ = gee_iterable_iterator ((GeeIterable*) hd);
										_pi_it = _tmp16_;
										while (TRUE) {
											gboolean _tmp17_;
											gpointer _tmp18_ = NULL;
											ExogenesisPartitionInfo* pi;
											const gchar* _tmp19_ = NULL;
											_tmp17_ = gee_iterator_next (_pi_it);
											if (!_tmp17_) {
												break;
											}
											_tmp18_ = gee_iterator_get (_pi_it);
											pi = (ExogenesisPartitionInfo*) _tmp18_;
											_tmp19_ = exogenesis_partition_info_get_UUID (pi);
											if (g_strcmp0 (_tmp19_, uuidval[1]) == 0) {
												exogenesis_partition_info_set_FSTabMountPoint (pi, values[1]);
											}
											_g_object_unref0 (pi);
										}
										_g_object_unref0 (_pi_it);
									}
									_g_object_unref0 (hd);
								}
								_g_object_unref0 (_hd_list);
							}
							uuidval = (_vala_array_free (uuidval, uuidval_length1, (GDestroyNotify) g_free), NULL);
						}
						_g_free0 (uuid);
						values = (_vala_array_free (values, values_length1, (GDestroyNotify) g_free), NULL);
					}
					_g_free0 (line);
				}
			}
		}
	}
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (fstabfile);
}


static gboolean exogenesis_previous_os_InFSTab (ExogenesisPreviousOS* self, const gchar* uuid) {
	gboolean result = FALSE;
	gboolean bFound;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uuid != NULL, FALSE);
	bFound = FALSE;
	{
		GeeSet* _tmp0_ = NULL;
		GeeSet* _tmp1_;
		GeeIterator* _tmp2_ = NULL;
		GeeIterator* _tmp3_;
		GeeIterator* _key_it;
		_tmp0_ = gee_map_get_keys ((GeeMap*) self->priv->FSTab);
		_tmp1_ = _tmp0_;
		_tmp2_ = gee_iterable_iterator ((GeeIterable*) _tmp1_);
		_tmp3_ = _tmp2_;
		_g_object_unref0 (_tmp1_);
		_key_it = _tmp3_;
		while (TRUE) {
			gboolean _tmp4_;
			gpointer _tmp5_ = NULL;
			gchar* key;
			_tmp4_ = gee_iterator_next (_key_it);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = gee_iterator_get (_key_it);
			key = (gchar*) _tmp5_;
			if (g_strcmp0 (key, uuid) == 0) {
				bFound = TRUE;
				_g_free0 (key);
				break;
			}
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
	result = bFound;
	return result;
}


static void exogenesis_previous_os_SetLSBName (ExogenesisPreviousOS* self, const gchar* lsbfilepath, ExogenesisHardDisk** hd) {
	gchar* _tmp0_ = NULL;
	gchar* lsbdata;
	gchar** lines = NULL;
	gint lines_length1 = 0;
	gint _lines_size_ = 0;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (lsbfilepath != NULL);
	g_return_if_fail (hd != NULL);
	_tmp0_ = exogenesis_general_functions_ReadTextFile (exogenesis_gGenFunc, lsbfilepath);
	lsbdata = _tmp0_;
	_tmp1_ = strlen (lsbdata);
	if (_tmp1_ > 0) {
		gchar** _tmp2_;
		gchar** _tmp3_ = NULL;
		gchar** _tmp4_;
		gchar** _tmp5_ = NULL;
		gchar** _tmp6_;
		gint _tmp6__length1;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* os;
		gchar** _tmp9_;
		gchar** _tmp10_ = NULL;
		gchar** _tmp11_;
		gint _tmp11__length1;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* ver;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_;
		_tmp3_ = _tmp2_ = g_strsplit (lsbdata, "\n", 0);
		lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
		lines = _tmp3_;
		lines_length1 = _vala_array_length (_tmp2_);
		_lines_size_ = _vala_array_length (_tmp2_);
		_tmp5_ = _tmp4_ = g_strsplit (lines[0], "=", 0);
		_tmp6_ = _tmp5_;
		_tmp6__length1 = _vala_array_length (_tmp4_);
		_tmp7_ = g_strdup (_tmp6_[1]);
		_tmp8_ = _tmp7_;
		_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
		os = _tmp8_;
		_tmp10_ = _tmp9_ = g_strsplit (lines[1], "=", 0);
		_tmp11_ = _tmp10_;
		_tmp11__length1 = _vala_array_length (_tmp9_);
		_tmp12_ = g_strdup (_tmp11_[1]);
		_tmp13_ = _tmp12_;
		_tmp11_ = (_vala_array_free (_tmp11_, _tmp11__length1, (GDestroyNotify) g_free), NULL);
		ver = _tmp13_;
		_tmp14_ = g_strdup_printf ("%s %s", os, ver);
		_tmp15_ = _tmp14_;
		exogenesis_hard_disk_set_PreviousOS (*hd, _tmp15_);
		_g_free0 (_tmp15_);
		_g_free0 (ver);
		_g_free0 (os);
	}
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (lsbdata);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void exogenesis_previous_os_GetExistingUsers (ExogenesisPreviousOS* self, const gchar* passwdfile) {
	gchar* _tmp0_ = NULL;
	gchar* filetext;
	gchar** lines = NULL;
	gint lines_length1 = 0;
	gint _lines_size_ = 0;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (passwdfile != NULL);
	_tmp0_ = exogenesis_general_functions_ReadTextFile (exogenesis_gGenFunc, passwdfile);
	filetext = _tmp0_;
	_tmp1_ = strlen (filetext);
	if (_tmp1_ > 0) {
		gchar** _tmp2_;
		gchar** _tmp3_ = NULL;
		_tmp3_ = _tmp2_ = g_strsplit (filetext, "\n", 0);
		lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
		lines = _tmp3_;
		lines_length1 = _vala_array_length (_tmp2_);
		_lines_size_ = _vala_array_length (_tmp2_);
		{
			gchar** userdetail_collection;
			int userdetail_collection_length1;
			int userdetail_it;
			userdetail_collection = lines;
			userdetail_collection_length1 = lines_length1;
			for (userdetail_it = 0; userdetail_it < lines_length1; userdetail_it = userdetail_it + 1) {
				gchar* _tmp4_;
				gchar* userdetail;
				_tmp4_ = g_strdup (userdetail_collection[userdetail_it]);
				userdetail = _tmp4_;
				{
					gint _tmp5_;
					_tmp5_ = strlen (userdetail);
					if (_tmp5_ > 0) {
						gchar** _tmp6_;
						gchar** _tmp7_ = NULL;
						gchar** userdata;
						gint userdata_length1;
						gint _userdata_size_;
						gboolean _tmp8_ = FALSE;
						const gchar* _tmp9_ = NULL;
						gint _tmp10_;
						_tmp7_ = _tmp6_ = g_strsplit (userdetail, ":", 0);
						userdata = _tmp7_;
						userdata_length1 = _vala_array_length (_tmp6_);
						_userdata_size_ = _vala_array_length (_tmp6_);
						_tmp9_ = string_to_string (userdata[2]);
						_tmp10_ = atoi (_tmp9_);
						if (_tmp10_ > 999) {
							const gchar* _tmp11_ = NULL;
							gint _tmp12_;
							gboolean _tmp13_;
							_tmp11_ = string_to_string (userdata[2]);
							_tmp12_ = atoi (_tmp11_);
							_tmp13_ = exogenesis_previous_os_UserExists (self, _tmp12_);
							_tmp8_ = !_tmp13_;
						} else {
							_tmp8_ = FALSE;
						}
						if (_tmp8_) {
							ExogenesisUserDetail* _tmp14_ = NULL;
							ExogenesisUserDetail* user;
							gchar** _tmp15_;
							gchar** _tmp16_ = NULL;
							gchar** detail;
							gint detail_length1;
							gint _detail_size_;
							const gchar* _tmp17_ = NULL;
							gint _tmp18_;
							const gchar* _tmp19_ = NULL;
							gint _tmp20_;
							_tmp14_ = exogenesis_user_detail_new ();
							user = _tmp14_;
							_tmp16_ = _tmp15_ = g_strsplit (userdata[4], ",", 0);
							detail = _tmp16_;
							detail_length1 = _vala_array_length (_tmp15_);
							_detail_size_ = _vala_array_length (_tmp15_);
							exogenesis_user_detail_set_Username (user, userdata[0]);
							exogenesis_user_detail_set_Type (user, (gchar) userdata[1]);
							_tmp17_ = string_to_string (userdata[2]);
							_tmp18_ = atoi (_tmp17_);
							exogenesis_user_detail_set_UserId (user, _tmp18_);
							_tmp19_ = string_to_string (userdata[3]);
							_tmp20_ = atoi (_tmp19_);
							exogenesis_user_detail_set_GroupId (user, _tmp20_);
							if (detail_length1 > 0) {
								exogenesis_user_detail_set_Fullname (user, detail[0]);
							}
							if (detail_length1 > 1) {
								exogenesis_user_detail_set_OfficeLocation (user, detail[1]);
							}
							if (detail_length1 > 2) {
								exogenesis_user_detail_set_WorkPhone (user, detail[2]);
							}
							if (detail_length1 > 3) {
								exogenesis_user_detail_set_HomePhone (user, detail[3]);
							}
							exogenesis_user_detail_set_HomeFolder (user, userdata[5]);
							exogenesis_user_detail_set_Shell (user, userdata[6]);
							gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_existingUsers, user);
							detail = (_vala_array_free (detail, detail_length1, (GDestroyNotify) g_free), NULL);
							_g_object_unref0 (user);
						}
						userdata = (_vala_array_free (userdata, userdata_length1, (GDestroyNotify) g_free), NULL);
					}
					_g_free0 (userdetail);
				}
			}
		}
	}
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (filetext);
}


static gboolean exogenesis_previous_os_UserExists (ExogenesisPreviousOS* self, gint uid) {
	gboolean result = FALSE;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	ret = FALSE;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _user_list;
		gint _tmp1_;
		gint _user_size;
		gint _user_index;
		_tmp0_ = _g_object_ref0 (self->priv->_existingUsers);
		_user_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _user_list);
		_user_size = _tmp1_;
		_user_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisUserDetail* user;
			gint _tmp3_;
			_user_index = _user_index + 1;
			if (!(_user_index < _user_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _user_list, _user_index);
			user = (ExogenesisUserDetail*) _tmp2_;
			_tmp3_ = exogenesis_user_detail_get_UserId (user);
			if (_tmp3_ == uid) {
				ret = TRUE;
				_g_object_unref0 (user);
				break;
			}
			_g_object_unref0 (user);
		}
		_g_object_unref0 (_user_list);
	}
	result = ret;
	return result;
}


ExogenesisPreviousOS* exogenesis_previous_os_construct (GType object_type) {
	ExogenesisPreviousOS* self = NULL;
	self = (ExogenesisPreviousOS*) g_type_create_instance (object_type);
	return self;
}


ExogenesisPreviousOS* exogenesis_previous_os_new (void) {
	return exogenesis_previous_os_construct (EXOGENESIS_TYPE_PREVIOUS_OS);
}


GeeArrayList* exogenesis_previous_os_get_ExistingUsers (ExogenesisPreviousOS* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_existingUsers;
	return result;
}


gint exogenesis_previous_os_get_ExistingUsersCount (ExogenesisPreviousOS* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->_existingUsers);
	result = (gint) _tmp0_;
	return result;
}


static void exogenesis_value_previous_os_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_previous_os_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_previous_os_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_previous_os_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_previous_os_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_previous_os_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_previous_os_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisPreviousOS* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_previous_os_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_previous_os_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisPreviousOS** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_previous_os_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_previous_os (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecPreviousOS* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_PREVIOUS_OS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_previous_os (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_PREVIOUS_OS), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_previous_os (GValue* value, gpointer v_object) {
	ExogenesisPreviousOS* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_PREVIOUS_OS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_PREVIOUS_OS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_previous_os_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_previous_os_unref (old);
	}
}


void exogenesis_value_take_previous_os (GValue* value, gpointer v_object) {
	ExogenesisPreviousOS* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_PREVIOUS_OS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_PREVIOUS_OS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_previous_os_unref (old);
	}
}


static void exogenesis_previous_os_class_init (ExogenesisPreviousOSClass * klass) {
	exogenesis_previous_os_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_PREVIOUS_OS_CLASS (klass)->finalize = exogenesis_previous_os_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisPreviousOSPrivate));
}


static void exogenesis_previous_os_instance_init (ExogenesisPreviousOS * self) {
	GeeHashMap* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	self->priv = EXOGENESIS_PREVIOUS_OS_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_str_hash, g_str_equal, NULL);
	self->priv->FSTab = _tmp0_;
	_tmp1_ = gee_array_list_new (EXOGENESIS_TYPE_USER_DETAIL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_existingUsers = _tmp1_;
	self->ref_count = 1;
}


static void exogenesis_previous_os_finalize (ExogenesisPreviousOS* obj) {
	ExogenesisPreviousOS * self;
	self = EXOGENESIS_PREVIOUS_OS (obj);
	_g_object_unref0 (self->priv->FSTab);
	_g_object_unref0 (self->priv->_existingUsers);
}


GType exogenesis_previous_os_get_type (void) {
	static volatile gsize exogenesis_previous_os_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_previous_os_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_previous_os_init, exogenesis_value_previous_os_free_value, exogenesis_value_previous_os_copy_value, exogenesis_value_previous_os_peek_pointer, "p", exogenesis_value_previous_os_collect_value, "p", exogenesis_value_previous_os_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisPreviousOSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_previous_os_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisPreviousOS), 0, (GInstanceInitFunc) exogenesis_previous_os_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_previous_os_type_id;
		exogenesis_previous_os_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisPreviousOS", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_previous_os_type_id__volatile, exogenesis_previous_os_type_id);
	}
	return exogenesis_previous_os_type_id__volatile;
}


gpointer exogenesis_previous_os_ref (gpointer instance) {
	ExogenesisPreviousOS* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_previous_os_unref (gpointer instance) {
	ExogenesisPreviousOS* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_PREVIOUS_OS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



