/* exoFCreatePartition.c generated by valac 0.12.1, the Vala compiler
 * generated from exoFCreatePartition.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <float.h>
#include <math.h>


#define EXOGENESIS_TYPE_FCREATE_PARTITION (exogenesis_fcreate_partition_get_type ())
#define EXOGENESIS_FCREATE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartition))
#define EXOGENESIS_FCREATE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartitionClass))
#define EXOGENESIS_IS_FCREATE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION))
#define EXOGENESIS_IS_FCREATE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FCREATE_PARTITION))
#define EXOGENESIS_FCREATE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartitionClass))

typedef struct _ExogenesisFCreatePartition ExogenesisFCreatePartition;
typedef struct _ExogenesisFCreatePartitionClass ExogenesisFCreatePartitionClass;
typedef struct _ExogenesisFCreatePartitionPrivate ExogenesisFCreatePartitionPrivate;

#define EXOGENESIS_TYPE_INSTALL_HARD_DISK (exogenesis_install_hard_disk_get_type ())
#define EXOGENESIS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDisk))
#define EXOGENESIS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))
#define EXOGENESIS_IS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_IS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_INSTALL_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))

typedef struct _ExogenesisInstallHardDisk ExogenesisInstallHardDisk;
typedef struct _ExogenesisInstallHardDiskClass ExogenesisInstallHardDiskClass;

#define EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED (exogenesis_fhd_config_advanced_get_type ())
#define EXOGENESIS_FHD_CONFIG_ADVANCED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvanced))
#define EXOGENESIS_FHD_CONFIG_ADVANCED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvancedClass))
#define EXOGENESIS_IS_FHD_CONFIG_ADVANCED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED))
#define EXOGENESIS_IS_FHD_CONFIG_ADVANCED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED))
#define EXOGENESIS_FHD_CONFIG_ADVANCED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvancedClass))

typedef struct _ExogenesisFHDConfigAdvanced ExogenesisFHDConfigAdvanced;
typedef struct _ExogenesisFHDConfigAdvancedClass ExogenesisFHDConfigAdvancedClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_FILESYSTEM_TYPE (exogenesis_filesystem_type_get_type ())
#define EXOGENESIS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemType))
#define EXOGENESIS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))
#define EXOGENESIS_IS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_IS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_FILESYSTEM_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))

typedef struct _ExogenesisFilesystemType ExogenesisFilesystemType;
typedef struct _ExogenesisFilesystemTypeClass ExogenesisFilesystemTypeClass;

#define EXOGENESIS_TYPE_MOUNT_POINT (exogenesis_mount_point_get_type ())
#define EXOGENESIS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPoint))
#define EXOGENESIS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))
#define EXOGENESIS_IS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_IS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_MOUNT_POINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))

typedef struct _ExogenesisMountPoint ExogenesisMountPoint;
typedef struct _ExogenesisMountPointClass ExogenesisMountPointClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;

#define EXOGENESIS_TYPE_MOUNT_POINTS (exogenesis_mount_points_get_type ())
#define EXOGENESIS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPoints))
#define EXOGENESIS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))
#define EXOGENESIS_IS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_IS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_MOUNT_POINTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))

typedef struct _ExogenesisMountPoints ExogenesisMountPoints;
typedef struct _ExogenesisMountPointsClass ExogenesisMountPointsClass;

#define EXOGENESIS_TYPE_GENERAL_FUNCTIONS (exogenesis_general_functions_get_type ())
#define EXOGENESIS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctions))
#define EXOGENESIS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_GENERAL_FUNCTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))

typedef struct _ExogenesisGeneralFunctions ExogenesisGeneralFunctions;
typedef struct _ExogenesisGeneralFunctionsClass ExogenesisGeneralFunctionsClass;

struct _ExogenesisFCreatePartition {
	GtkLayout parent_instance;
	ExogenesisFCreatePartitionPrivate * priv;
};

struct _ExogenesisFCreatePartitionClass {
	GtkLayoutClass parent_class;
};

struct _ExogenesisFCreatePartitionPrivate {
	GtkBox* boxCreatePartition;
	GtkLabel* lblCPTitle;
	GtkBox* boxCPMain;
	GtkGrid* grdCPOptions;
	GtkLabel* lblCPPartType;
	GtkLabel* lblCPMountPoint;
	GtkLabel* lblCPLabel;
	GtkComboBox* cboCPPartType;
	GtkComboBox* cboCPMountPoint;
	GtkEntry* txtCPLabel;
	GtkBox* boxCPSize;
	GtkSpinButton* spnCPSize;
	GtkScale* sclCPSize;
	GtkBox* boxCPButtons;
	GtkButton* btnCPCancel;
	GtkImage* imgCPBtnCancel;
	GtkLabel* lblCPBtnCancel;
	GtkButton* btnCPApply;
	GtkImage* imgCPBtnApply;
	GtkLabel* lblCPBtnApply;
	GtkListStore* _lstPartTypes;
	GtkListStore* _lstMountPoints;
	ExogenesisInstallHardDisk* _iHD;
	ExogenesisFHDConfigAdvanced* _Owner;
};


static gpointer exogenesis_fcreate_partition_parent_class = NULL;
extern gchar* exogenesis_AppPath;
extern ExogenesisHDManager* exogenesis_gHDManager;
extern ExogenesisGeneralFunctions* exogenesis_gGenFunc;

GType exogenesis_fcreate_partition_get_type (void) G_GNUC_CONST;
GType exogenesis_install_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_fhd_config_advanced_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_FCREATE_PARTITION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartitionPrivate))
enum  {
	EXOGENESIS_FCREATE_PARTITION_DUMMY_PROPERTY
};
GType exogenesis_filesystem_type_get_type (void) G_GNUC_CONST;
GType exogenesis_mount_point_get_type (void) G_GNUC_CONST;
ExogenesisFCreatePartition* exogenesis_fcreate_partition_new (ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner);
ExogenesisFCreatePartition* exogenesis_fcreate_partition_construct (GType object_type, ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner);
static void exogenesis_fcreate_partition_Build (ExogenesisFCreatePartition* self);
static void exogenesis_fcreate_partition_SetMaxAvailable (ExogenesisFCreatePartition* self, guint64 available);
static void exogenesis_fcreate_partition_GetFileSystemTypes (ExogenesisFCreatePartition* self);
static void exogenesis_fcreate_partition_GetMountPoints (ExogenesisFCreatePartition* self);
void exogenesis_fcreate_partition_OnCboFileTypes_Changed (ExogenesisFCreatePartition* self);
static void _exogenesis_fcreate_partition_OnCboFileTypes_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
static void exogenesis_fcreate_partition_OnBtnApplyCP_Click (ExogenesisFCreatePartition* self);
static void _exogenesis_fcreate_partition_OnBtnApplyCP_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void exogenesis_fcreate_partition_OnBtnCancelCP_Click (ExogenesisFCreatePartition* self);
static void _exogenesis_fcreate_partition_OnBtnCancelCP_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
GType exogenesis_mount_points_get_type (void) G_GNUC_CONST;
ExogenesisMountPoints* exogenesis_hd_manager_GetMountPoints (ExogenesisHDManager* self);
const gchar* exogenesis_mount_point_get_Key (ExogenesisMountPoint* self);
const gchar* exogenesis_mount_point_get_Path (ExogenesisMountPoint* self);
gboolean exogenesis_fhd_config_advanced_IsMountPointUsed (ExogenesisFHDConfigAdvanced* self, const gchar* MountPoint);
static void exogenesis_fcreate_partition_SetMountToNone (ExogenesisFCreatePartition* self);
GeeArrayList* exogenesis_hd_manager_get_FileSystemTypes (ExogenesisHDManager* self);
const gchar* exogenesis_filesystem_type_get_Name (ExogenesisFilesystemType* self);
static ExogenesisFilesystemType* exogenesis_fcreate_partition_GetSelectedFileType (ExogenesisFCreatePartition* self);
static gchar* exogenesis_fcreate_partition_GetSelectedMountPoint (ExogenesisFCreatePartition* self);
static gchar* exogenesis_fcreate_partition_GetSelectedMountPointID (ExogenesisFCreatePartition* self);
gpointer exogenesis_general_functions_ref (gpointer instance);
void exogenesis_general_functions_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_general_functions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_general_functions (GValue* value, gpointer v_object);
void exogenesis_value_take_general_functions (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_general_functions (const GValue* value);
GType exogenesis_general_functions_get_type (void) G_GNUC_CONST;
GtkResponseType exogenesis_general_functions_ShowDialogue (ExogenesisGeneralFunctions* self, const gchar* Title, const gchar* Message, GtkButtonsType buttons, GtkMessageType type);
static void exogenesis_fcreate_partition_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


ExogenesisFCreatePartition* exogenesis_fcreate_partition_construct (GType object_type, ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner) {
	ExogenesisFCreatePartition * self = NULL;
	ExogenesisFHDConfigAdvanced* _tmp0_;
	g_return_val_if_fail (hd != NULL, NULL);
	g_return_val_if_fail (owner != NULL, NULL);
	self = (ExogenesisFCreatePartition*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (owner);
	_g_object_unref0 (self->priv->_Owner);
	self->priv->_Owner = _tmp0_;
	if (hd != NULL) {
		ExogenesisInstallHardDisk* _tmp1_;
		_tmp1_ = _g_object_ref0 (hd);
		_g_object_unref0 (self->priv->_iHD);
		self->priv->_iHD = _tmp1_;
	}
	exogenesis_fcreate_partition_Build (self);
	exogenesis_fcreate_partition_SetMaxAvailable (self, availablesize);
	exogenesis_fcreate_partition_GetFileSystemTypes (self);
	exogenesis_fcreate_partition_GetMountPoints (self);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->boxCreatePartition);
	return self;
}


ExogenesisFCreatePartition* exogenesis_fcreate_partition_new (ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner) {
	return exogenesis_fcreate_partition_construct (EXOGENESIS_TYPE_FCREATE_PARTITION, hd, availablesize, owner);
}


static void _exogenesis_fcreate_partition_OnCboFileTypes_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	exogenesis_fcreate_partition_OnCboFileTypes_Changed (self);
}


static void _exogenesis_fcreate_partition_OnBtnApplyCP_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fcreate_partition_OnBtnApplyCP_Click (self);
}


static void _exogenesis_fcreate_partition_OnBtnCancelCP_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fcreate_partition_OnBtnCancelCP_Click (self);
}


static void exogenesis_fcreate_partition_Build (ExogenesisFCreatePartition* self) {
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* builder;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GObject* _tmp3_ = NULL;
	GtkBox* _tmp4_;
	GObject* _tmp5_ = NULL;
	GtkLabel* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkBox* _tmp8_;
	GObject* _tmp9_ = NULL;
	GtkGrid* _tmp10_;
	GObject* _tmp11_ = NULL;
	GtkLabel* _tmp12_;
	GObject* _tmp13_ = NULL;
	GtkLabel* _tmp14_;
	GObject* _tmp15_ = NULL;
	GtkLabel* _tmp16_;
	GObject* _tmp17_ = NULL;
	GtkComboBox* _tmp18_;
	GObject* _tmp19_ = NULL;
	GtkComboBox* _tmp20_;
	GObject* _tmp21_ = NULL;
	GtkEntry* _tmp22_;
	GObject* _tmp23_ = NULL;
	GtkBox* _tmp24_;
	GObject* _tmp25_ = NULL;
	GtkSpinButton* _tmp26_;
	GObject* _tmp27_ = NULL;
	GtkScale* _tmp28_;
	GObject* _tmp29_ = NULL;
	GtkBox* _tmp30_;
	GObject* _tmp31_ = NULL;
	GtkButton* _tmp32_;
	GObject* _tmp33_ = NULL;
	GtkImage* _tmp34_;
	GObject* _tmp35_ = NULL;
	GtkLabel* _tmp36_;
	GObject* _tmp37_ = NULL;
	GtkButton* _tmp38_;
	GObject* _tmp39_ = NULL;
	GtkImage* _tmp40_;
	GObject* _tmp41_ = NULL;
	GtkLabel* _tmp42_;
	GtkCellRendererText* _tmp43_ = NULL;
	GtkCellRendererText* cellFormat;
	GtkCellRendererText* _tmp44_ = NULL;
	GtkCellRendererText* cellMP;
	gint _tmp45_;
	gint _tmp46_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	_tmp1_ = g_strdup_printf ("%s/src/exogenesis.ui", exogenesis_AppPath);
	_tmp2_ = _tmp1_;
	gtk_builder_add_from_file (builder, _tmp2_, &_inner_error_);
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		goto __catch3_g_error;
	}
	_tmp3_ = gtk_builder_get_object (builder, "boxCreatePartition");
	_tmp4_ = _g_object_ref0 (GTK_BOX (_tmp3_));
	_g_object_unref0 (self->priv->boxCreatePartition);
	self->priv->boxCreatePartition = _tmp4_;
	_tmp5_ = gtk_builder_get_object (builder, "lblCPTitle");
	_tmp6_ = _g_object_ref0 (GTK_LABEL (_tmp5_));
	_g_object_unref0 (self->priv->lblCPTitle);
	self->priv->lblCPTitle = _tmp6_;
	_tmp7_ = gtk_builder_get_object (builder, "boxCPMain");
	_tmp8_ = _g_object_ref0 (GTK_BOX (_tmp7_));
	_g_object_unref0 (self->priv->boxCPMain);
	self->priv->boxCPMain = _tmp8_;
	_tmp9_ = gtk_builder_get_object (builder, "grdCPOptions");
	_tmp10_ = _g_object_ref0 (GTK_GRID (_tmp9_));
	_g_object_unref0 (self->priv->grdCPOptions);
	self->priv->grdCPOptions = _tmp10_;
	_tmp11_ = gtk_builder_get_object (builder, "lblCPPartType");
	_tmp12_ = _g_object_ref0 (GTK_LABEL (_tmp11_));
	_g_object_unref0 (self->priv->lblCPPartType);
	self->priv->lblCPPartType = _tmp12_;
	_tmp13_ = gtk_builder_get_object (builder, "lblCPMountPoint");
	_tmp14_ = _g_object_ref0 (GTK_LABEL (_tmp13_));
	_g_object_unref0 (self->priv->lblCPMountPoint);
	self->priv->lblCPMountPoint = _tmp14_;
	_tmp15_ = gtk_builder_get_object (builder, "lblCPLabel");
	_tmp16_ = _g_object_ref0 (GTK_LABEL (_tmp15_));
	_g_object_unref0 (self->priv->lblCPLabel);
	self->priv->lblCPLabel = _tmp16_;
	_tmp17_ = gtk_builder_get_object (builder, "cboCPPartType");
	_tmp18_ = _g_object_ref0 (GTK_COMBO_BOX (_tmp17_));
	_g_object_unref0 (self->priv->cboCPPartType);
	self->priv->cboCPPartType = _tmp18_;
	_tmp19_ = gtk_builder_get_object (builder, "cboCPMountPoint");
	_tmp20_ = _g_object_ref0 (GTK_COMBO_BOX (_tmp19_));
	_g_object_unref0 (self->priv->cboCPMountPoint);
	self->priv->cboCPMountPoint = _tmp20_;
	_tmp21_ = gtk_builder_get_object (builder, "txtCPLabel");
	_tmp22_ = _g_object_ref0 (GTK_ENTRY (_tmp21_));
	_g_object_unref0 (self->priv->txtCPLabel);
	self->priv->txtCPLabel = _tmp22_;
	_tmp23_ = gtk_builder_get_object (builder, "boxCPSize");
	_tmp24_ = _g_object_ref0 (GTK_BOX (_tmp23_));
	_g_object_unref0 (self->priv->boxCPSize);
	self->priv->boxCPSize = _tmp24_;
	_tmp25_ = gtk_builder_get_object (builder, "spnCPSize");
	_tmp26_ = _g_object_ref0 (GTK_SPIN_BUTTON (_tmp25_));
	_g_object_unref0 (self->priv->spnCPSize);
	self->priv->spnCPSize = _tmp26_;
	_tmp27_ = gtk_builder_get_object (builder, "sclCPSize");
	_tmp28_ = _g_object_ref0 (GTK_SCALE (_tmp27_));
	_g_object_unref0 (self->priv->sclCPSize);
	self->priv->sclCPSize = _tmp28_;
	_tmp29_ = gtk_builder_get_object (builder, "boxCPButtons");
	_tmp30_ = _g_object_ref0 (GTK_BOX (_tmp29_));
	_g_object_unref0 (self->priv->boxCPButtons);
	self->priv->boxCPButtons = _tmp30_;
	_tmp31_ = gtk_builder_get_object (builder, "btnCPCancel");
	_tmp32_ = _g_object_ref0 (GTK_BUTTON (_tmp31_));
	_g_object_unref0 (self->priv->btnCPCancel);
	self->priv->btnCPCancel = _tmp32_;
	_tmp33_ = gtk_builder_get_object (builder, "imgCPBtnCancel");
	_tmp34_ = _g_object_ref0 (GTK_IMAGE (_tmp33_));
	_g_object_unref0 (self->priv->imgCPBtnCancel);
	self->priv->imgCPBtnCancel = _tmp34_;
	_tmp35_ = gtk_builder_get_object (builder, "lblCPBtnCancel");
	_tmp36_ = _g_object_ref0 (GTK_LABEL (_tmp35_));
	_g_object_unref0 (self->priv->lblCPBtnCancel);
	self->priv->lblCPBtnCancel = _tmp36_;
	_tmp37_ = gtk_builder_get_object (builder, "btnCPApply");
	_tmp38_ = _g_object_ref0 (GTK_BUTTON (_tmp37_));
	_g_object_unref0 (self->priv->btnCPApply);
	self->priv->btnCPApply = _tmp38_;
	_tmp39_ = gtk_builder_get_object (builder, "imgCPBtnApply");
	_tmp40_ = _g_object_ref0 (GTK_IMAGE (_tmp39_));
	_g_object_unref0 (self->priv->imgCPBtnApply);
	self->priv->imgCPBtnApply = _tmp40_;
	_tmp41_ = gtk_builder_get_object (builder, "lblCPBtnApply");
	_tmp42_ = _g_object_ref0 (GTK_LABEL (_tmp41_));
	_g_object_unref0 (self->priv->lblCPBtnApply);
	self->priv->lblCPBtnApply = _tmp42_;
	g_signal_connect_object (self->priv->cboCPPartType, "changed", (GCallback) _exogenesis_fcreate_partition_OnCboFileTypes_Changed_gtk_combo_box_changed, self, 0);
	g_signal_connect_object (self->priv->btnCPApply, "clicked", (GCallback) _exogenesis_fcreate_partition_OnBtnApplyCP_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->btnCPCancel, "clicked", (GCallback) _exogenesis_fcreate_partition_OnBtnCancelCP_Click_gtk_button_clicked, self, 0);
	gtk_combo_box_set_model (self->priv->cboCPPartType, (GtkTreeModel*) self->priv->_lstPartTypes);
	_tmp43_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	cellFormat = g_object_ref_sink (_tmp43_);
	gtk_cell_layout_pack_start ((GtkCellLayout*) self->priv->cboCPPartType, (GtkCellRenderer*) cellFormat, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) self->priv->cboCPPartType, (GtkCellRenderer*) cellFormat, "text", 0);
	gtk_combo_box_set_model (self->priv->cboCPMountPoint, (GtkTreeModel*) self->priv->_lstMountPoints);
	_tmp44_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	cellMP = g_object_ref_sink (_tmp44_);
	gtk_cell_layout_pack_start ((GtkCellLayout*) self->priv->cboCPMountPoint, (GtkCellRenderer*) cellMP, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) self->priv->cboCPMountPoint, (GtkCellRenderer*) cellMP, "text", 0);
	g_object_get ((GtkWidget*) self->priv->boxCreatePartition, "width-request", &_tmp45_, NULL);
	g_object_set ((GtkWidget*) self, "width-request", _tmp45_, NULL);
	g_object_get ((GtkWidget*) self->priv->boxCreatePartition, "height-request", &_tmp46_, NULL);
	g_object_set ((GtkWidget*) self, "height-request", _tmp46_, NULL);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (cellMP);
	_g_object_unref0 (cellFormat);
	_g_object_unref0 (builder);
	goto __finally3;
	__catch3_g_error:
	{
		GError * err;
		gchar* _tmp47_;
		gchar* _tmp48_;
		GtkMessageDialog* _tmp49_ = NULL;
		GtkMessageDialog* _tmp50_;
		GtkMessageDialog* msg;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp47_ = g_strconcat ("Failed to load UI\n", err->message, NULL);
		_tmp48_ = _tmp47_;
		_tmp49_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CANCEL, _tmp48_);
		_tmp50_ = g_object_ref_sink (_tmp49_);
		_g_free0 (_tmp48_);
		msg = _tmp50_;
		gtk_dialog_run ((GtkDialog*) msg);
		gtk_main_quit ();
		_g_object_unref0 (msg);
		_g_error_free0 (err);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void exogenesis_fcreate_partition_GetMountPoints (ExogenesisFCreatePartition* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->_lstMountPoints);
	{
		ExogenesisMountPoints* _tmp0_ = NULL;
		ExogenesisMountPoints* _tmp1_;
		GeeIterator* _tmp2_ = NULL;
		GeeIterator* _tmp3_;
		GeeIterator* _mp_it;
		_tmp0_ = exogenesis_hd_manager_GetMountPoints (exogenesis_gHDManager);
		_tmp1_ = _tmp0_;
		_tmp2_ = gee_iterable_iterator ((GeeIterable*) _tmp1_);
		_tmp3_ = _tmp2_;
		_g_object_unref0 (_tmp1_);
		_mp_it = _tmp3_;
		while (TRUE) {
			gboolean _tmp4_;
			gpointer _tmp5_ = NULL;
			ExogenesisMountPoint* mp;
			gchar* sDisplay = NULL;
			const gchar* _tmp6_ = NULL;
			gboolean _tmp12_;
			_tmp4_ = gee_iterator_next (_mp_it);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = gee_iterator_get (_mp_it);
			mp = (ExogenesisMountPoint*) _tmp5_;
			_tmp6_ = exogenesis_mount_point_get_Key (mp);
			if (g_strcmp0 (_tmp6_, "none") != 0) {
				const gchar* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp7_ = exogenesis_mount_point_get_Key (mp);
				_tmp8_ = exogenesis_mount_point_get_Path (mp);
				_tmp9_ = g_strdup_printf ("%s - %s", _tmp7_, _tmp8_);
				_g_free0 (sDisplay);
				sDisplay = _tmp9_;
			} else {
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				_tmp10_ = exogenesis_mount_point_get_Key (mp);
				_tmp11_ = g_strdup_printf ("%s", _tmp10_);
				_g_free0 (sDisplay);
				sDisplay = _tmp11_;
			}
			_tmp12_ = exogenesis_fhd_config_advanced_IsMountPointUsed (self->priv->_Owner, sDisplay);
			if (!_tmp12_) {
				GtkTreeIter _tmp13_ = {0};
				gtk_list_store_append (self->priv->_lstMountPoints, &_tmp13_);
				iter = _tmp13_;
				gtk_list_store_set (self->priv->_lstMountPoints, &iter, 0, sDisplay, 1, mp, -1);
			}
			_g_free0 (sDisplay);
			_g_object_unref0 (mp);
		}
		_g_object_unref0 (_mp_it);
	}
	gtk_combo_box_set_active (self->priv->cboCPMountPoint, 0);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


void exogenesis_fcreate_partition_OnCboFileTypes_Changed (ExogenesisFCreatePartition* self) {
	GtkTreeIter iter = {0};
	GValue v = {0};
	gchar* s = NULL;
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	gtk_combo_box_get_active_iter (self->priv->cboCPPartType, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartTypes, &iter, 2, &_tmp1_);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	v = _tmp1_;
	_tmp2_ = g_value_get_string (&v);
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (s);
	s = _tmp3_;
	_tmp5_ = g_utf8_strdown (s, (gssize) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = string_contains (_tmp6_, "swap");
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	if (_tmp8_) {
		_tmp4_ = TRUE;
	} else {
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gboolean _tmp11_;
		_tmp9_ = g_utf8_strdown (s, (gssize) (-1));
		_tmp10_ = _tmp9_;
		_tmp11_ = string_contains (_tmp10_, "extended partition");
		_tmp4_ = _tmp11_;
		_g_free0 (_tmp10_);
	}
	if (_tmp4_) {
		exogenesis_fcreate_partition_SetMountToNone (self);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->cboCPMountPoint, FALSE);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->txtCPLabel, FALSE);
	} else {
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->cboCPMountPoint, TRUE);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->txtCPLabel, TRUE);
	}
	_g_free0 (s);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
}


static void exogenesis_fcreate_partition_GetFileSystemTypes (ExogenesisFCreatePartition* self) {
	GtkTreeIter iter = {0};
	gint idxExt4;
	gint i;
	g_return_if_fail (self != NULL);
	idxExt4 = 0;
	i = 0;
	{
		GeeArrayList* _tmp0_ = NULL;
		GeeArrayList* _tmp1_;
		GeeArrayList* _f_list;
		gint _tmp2_;
		gint _f_size;
		gint _f_index;
		_tmp0_ = exogenesis_hd_manager_get_FileSystemTypes (exogenesis_gHDManager);
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_f_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _f_list);
		_f_size = _tmp2_;
		_f_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			ExogenesisFilesystemType* f;
			GtkTreeIter _tmp4_ = {0};
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_ = NULL;
			gchar* sDisplay;
			gchar* _tmp7_ = NULL;
			gchar* _tmp8_;
			gboolean _tmp9_;
			gboolean _tmp10_;
			_f_index = _f_index + 1;
			if (!(_f_index < _f_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _f_list, _f_index);
			f = (ExogenesisFilesystemType*) _tmp3_;
			gtk_list_store_append (self->priv->_lstPartTypes, &_tmp4_);
			iter = _tmp4_;
			_tmp5_ = exogenesis_filesystem_type_get_Name (f);
			_tmp6_ = g_strdup_printf ("%s", _tmp5_);
			sDisplay = _tmp6_;
			gtk_list_store_set (self->priv->_lstPartTypes, &iter, 0, sDisplay, 1, f, -1, -1);
			_tmp7_ = g_utf8_strdown (sDisplay, (gssize) (-1));
			_tmp8_ = _tmp7_;
			_tmp9_ = string_contains (_tmp8_, "ext4");
			_tmp10_ = _tmp9_;
			_g_free0 (_tmp8_);
			if (_tmp10_) {
				idxExt4 = i;
			}
			i++;
			_g_free0 (sDisplay);
			_g_object_unref0 (f);
		}
		_g_object_unref0 (_f_list);
	}
	gtk_combo_box_set_active (self->priv->cboCPPartType, idxExt4);
}


static void exogenesis_fcreate_partition_SetMaxAvailable (ExogenesisFCreatePartition* self, guint64 available) {
	g_return_if_fail (self != NULL);
	if (available > 0) {
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->spnCPSize, TRUE);
		gtk_spin_button_set_range (self->priv->spnCPSize, (gdouble) 0, (gdouble) available);
	} else {
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->spnCPSize, FALSE);
	}
}


static ExogenesisFilesystemType* exogenesis_fcreate_partition_GetSelectedFileType (ExogenesisFCreatePartition* self) {
	ExogenesisFilesystemType* result = NULL;
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	ExogenesisFilesystemType* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_combo_box_get_active_iter (self->priv->cboCPPartType, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartTypes, &iter, 1, &_tmp1_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp1_;
	_tmp2_ = _g_object_ref0 (g_value_get_object (&val));
	result = _tmp2_;
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return result;
}


static void exogenesis_fcreate_partition_SetMountToNone (ExogenesisFCreatePartition* self) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstMountPoints, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue gVal = {0};
			GValue _tmp3_ = {0};
			const gchar* _tmp4_ = NULL;
			gchar* _tmp5_ = NULL;
			gchar* _tmp6_;
			gboolean _tmp7_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstMountPoints, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstMountPoints, &iter, 0, &_tmp3_);
			G_IS_VALUE (&gVal) ? (g_value_unset (&gVal), NULL) : NULL;
			gVal = _tmp3_;
			_tmp4_ = g_value_get_string (&gVal);
			_tmp5_ = g_utf8_strdown (_tmp4_, (gssize) (-1));
			_tmp6_ = _tmp5_;
			_tmp7_ = g_strcmp0 (_tmp6_, "none") == 0;
			_g_free0 (_tmp6_);
			if (_tmp7_) {
				gtk_combo_box_set_active_iter (self->priv->cboCPMountPoint, &iter);
				G_IS_VALUE (&gVal) ? (g_value_unset (&gVal), NULL) : NULL;
				break;
			}
			G_IS_VALUE (&gVal) ? (g_value_unset (&gVal), NULL) : NULL;
		}
	}
}


static gchar* exogenesis_fcreate_partition_GetSelectedMountPoint (ExogenesisFCreatePartition* self) {
	gchar* result = NULL;
	GtkTreeIter iter = {0};
	GValue v = {0};
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_combo_box_get_active_iter (self->priv->cboCPMountPoint, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstMountPoints, &iter, 2, &_tmp1_);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	v = _tmp1_;
	_tmp2_ = g_value_get_string (&v);
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	return result;
}


static gchar* exogenesis_fcreate_partition_GetSelectedMountPointID (ExogenesisFCreatePartition* self) {
	gchar* result = NULL;
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_combo_box_get_active_iter (self->priv->cboCPMountPoint, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstMountPoints, &iter, 0, &_tmp1_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp1_;
	_tmp2_ = g_value_get_string (&val);
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return result;
}


static void exogenesis_fcreate_partition_OnBtnApplyCP_Click (ExogenesisFCreatePartition* self) {
	g_return_if_fail (self != NULL);
}


static void exogenesis_fcreate_partition_OnBtnCancelCP_Click (ExogenesisFCreatePartition* self) {
	GtkResponseType _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = exogenesis_general_functions_ShowDialogue (exogenesis_gGenFunc, "Abort Create Partition", "Cancel and return to previous screen?", GTK_BUTTONS_YES_NO, GTK_MESSAGE_QUESTION);
	if (_tmp0_ == GTK_RESPONSE_YES) {
		GtkContainer* _tmp1_ = NULL;
		_tmp1_ = gtk_widget_get_parent ((GtkWidget*) self);
		gtk_widget_destroy ((GtkWidget*) _tmp1_);
	}
}


static void exogenesis_fcreate_partition_class_init (ExogenesisFCreatePartitionClass * klass) {
	exogenesis_fcreate_partition_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisFCreatePartitionPrivate));
	G_OBJECT_CLASS (klass)->finalize = exogenesis_fcreate_partition_finalize;
}


static void exogenesis_fcreate_partition_instance_init (ExogenesisFCreatePartition * self) {
	GtkListStore* _tmp0_ = NULL;
	GtkListStore* _tmp1_ = NULL;
	self->priv = EXOGENESIS_FCREATE_PARTITION_GET_PRIVATE (self);
	_tmp0_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_FILESYSTEM_TYPE);
	self->priv->_lstPartTypes = _tmp0_;
	_tmp1_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_MOUNT_POINT);
	self->priv->_lstMountPoints = _tmp1_;
}


static void exogenesis_fcreate_partition_finalize (GObject* obj) {
	ExogenesisFCreatePartition * self;
	self = EXOGENESIS_FCREATE_PARTITION (obj);
	_g_object_unref0 (self->priv->boxCreatePartition);
	_g_object_unref0 (self->priv->lblCPTitle);
	_g_object_unref0 (self->priv->boxCPMain);
	_g_object_unref0 (self->priv->grdCPOptions);
	_g_object_unref0 (self->priv->lblCPPartType);
	_g_object_unref0 (self->priv->lblCPMountPoint);
	_g_object_unref0 (self->priv->lblCPLabel);
	_g_object_unref0 (self->priv->cboCPPartType);
	_g_object_unref0 (self->priv->cboCPMountPoint);
	_g_object_unref0 (self->priv->txtCPLabel);
	_g_object_unref0 (self->priv->boxCPSize);
	_g_object_unref0 (self->priv->spnCPSize);
	_g_object_unref0 (self->priv->sclCPSize);
	_g_object_unref0 (self->priv->boxCPButtons);
	_g_object_unref0 (self->priv->btnCPCancel);
	_g_object_unref0 (self->priv->imgCPBtnCancel);
	_g_object_unref0 (self->priv->lblCPBtnCancel);
	_g_object_unref0 (self->priv->btnCPApply);
	_g_object_unref0 (self->priv->imgCPBtnApply);
	_g_object_unref0 (self->priv->lblCPBtnApply);
	_g_object_unref0 (self->priv->_lstPartTypes);
	_g_object_unref0 (self->priv->_lstMountPoints);
	_g_object_unref0 (self->priv->_iHD);
	_g_object_unref0 (self->priv->_Owner);
	G_OBJECT_CLASS (exogenesis_fcreate_partition_parent_class)->finalize (obj);
}


GType exogenesis_fcreate_partition_get_type (void) {
	static volatile gsize exogenesis_fcreate_partition_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fcreate_partition_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisFCreatePartitionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_fcreate_partition_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisFCreatePartition), 0, (GInstanceInitFunc) exogenesis_fcreate_partition_instance_init, NULL };
		GType exogenesis_fcreate_partition_type_id;
		exogenesis_fcreate_partition_type_id = g_type_register_static (GTK_TYPE_LAYOUT, "ExogenesisFCreatePartition", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_fcreate_partition_type_id__volatile, exogenesis_fcreate_partition_type_id);
	}
	return exogenesis_fcreate_partition_type_id__volatile;
}



