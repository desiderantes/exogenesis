/* exoHardDiskMgr.c generated by valac 0.12.1, the Vala compiler
 * generated from exoHardDiskMgr.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <gdu/gdu.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;
typedef struct _ExogenesisHDManagerPrivate ExogenesisHDManagerPrivate;

#define EXOGENESIS_TYPE_HARD_DISK (exogenesis_hard_disk_get_type ())
#define EXOGENESIS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDisk))
#define EXOGENESIS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))
#define EXOGENESIS_IS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_IS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))

typedef struct _ExogenesisHardDisk ExogenesisHardDisk;
typedef struct _ExogenesisHardDiskClass ExogenesisHardDiskClass;

#define EXOGENESIS_TYPE_MOUNT_POINTS (exogenesis_mount_points_get_type ())
#define EXOGENESIS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPoints))
#define EXOGENESIS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))
#define EXOGENESIS_IS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_IS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_MOUNT_POINTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))

typedef struct _ExogenesisMountPoints ExogenesisMountPoints;
typedef struct _ExogenesisMountPointsClass ExogenesisMountPointsClass;

#define EXOGENESIS_TYPE_FILESYSTEM_TYPE (exogenesis_filesystem_type_get_type ())
#define EXOGENESIS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemType))
#define EXOGENESIS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))
#define EXOGENESIS_IS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_IS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_FILESYSTEM_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))

typedef struct _ExogenesisFilesystemType ExogenesisFilesystemType;
typedef struct _ExogenesisFilesystemTypeClass ExogenesisFilesystemTypeClass;

#define EXOGENESIS_TYPE_INSTALL_HARD_DISK (exogenesis_install_hard_disk_get_type ())
#define EXOGENESIS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDisk))
#define EXOGENESIS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))
#define EXOGENESIS_IS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_IS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_INSTALL_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))

typedef struct _ExogenesisInstallHardDisk ExogenesisInstallHardDisk;
typedef struct _ExogenesisInstallHardDiskClass ExogenesisInstallHardDiskClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_PARTITION_INFO (exogenesis_partition_info_get_type ())
#define EXOGENESIS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfo))
#define EXOGENESIS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))
#define EXOGENESIS_IS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_IS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_PARTITION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))

typedef struct _ExogenesisPartitionInfo ExogenesisPartitionInfo;
typedef struct _ExogenesisPartitionInfoClass ExogenesisPartitionInfoClass;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define EXOGENESIS_TYPE_INSTALL_PARTITION (exogenesis_install_partition_get_type ())
#define EXOGENESIS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartition))
#define EXOGENESIS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))
#define EXOGENESIS_IS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_IS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_INSTALL_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))

typedef struct _ExogenesisInstallPartition ExogenesisInstallPartition;
typedef struct _ExogenesisInstallPartitionClass ExogenesisInstallPartitionClass;
typedef struct _ExogenesisParamSpecHDManager ExogenesisParamSpecHDManager;
typedef struct _ExogenesisHardDiskPrivate ExogenesisHardDiskPrivate;
typedef struct _ExogenesisPartitionInfoPrivate ExogenesisPartitionInfoPrivate;
typedef struct _ExogenesisFilesystemTypePrivate ExogenesisFilesystemTypePrivate;
typedef struct _ExogenesisMountPointsPrivate ExogenesisMountPointsPrivate;

#define EXOGENESIS_TYPE_MOUNT_POINT (exogenesis_mount_point_get_type ())
#define EXOGENESIS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPoint))
#define EXOGENESIS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))
#define EXOGENESIS_IS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_IS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_MOUNT_POINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))

typedef struct _ExogenesisMountPoint ExogenesisMountPoint;
typedef struct _ExogenesisMountPointClass ExogenesisMountPointClass;
typedef struct _ExogenesisMountPointPrivate ExogenesisMountPointPrivate;

#define EXOGENESIS_TYPE_DEFAULT_SCHEMA (exogenesis_default_schema_get_type ())
#define EXOGENESIS_DEFAULT_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_DEFAULT_SCHEMA, ExogenesisDefaultSchema))
#define EXOGENESIS_DEFAULT_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_DEFAULT_SCHEMA, ExogenesisDefaultSchemaClass))
#define EXOGENESIS_IS_DEFAULT_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_DEFAULT_SCHEMA))
#define EXOGENESIS_IS_DEFAULT_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_DEFAULT_SCHEMA))
#define EXOGENESIS_DEFAULT_SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_DEFAULT_SCHEMA, ExogenesisDefaultSchemaClass))

typedef struct _ExogenesisDefaultSchema ExogenesisDefaultSchema;
typedef struct _ExogenesisDefaultSchemaClass ExogenesisDefaultSchemaClass;
typedef struct _ExogenesisDefaultSchemaPrivate ExogenesisDefaultSchemaPrivate;

#define EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA (exogenesis_default_partition_data_get_type ())
#define EXOGENESIS_DEFAULT_PARTITION_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA, ExogenesisDefaultPartitionData))
#define EXOGENESIS_DEFAULT_PARTITION_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA, ExogenesisDefaultPartitionDataClass))
#define EXOGENESIS_IS_DEFAULT_PARTITION_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA))
#define EXOGENESIS_IS_DEFAULT_PARTITION_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA))
#define EXOGENESIS_DEFAULT_PARTITION_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA, ExogenesisDefaultPartitionDataClass))

typedef struct _ExogenesisDefaultPartitionData ExogenesisDefaultPartitionData;
typedef struct _ExogenesisDefaultPartitionDataClass ExogenesisDefaultPartitionDataClass;
typedef struct _ExogenesisDefaultPartitionDataPrivate ExogenesisDefaultPartitionDataPrivate;
typedef struct _ExogenesisParamSpecDefaultPartitionData ExogenesisParamSpecDefaultPartitionData;

struct _ExogenesisHDManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisHDManagerPrivate * priv;
	gboolean ThreadStop;
	gboolean PartitionerRunning;
	GeeArrayList* HardDisks;
};

struct _ExogenesisHDManagerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisHDManager *self);
};

struct _ExogenesisHDManagerPrivate {
	GduPool* _drivepool;
	ExogenesisMountPoints* _MountPoints;
	gboolean _MountComplete;
	GeeHashMap* FSTab;
	GeeArrayList* _fsTypes;
	gint _currentPIdx;
	gint _currentEIdx;
	ExogenesisInstallHardDisk* _currentIDH;
	gint _HardDiskCount;
};

struct _ExogenesisParamSpecHDManager {
	GParamSpec parent_instance;
};

struct _ExogenesisHardDisk {
	GObject parent_instance;
	ExogenesisHardDiskPrivate * priv;
	GeeArrayList* _partitions;
};

struct _ExogenesisHardDiskClass {
	GObjectClass parent_class;
};

struct _ExogenesisHardDiskPrivate {
	gchar* _Model;
	gchar* _Firmware;
	gchar* _Location;
	gboolean _WriteCacheEnabled;
	guint64 _Capacity;
	gchar* _CapacityDescription;
	gchar* _Partitioning;
	gchar* _SerialNumber;
	gchar* _Device;
	gchar* _Connection;
	gchar* _SmartStatus;
	gboolean _IsOptical;
	gchar* _PreviousOS;
};

struct _ExogenesisPartitionInfo {
	GObject parent_instance;
	ExogenesisPartitionInfoPrivate * priv;
};

struct _ExogenesisPartitionInfoClass {
	GObjectClass parent_class;
};

struct _ExogenesisPartitionInfoPrivate {
	gchar* _Usage;
	gchar* _PartitionType;
	gchar* _OSType;
	gchar* _OSTypeID;
	gchar* _Label;
	gchar* _Device;
	gchar* _PartitionLabel;
	gchar* _CapacityDescription;
	guint64 _Capacity;
	gchar* _AvailableDescription;
	guint64 _AvailableCapacity;
	gchar* _MountPoint;
	gchar* _PartitionFlags;
	gint _PartitionNumber;
	guint64 _StartSector;
	guint64 _EndSector;
	gchar* _UUID;
	gchar* _FSTabMountPoint;
	gboolean _IsMounted;
	gchar* _ParentDevice;
	GeeArrayList* _lstPartitions;
};

struct _ExogenesisFilesystemType {
	GObject parent_instance;
	ExogenesisFilesystemTypePrivate * priv;
};

struct _ExogenesisFilesystemTypeClass {
	GObjectClass parent_class;
};

struct _ExogenesisFilesystemTypePrivate {
	gchar* _ID;
	gchar* _Name;
	gboolean _CanCreate;
	gboolean _CanMount;
	gint _MaxLabelLen;
	gboolean _SupportUnixOwner;
	gboolean _AllowLabelRename;
	gboolean _SupportFsck;
	gboolean _SupportResizeEnlarge;
	gboolean _SupportResizeShrink;
	gboolean _SupportEnlargeOnline;
	gboolean _SupportShrinkOnline;
};

struct _ExogenesisMountPoints {
	GObject parent_instance;
	ExogenesisMountPointsPrivate * priv;
	GeeArrayList* _MountPoints;
};

struct _ExogenesisMountPointsClass {
	GObjectClass parent_class;
};

struct _ExogenesisMountPoint {
	GObject parent_instance;
	ExogenesisMountPointPrivate * priv;
};

struct _ExogenesisMountPointClass {
	GObjectClass parent_class;
};

struct _ExogenesisMountPointPrivate {
	gchar* _Key;
	gchar* _Path;
	gint _DisplayOrder;
};

struct _ExogenesisDefaultSchema {
	GObject parent_instance;
	ExogenesisDefaultSchemaPrivate * priv;
};

struct _ExogenesisDefaultSchemaClass {
	GObjectClass parent_class;
};

struct _ExogenesisDefaultSchemaPrivate {
	GeeArrayList* _dpd;
};

struct _ExogenesisDefaultPartitionData {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisDefaultPartitionDataPrivate * priv;
};

struct _ExogenesisDefaultPartitionDataClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisDefaultPartitionData *self);
};

struct _ExogenesisDefaultPartitionDataPrivate {
	gchar* _MountPoint;
	gchar* _Label;
	gint _Percentage;
};

struct _ExogenesisParamSpecDefaultPartitionData {
	GParamSpec parent_instance;
};


static gpointer exogenesis_hd_manager_parent_class = NULL;
static gpointer exogenesis_hard_disk_parent_class = NULL;
static GeeIterableIface* exogenesis_hard_disk_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_partition_info_parent_class = NULL;
static GeeComparableIface* exogenesis_partition_info_gee_comparable_parent_iface = NULL;
static GeeIterableIface* exogenesis_partition_info_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_filesystem_type_parent_class = NULL;
static gpointer exogenesis_mount_points_parent_class = NULL;
static GeeIterableIface* exogenesis_mount_points_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_mount_point_parent_class = NULL;
static GeeComparableIface* exogenesis_mount_point_gee_comparable_parent_iface = NULL;
static gpointer exogenesis_default_schema_parent_class = NULL;
static GeeIterableIface* exogenesis_default_schema_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_default_partition_data_parent_class = NULL;

gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
GType exogenesis_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_mount_points_get_type (void) G_GNUC_CONST;
GType exogenesis_filesystem_type_get_type (void) G_GNUC_CONST;
GType exogenesis_install_hard_disk_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_HD_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerPrivate))
enum  {
	EXOGENESIS_HD_MANAGER_DUMMY_PROPERTY
};
ExogenesisMountPoints* exogenesis_mount_points_new (void);
ExogenesisMountPoints* exogenesis_mount_points_construct (GType object_type);
ExogenesisHDManager* exogenesis_hd_manager_new (void);
ExogenesisHDManager* exogenesis_hd_manager_construct (GType object_type);
void exogenesis_hd_manager_PopulateFileSystemTypes (ExogenesisHDManager* self, gboolean includeExtended);
static void exogenesis_hd_manager_GduGetDevices (ExogenesisHDManager* self);
void exogenesis_mount_points_AddMountPointValues (ExogenesisMountPoints* self, const gchar* key, const gchar* mountpoint, gint order);
void exogenesis_hd_manager_OnDeviceConnected (ExogenesisHDManager* self, GduDevice* dev);
static void _exogenesis_hd_manager_OnDeviceConnected_gdu_pool_device_added (GduPool* _sender, GduDevice* device, gpointer self);
void exogenesis_hd_manager_OnDeviceRemoved (ExogenesisHDManager* self, GduDevice* dev);
static void _exogenesis_hd_manager_OnDeviceRemoved_gdu_pool_device_removed (GduPool* _sender, GduDevice* device, gpointer self);
void exogenesis_hd_manager_OnDeviceChanged (ExogenesisHDManager* self, GduDevice* dev);
static void _exogenesis_hd_manager_OnDeviceChanged_gdu_pool_device_changed (GduPool* _sender, GduDevice* device, gpointer self);
void exogenesis_hd_manager_RefreshDisks (ExogenesisHDManager* self);
ExogenesisHardDisk* exogenesis_hd_manager_GetHDBySerial (ExogenesisHDManager* self, const gchar* serialNumber);
const gchar* exogenesis_hard_disk_get_SerialNumber (ExogenesisHardDisk* self);
ExogenesisHardDisk* exogenesis_hd_manager_GetHDByDevice (ExogenesisHDManager* self, const gchar* deviceName);
const gchar* exogenesis_hard_disk_get_Device (ExogenesisHardDisk* self);
void exogenesis_hd_manager_MountTargetDisk (ExogenesisHDManager* self);
void exogenesis_hd_manager_UnMountTargetDisk (ExogenesisHDManager* self);
static gboolean exogenesis_hd_manager_HasStrv0 (ExogenesisHDManager* self, const gchar** strv, const gchar* str);
ExogenesisMountPoints* exogenesis_hd_manager_GetMountPoints (ExogenesisHDManager* self);
static GList* exogenesis_hd_manager_GetDrives (ExogenesisHDManager* self);
ExogenesisHardDisk* exogenesis_hard_disk_new (void);
ExogenesisHardDisk* exogenesis_hard_disk_construct (GType object_type);
void exogenesis_hard_disk_set_Device (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_Model (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_Firmware (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_Location (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_SerialNumber (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_CapacityDescription (ExogenesisHardDisk* self, const gchar* value);
void exogenesis_hard_disk_set_Capacity (ExogenesisHardDisk* self, guint64 value);
void exogenesis_hard_disk_set_IsOptical (ExogenesisHardDisk* self, gboolean value);
GType exogenesis_partition_info_get_type (void) G_GNUC_CONST;
static ExogenesisPartitionInfo* exogenesis_hd_manager_PopulatePartition (ExogenesisHDManager* self, GduVolume* vol);
void exogenesis_partition_info_AddPartition (ExogenesisPartitionInfo* self, ExogenesisPartitionInfo* pi);
void exogenesis_hard_disk_AddPartition (ExogenesisHardDisk* self, ExogenesisPartitionInfo* pi);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
void exogenesis_hard_disk_SortPartitions (ExogenesisHardDisk* self);
gint exogenesis_hd_manager_get_HardDiskCount (ExogenesisHDManager* self);
void exogenesis_hd_manager_set_HardDiskCount (ExogenesisHDManager* self, gint value);
void exogenesis_general_functions_LogIt (const gchar* Message);
ExogenesisPartitionInfo* exogenesis_partition_info_new (void);
ExogenesisPartitionInfo* exogenesis_partition_info_construct (GType object_type);
void exogenesis_partition_info_set_CapacityDescription (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_Capacity (ExogenesisPartitionInfo* self, guint64 value);
void exogenesis_partition_info_set_StartSector (ExogenesisPartitionInfo* self, guint64 value);
void exogenesis_partition_info_set_EndSector (ExogenesisPartitionInfo* self, guint64 value);
void exogenesis_partition_info_set_ParentDevice (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_Device (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_OSType (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_PartitionType (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_PartitionFlags (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_OSTypeID (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_Usage (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_Label (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_PartitionLabel (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_PartitionNumber (ExogenesisPartitionInfo* self, gint value);
void exogenesis_partition_info_set_UUID (ExogenesisPartitionInfo* self, const gchar* value);
void exogenesis_partition_info_set_FSTabMountPoint (ExogenesisPartitionInfo* self, const gchar* value);
ExogenesisFilesystemType* exogenesis_filesystem_type_new (void);
ExogenesisFilesystemType* exogenesis_filesystem_type_construct (GType object_type);
void exogenesis_filesystem_type_set_ID (ExogenesisFilesystemType* self, const gchar* value);
void exogenesis_filesystem_type_set_Name (ExogenesisFilesystemType* self, const gchar* value);
void exogenesis_filesystem_type_set_CanCreate (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_CanMount (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_MaxLabelLen (ExogenesisFilesystemType* self, gint value);
void exogenesis_filesystem_type_set_SupportUnixOwner (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_AllowLabelRename (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_SupportFsck (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_SupportResizeEnlarge (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_SupportResizeShrink (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_SupportEnlargeOnline (ExogenesisFilesystemType* self, gboolean value);
void exogenesis_filesystem_type_set_SupportShrinkOnline (ExogenesisFilesystemType* self, gboolean value);
static void exogenesis_hd_manager_AddMountPath (ExogenesisHDManager* self, const gchar* uuid, const gchar* MountPath);
const gchar* exogenesis_partition_info_get_UUID (ExogenesisPartitionInfo* self);
void exogenesis_partition_info_set_IsMounted (ExogenesisPartitionInfo* self, gboolean value);
void exogenesis_partition_info_set_MountPoint (ExogenesisPartitionInfo* self, const gchar* value);
static GduDrive* exogenesis_hd_manager_GetDriveFromDeviceName (ExogenesisHDManager* self, const gchar* DeviceName);
GType exogenesis_install_partition_get_type (void) G_GNUC_CONST;
gboolean exogenesis_hd_manager_CreatePartitionA (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, gint pindex, gint eindex, ExogenesisInstallHardDisk* ihd, gboolean primary);
const gchar* exogenesis_install_hard_disk_get_DeviceName (ExogenesisInstallHardDisk* self);
const gchar* exogenesis_install_hard_disk_get_SerialNumber (ExogenesisInstallHardDisk* self);
static gboolean exogenesis_hd_manager_UnMountRequired (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, ExogenesisHardDisk* hd, gchar** pidevice);
static void exogenesis_hd_manager_UnMountCallBackEvt (ExogenesisHDManager* self, GduDevice* d, GError* _error_);
static void _exogenesis_hd_manager_UnMountCallBackEvt_gdu_device_filesystem_unmount_completed_func (GduDevice* device, GError* _error_, gpointer self);
static gboolean exogenesis_hd_manager_DeleteRequired (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, ExogenesisHardDisk** hd, gchar** pidevice);
static void exogenesis_hd_manager_PartitionDeletedCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_);
static void _exogenesis_hd_manager_PartitionDeletedCallBack_gdu_device_partition_delete_completed_func (GduDevice* device, GError* _error_, gpointer self);
static gboolean exogenesis_hd_manager_Ownership (ExogenesisHDManager* self, const gchar* parttype);
const gchar* exogenesis_install_partition_get_Type (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_Format (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_NewPartition (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Device (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_TypeID (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Label (ExogenesisInstallPartition* self);
static void exogenesis_hd_manager_FileSystemCreateCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_);
static void _exogenesis_hd_manager_FileSystemCreateCallBack_gdu_device_filesystem_create_completed_func (GduDevice* device, GError* _error_, gpointer self);
guint64 exogenesis_install_partition_get_ByteSize (ExogenesisInstallPartition* self);
guint64 exogenesis_install_partition_get_Start (ExogenesisInstallPartition* self);
void exogenesis_hd_manager_CreatePartitionCallBack (ExogenesisHDManager* self, GduDevice* d, const gchar* objectPath, GError* _error_);
static void _exogenesis_hd_manager_CreatePartitionCallBack_gdu_device_partition_create_completed_func (GduDevice* device, const gchar* created_device_object_path, GError* _error_, gpointer self);
const gchar* exogenesis_partition_info_get_Device (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_PartitionType (ExogenesisPartitionInfo* self);
guint64 exogenesis_partition_info_get_EndSector (ExogenesisPartitionInfo* self);
guint64 exogenesis_partition_info_get_StartSector (ExogenesisPartitionInfo* self);
guint64 exogenesis_install_partition_get_End (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_Use (ExogenesisInstallPartition* self);
void exogenesis_hard_disk_RemovePartition (ExogenesisHardDisk* self, ExogenesisPartitionInfo* pi);
gboolean exogenesis_hd_manager_FormatPartition (ExogenesisHDManager* self, const gchar* DeviceName, const gchar* FSType);
static void exogenesis_hd_manager_UnMountCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_);
static void exogenesis_hd_manager_PartitionTableCreateCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_);
static void exogenesis_hd_manager_MountCallBack (ExogenesisHDManager* self, GduDevice* d, const gchar* mountpoint, GError* _error_);
GeeArrayList* exogenesis_hd_manager_get_FileSystemTypes (ExogenesisHDManager* self);
static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_INT_INT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void exogenesis_hd_manager_finalize (ExogenesisHDManager* obj);
#define EXOGENESIS_HARD_DISK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskPrivate))
enum  {
	EXOGENESIS_HARD_DISK_DUMMY_PROPERTY,
	EXOGENESIS_HARD_DISK_MODEL,
	EXOGENESIS_HARD_DISK_FIRMWARE,
	EXOGENESIS_HARD_DISK_LOCATION,
	EXOGENESIS_HARD_DISK_WRITE_CACHE_ENABLED,
	EXOGENESIS_HARD_DISK_CAPACITY,
	EXOGENESIS_HARD_DISK_CAPACITY_DESCRIPTION,
	EXOGENESIS_HARD_DISK_PARTITIONING,
	EXOGENESIS_HARD_DISK_SERIAL_NUMBER,
	EXOGENESIS_HARD_DISK_DEVICE,
	EXOGENESIS_HARD_DISK_CONNECTION,
	EXOGENESIS_HARD_DISK_SMART_STATUS,
	EXOGENESIS_HARD_DISK_PARTITION_COUNT,
	EXOGENESIS_HARD_DISK_IS_OPTICAL,
	EXOGENESIS_HARD_DISK_PREVIOUS_OS,
	EXOGENESIS_HARD_DISK_START_SECTOR,
	EXOGENESIS_HARD_DISK_HAS_HOME_PARTITION,
	EXOGENESIS_HARD_DISK_ELEMENT_TYPE
};
static gint exogenesis_hard_disk_GetPartitionCount (ExogenesisHardDisk* self);
static guint64 exogenesis_hard_disk_GetFirstStartSector (ExogenesisHardDisk* self);
guint64 exogenesis_hard_disk_FirstPartitionStartSector (ExogenesisHardDisk* self);
static GeeIterator* exogenesis_hard_disk_real_iterator (GeeIterable* base);
const gchar* exogenesis_hard_disk_get_Model (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_Firmware (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_Location (ExogenesisHardDisk* self);
gboolean exogenesis_hard_disk_get_WriteCacheEnabled (ExogenesisHardDisk* self);
void exogenesis_hard_disk_set_WriteCacheEnabled (ExogenesisHardDisk* self, gboolean value);
guint64 exogenesis_hard_disk_get_Capacity (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_CapacityDescription (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_Partitioning (ExogenesisHardDisk* self);
void exogenesis_hard_disk_set_Partitioning (ExogenesisHardDisk* self, const gchar* value);
const gchar* exogenesis_hard_disk_get_Connection (ExogenesisHardDisk* self);
void exogenesis_hard_disk_set_Connection (ExogenesisHardDisk* self, const gchar* value);
const gchar* exogenesis_hard_disk_get_SmartStatus (ExogenesisHardDisk* self);
void exogenesis_hard_disk_set_SmartStatus (ExogenesisHardDisk* self, const gchar* value);
gint exogenesis_hard_disk_get_PartitionCount (ExogenesisHardDisk* self);
gboolean exogenesis_hard_disk_get_IsOptical (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_PreviousOS (ExogenesisHardDisk* self);
void exogenesis_hard_disk_set_PreviousOS (ExogenesisHardDisk* self, const gchar* value);
guint64 exogenesis_hard_disk_get_StartSector (ExogenesisHardDisk* self);
gboolean exogenesis_hard_disk_get_HasHomePartition (ExogenesisHardDisk* self);
const gchar* exogenesis_partition_info_get_MountPoint (ExogenesisPartitionInfo* self);
static void exogenesis_hard_disk_finalize (GObject* obj);
static void _vala_exogenesis_hard_disk_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_hard_disk_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define EXOGENESIS_PARTITION_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoPrivate))
enum  {
	EXOGENESIS_PARTITION_INFO_DUMMY_PROPERTY,
	EXOGENESIS_PARTITION_INFO_USAGE,
	EXOGENESIS_PARTITION_INFO_PARTITION_TYPE,
	EXOGENESIS_PARTITION_INFO_OS_TYPE,
	EXOGENESIS_PARTITION_INFO_OS_TYPE_ID,
	EXOGENESIS_PARTITION_INFO_LABEL,
	EXOGENESIS_PARTITION_INFO_DEVICE,
	EXOGENESIS_PARTITION_INFO_PARTITION_LABEL,
	EXOGENESIS_PARTITION_INFO_CAPACITY_DESCRIPTION,
	EXOGENESIS_PARTITION_INFO_CAPACITY,
	EXOGENESIS_PARTITION_INFO_AVAILABLE_DESCRIPTION,
	EXOGENESIS_PARTITION_INFO_AVAILABLE_CAPACITY,
	EXOGENESIS_PARTITION_INFO_MOUNT_POINT,
	EXOGENESIS_PARTITION_INFO_PARTITION_FLAGS,
	EXOGENESIS_PARTITION_INFO_PARTITION_NUMBER,
	EXOGENESIS_PARTITION_INFO_START_SECTOR,
	EXOGENESIS_PARTITION_INFO_END_SECTOR,
	EXOGENESIS_PARTITION_INFO_UUID,
	EXOGENESIS_PARTITION_INFO_FS_TAB_MOUNT_POINT,
	EXOGENESIS_PARTITION_INFO_IS_MOUNTED,
	EXOGENESIS_PARTITION_INFO_PARENT_DEVICE,
	EXOGENESIS_PARTITION_INFO_ELEMENT_TYPE
};
static gint exogenesis_partition_info_real_compare_to (GeeComparable* base, ExogenesisPartitionInfo* comp);
void exogenesis_partition_info_RemovePartition (ExogenesisPartitionInfo* self, ExogenesisPartitionInfo* pi);
static GeeIterator* exogenesis_partition_info_real_iterator (GeeIterable* base);
void exogenesis_partition_info_SortPartitions (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_Usage (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_OSType (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_OSTypeID (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_Label (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_PartitionLabel (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_CapacityDescription (ExogenesisPartitionInfo* self);
guint64 exogenesis_partition_info_get_Capacity (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_AvailableDescription (ExogenesisPartitionInfo* self);
void exogenesis_partition_info_set_AvailableDescription (ExogenesisPartitionInfo* self, const gchar* value);
guint64 exogenesis_partition_info_get_AvailableCapacity (ExogenesisPartitionInfo* self);
void exogenesis_partition_info_set_AvailableCapacity (ExogenesisPartitionInfo* self, guint64 value);
const gchar* exogenesis_partition_info_get_PartitionFlags (ExogenesisPartitionInfo* self);
gint exogenesis_partition_info_get_PartitionNumber (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_FSTabMountPoint (ExogenesisPartitionInfo* self);
gboolean exogenesis_partition_info_get_IsMounted (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_ParentDevice (ExogenesisPartitionInfo* self);
static void exogenesis_partition_info_finalize (GObject* obj);
static void _vala_exogenesis_partition_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_partition_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define EXOGENESIS_FILESYSTEM_TYPE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypePrivate))
enum  {
	EXOGENESIS_FILESYSTEM_TYPE_DUMMY_PROPERTY,
	EXOGENESIS_FILESYSTEM_TYPE_ID,
	EXOGENESIS_FILESYSTEM_TYPE_NAME,
	EXOGENESIS_FILESYSTEM_TYPE_CAN_CREATE,
	EXOGENESIS_FILESYSTEM_TYPE_CAN_MOUNT,
	EXOGENESIS_FILESYSTEM_TYPE_MAX_LABEL_LEN,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_UNIX_OWNER,
	EXOGENESIS_FILESYSTEM_TYPE_ALLOW_LABEL_RENAME,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_FSCK,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_ENLARGE,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_SHRINK,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_ENLARGE_ONLINE,
	EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_SHRINK_ONLINE
};
gchar* exogenesis_filesystem_type_to_string (ExogenesisFilesystemType* self);
const gchar* exogenesis_filesystem_type_get_ID (ExogenesisFilesystemType* self);
const gchar* exogenesis_filesystem_type_get_Name (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_CanCreate (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_CanMount (ExogenesisFilesystemType* self);
gint exogenesis_filesystem_type_get_MaxLabelLen (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportUnixOwner (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_AllowLabelRename (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportFsck (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportResizeEnlarge (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportResizeShrink (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportEnlargeOnline (ExogenesisFilesystemType* self);
gboolean exogenesis_filesystem_type_get_SupportShrinkOnline (ExogenesisFilesystemType* self);
static void exogenesis_filesystem_type_finalize (GObject* obj);
static void _vala_exogenesis_filesystem_type_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_filesystem_type_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType exogenesis_mount_point_get_type (void) G_GNUC_CONST;
enum  {
	EXOGENESIS_MOUNT_POINTS_DUMMY_PROPERTY,
	EXOGENESIS_MOUNT_POINTS_ELEMENT_TYPE
};
ExogenesisMountPoint* exogenesis_mount_point_new (void);
ExogenesisMountPoint* exogenesis_mount_point_construct (GType object_type);
void exogenesis_mount_point_set_Key (ExogenesisMountPoint* self, const gchar* value);
void exogenesis_mount_point_set_Path (ExogenesisMountPoint* self, const gchar* value);
void exogenesis_mount_point_set_DisplayOrder (ExogenesisMountPoint* self, gint value);
void exogenesis_mount_points_AddMountPoint (ExogenesisMountPoints* self, ExogenesisMountPoint* mp);
void exogenesis_mount_points_Sort (ExogenesisMountPoints* self);
static GeeIterator* exogenesis_mount_points_real_iterator (GeeIterable* base);
static void exogenesis_mount_points_finalize (GObject* obj);
static void _vala_exogenesis_mount_points_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define EXOGENESIS_MOUNT_POINT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointPrivate))
enum  {
	EXOGENESIS_MOUNT_POINT_DUMMY_PROPERTY,
	EXOGENESIS_MOUNT_POINT_KEY,
	EXOGENESIS_MOUNT_POINT_PATH,
	EXOGENESIS_MOUNT_POINT_DISPLAY_ORDER
};
static gint exogenesis_mount_point_real_compare_to (GeeComparable* base, ExogenesisMountPoint* comp);
gint exogenesis_mount_point_get_DisplayOrder (ExogenesisMountPoint* self);
const gchar* exogenesis_mount_point_get_Key (ExogenesisMountPoint* self);
const gchar* exogenesis_mount_point_get_Path (ExogenesisMountPoint* self);
static void exogenesis_mount_point_finalize (GObject* obj);
static void _vala_exogenesis_mount_point_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_mount_point_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType exogenesis_default_schema_get_type (void) G_GNUC_CONST;
gpointer exogenesis_default_partition_data_ref (gpointer instance);
void exogenesis_default_partition_data_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_default_partition_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_default_partition_data (GValue* value, gpointer v_object);
void exogenesis_value_take_default_partition_data (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_default_partition_data (const GValue* value);
GType exogenesis_default_partition_data_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_DEFAULT_SCHEMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_DEFAULT_SCHEMA, ExogenesisDefaultSchemaPrivate))
enum  {
	EXOGENESIS_DEFAULT_SCHEMA_DUMMY_PROPERTY,
	EXOGENESIS_DEFAULT_SCHEMA_ELEMENT_TYPE
};
void exogenesis_default_schema_AddPartitionData (ExogenesisDefaultSchema* self, ExogenesisDefaultPartitionData* dpd);
static GeeIterator* exogenesis_default_schema_real_iterator (GeeIterable* base);
ExogenesisDefaultSchema* exogenesis_default_schema_new (void);
ExogenesisDefaultSchema* exogenesis_default_schema_construct (GType object_type);
static void exogenesis_default_schema_finalize (GObject* obj);
static void _vala_exogenesis_default_schema_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define EXOGENESIS_DEFAULT_PARTITION_DATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA, ExogenesisDefaultPartitionDataPrivate))
enum  {
	EXOGENESIS_DEFAULT_PARTITION_DATA_DUMMY_PROPERTY
};
ExogenesisDefaultPartitionData* exogenesis_default_partition_data_new (void);
ExogenesisDefaultPartitionData* exogenesis_default_partition_data_construct (GType object_type);
static const gchar* exogenesis_default_partition_data_get_MountPoint (ExogenesisDefaultPartitionData* self);
static void exogenesis_default_partition_data_set_MountPoint (ExogenesisDefaultPartitionData* self, const gchar* value);
static const gchar* exogenesis_default_partition_data_get_Label (ExogenesisDefaultPartitionData* self);
static void exogenesis_default_partition_data_set_Label (ExogenesisDefaultPartitionData* self, const gchar* value);
static gint exogenesis_default_partition_data_get_Percentage (ExogenesisDefaultPartitionData* self);
static void exogenesis_default_partition_data_set_Percentage (ExogenesisDefaultPartitionData* self, gint value);
static void exogenesis_default_partition_data_finalize (ExogenesisDefaultPartitionData* obj);


static void _exogenesis_hd_manager_OnDeviceConnected_gdu_pool_device_added (GduPool* _sender, GduDevice* device, gpointer self) {
	exogenesis_hd_manager_OnDeviceConnected (self, device);
}


static void _exogenesis_hd_manager_OnDeviceRemoved_gdu_pool_device_removed (GduPool* _sender, GduDevice* device, gpointer self) {
	exogenesis_hd_manager_OnDeviceRemoved (self, device);
}


static void _exogenesis_hd_manager_OnDeviceChanged_gdu_pool_device_changed (GduPool* _sender, GduDevice* device, gpointer self) {
	exogenesis_hd_manager_OnDeviceChanged (self, device);
}


ExogenesisHDManager* exogenesis_hd_manager_construct (GType object_type) {
	ExogenesisHDManager* self = NULL;
	GduPool* _tmp0_ = NULL;
	self = (ExogenesisHDManager*) g_type_create_instance (object_type);
	_tmp0_ = gdu_pool_new ();
	_g_object_unref0 (self->priv->_drivepool);
	self->priv->_drivepool = _tmp0_;
	exogenesis_hd_manager_PopulateFileSystemTypes (self, TRUE);
	exogenesis_hd_manager_GduGetDevices (self);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "root", "/", 0);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "home", "/home", 1);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "boot", "/boot", 2);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "opt", "/opt", 3);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "var", "/var", 4);
	exogenesis_mount_points_AddMountPointValues (self->priv->_MountPoints, "none", "", 5);
	g_signal_connect (self->priv->_drivepool, "device-added", (GCallback) _exogenesis_hd_manager_OnDeviceConnected_gdu_pool_device_added, self);
	g_signal_connect (self->priv->_drivepool, "device-removed", (GCallback) _exogenesis_hd_manager_OnDeviceRemoved_gdu_pool_device_removed, self);
	g_signal_connect (self->priv->_drivepool, "device-changed", (GCallback) _exogenesis_hd_manager_OnDeviceChanged_gdu_pool_device_changed, self);
	return self;
}


ExogenesisHDManager* exogenesis_hd_manager_new (void) {
	return exogenesis_hd_manager_construct (EXOGENESIS_TYPE_HD_MANAGER);
}


void exogenesis_hd_manager_RefreshDisks (ExogenesisHDManager* self) {
	g_return_if_fail (self != NULL);
	gee_abstract_collection_clear ((GeeAbstractCollection*) self->HardDisks);
	exogenesis_hd_manager_GduGetDevices (self);
	g_signal_emit_by_name (self, "devices-refreshed");
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


ExogenesisHardDisk* exogenesis_hd_manager_GetHDBySerial (ExogenesisHDManager* self, const gchar* serialNumber) {
	ExogenesisHardDisk* result = NULL;
	ExogenesisHardDisk* ret;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (serialNumber != NULL, NULL);
	ret = NULL;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _hd_list;
		gint _tmp1_;
		gint _hd_size;
		gint _hd_index;
		_tmp0_ = _g_object_ref0 (self->HardDisks);
		_hd_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _hd_list);
		_hd_size = _tmp1_;
		_hd_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* hd;
			const gchar* _tmp3_ = NULL;
			_hd_index = _hd_index + 1;
			if (!(_hd_index < _hd_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
			hd = (ExogenesisHardDisk*) _tmp2_;
			_tmp3_ = exogenesis_hard_disk_get_SerialNumber (hd);
			if (g_strcmp0 (_tmp3_, serialNumber) == 0) {
				ExogenesisHardDisk* _tmp4_;
				_tmp4_ = _g_object_ref0 (hd);
				_g_object_unref0 (ret);
				ret = _tmp4_;
				_g_object_unref0 (hd);
				break;
			}
			_g_object_unref0 (hd);
		}
		_g_object_unref0 (_hd_list);
	}
	result = ret;
	return result;
}


ExogenesisHardDisk* exogenesis_hd_manager_GetHDByDevice (ExogenesisHDManager* self, const gchar* deviceName) {
	ExogenesisHardDisk* result = NULL;
	ExogenesisHardDisk* ret;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (deviceName != NULL, NULL);
	ret = NULL;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _hd_list;
		gint _tmp1_;
		gint _hd_size;
		gint _hd_index;
		_tmp0_ = _g_object_ref0 (self->HardDisks);
		_hd_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _hd_list);
		_hd_size = _tmp1_;
		_hd_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* hd;
			const gchar* _tmp3_ = NULL;
			_hd_index = _hd_index + 1;
			if (!(_hd_index < _hd_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
			hd = (ExogenesisHardDisk*) _tmp2_;
			_tmp3_ = exogenesis_hard_disk_get_Device (hd);
			if (g_strcmp0 (_tmp3_, deviceName) == 0) {
				ExogenesisHardDisk* _tmp4_;
				_tmp4_ = _g_object_ref0 (hd);
				_g_object_unref0 (ret);
				ret = _tmp4_;
				_g_object_unref0 (hd);
				break;
			}
			_g_object_unref0 (hd);
		}
		_g_object_unref0 (_hd_list);
	}
	result = ret;
	return result;
}


void exogenesis_hd_manager_MountTargetDisk (ExogenesisHDManager* self) {
	g_return_if_fail (self != NULL);
}


void exogenesis_hd_manager_UnMountTargetDisk (ExogenesisHDManager* self) {
	g_return_if_fail (self != NULL);
}


static gboolean exogenesis_hd_manager_HasStrv0 (ExogenesisHDManager* self, const gchar** strv, const gchar* str) {
	gboolean result = FALSE;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	ret = FALSE;
	{
		gint n;
		n = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				gint _tmp2_;
				if (!_tmp0_) {
					n++;
				}
				_tmp0_ = FALSE;
				if (strv != NULL) {
					_tmp1_ = strv[n] != NULL;
				} else {
					_tmp1_ = FALSE;
				}
				if (!_tmp1_) {
					break;
				}
				_tmp2_ = g_strcmp0 (strv[n], str);
				if (_tmp2_ == 0) {
					ret = TRUE;
					break;
				}
			}
		}
	}
	result = ret;
	return result;
}


ExogenesisMountPoints* exogenesis_hd_manager_GetMountPoints (ExogenesisHDManager* self) {
	ExogenesisMountPoints* result = NULL;
	ExogenesisMountPoints* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = _g_object_ref0 (self->priv->_MountPoints);
	result = _tmp0_;
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static void exogenesis_hd_manager_GduGetDevices (ExogenesisHDManager* self) {
	GList* _tmp0_ = NULL;
	GList* drvs;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = exogenesis_hd_manager_GetDrives (self);
	drvs = _tmp0_;
	{
		GList* drv_collection;
		GList* drv_it;
		drv_collection = drvs;
		for (drv_it = drv_collection; drv_it != NULL; drv_it = drv_it->next) {
			GduDrive* _tmp1_;
			GduDrive* drv;
			_tmp1_ = _g_object_ref0 ((GduDrive*) drv_it->data);
			drv = _tmp1_;
			{
				GduDevice* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				gboolean _tmp4_;
				_tmp2_ = gdu_presentable_get_device ((GduPresentable*) drv);
				_tmp3_ = gdu_device_drive_get_media_compatibility (_tmp2_);
				_tmp4_ = exogenesis_hd_manager_HasStrv0 (self, _tmp3_, "optical_cd");
				if (!_tmp4_) {
					ExogenesisHardDisk* _tmp5_ = NULL;
					ExogenesisHardDisk* hd;
					GduDevice* _tmp6_ = NULL;
					const gchar* _tmp7_ = NULL;
					GduDevice* _tmp8_ = NULL;
					const gchar* _tmp9_ = NULL;
					GduDevice* _tmp10_ = NULL;
					const gchar* _tmp11_ = NULL;
					GduDevice* _tmp12_ = NULL;
					const gchar* _tmp13_ = NULL;
					guint64 _tmp14_;
					const gchar* _tmp15_ = NULL;
					guint64 _tmp16_;
					GList* _tmp17_ = NULL;
					GList* _tmp18_ = NULL;
					GList* vols;
					_tmp5_ = exogenesis_hard_disk_new ();
					hd = _tmp5_;
					_tmp6_ = gdu_presentable_get_device ((GduPresentable*) drv);
					_tmp7_ = gdu_device_get_device_file (_tmp6_);
					exogenesis_hard_disk_set_Device (hd, _tmp7_);
					_tmp8_ = gdu_presentable_get_device ((GduPresentable*) drv);
					_tmp9_ = gdu_device_drive_get_model (_tmp8_);
					exogenesis_hard_disk_set_Model (hd, _tmp9_);
					_tmp10_ = gdu_presentable_get_device ((GduPresentable*) drv);
					_tmp11_ = gdu_device_drive_get_revision (_tmp10_);
					exogenesis_hard_disk_set_Firmware (hd, _tmp11_);
					exogenesis_hard_disk_set_Location (hd, "");
					_tmp12_ = gdu_presentable_get_device ((GduPresentable*) drv);
					_tmp13_ = gdu_device_drive_get_serial (_tmp12_);
					exogenesis_hard_disk_set_SerialNumber (hd, _tmp13_);
					_tmp14_ = gdu_presentable_get_size ((GduPresentable*) drv);
					_tmp15_ = gdu_util_get_size_for_display (_tmp14_, FALSE, FALSE);
					exogenesis_hard_disk_set_CapacityDescription (hd, _tmp15_);
					_tmp16_ = gdu_presentable_get_size ((GduPresentable*) drv);
					exogenesis_hard_disk_set_Capacity (hd, _tmp16_);
					exogenesis_hard_disk_set_IsOptical (hd, FALSE);
					_tmp17_ = gdu_presentable_get_enclosed ((GduPresentable*) drv);
					_tmp18_ = g_list_copy (_tmp17_);
					vols = (GList*) _tmp18_;
					{
						GList* vol_collection;
						GList* vol_it;
						vol_collection = vols;
						for (vol_it = vol_collection; vol_it != NULL; vol_it = vol_it->next) {
							GduVolume* _tmp19_;
							GduVolume* vol;
							_tmp19_ = _g_object_ref0 ((GduVolume*) vol_it->data);
							vol = _tmp19_;
							{
								GduPresentable* _tmp20_ = NULL;
								const gchar* _tmp21_ = NULL;
								const gchar* _tmp22_ = NULL;
								_tmp20_ = gdu_presentable_get_enclosing_presentable ((GduPresentable*) vol);
								_tmp21_ = gdu_presentable_get_name (_tmp20_);
								_tmp22_ = gdu_presentable_get_name ((GduPresentable*) drv);
								if (g_strcmp0 (_tmp21_, _tmp22_) == 0) {
									ExogenesisPartitionInfo* _tmp23_ = NULL;
									ExogenesisPartitionInfo* pi;
									GList* _tmp24_ = NULL;
									GList* _tmp25_ = NULL;
									GList* parts;
									_tmp23_ = exogenesis_hd_manager_PopulatePartition (self, vol);
									pi = _tmp23_;
									_tmp24_ = gdu_presentable_get_enclosed ((GduPresentable*) vol);
									_tmp25_ = g_list_copy ((GList*) _tmp24_);
									parts = _tmp25_;
									{
										GList* v_collection;
										GList* v_it;
										v_collection = parts;
										for (v_it = v_collection; v_it != NULL; v_it = v_it->next) {
											GduVolume* _tmp26_;
											GduVolume* v;
											_tmp26_ = _g_object_ref0 ((GduVolume*) v_it->data);
											v = _tmp26_;
											{
												ExogenesisPartitionInfo* _tmp27_ = NULL;
												ExogenesisPartitionInfo* _tmp28_;
												_tmp27_ = exogenesis_hd_manager_PopulatePartition (self, v);
												_tmp28_ = _tmp27_;
												exogenesis_partition_info_AddPartition (pi, _tmp28_);
												_g_object_unref0 (_tmp28_);
												_g_object_unref0 (v);
											}
										}
									}
									exogenesis_hard_disk_AddPartition (hd, pi);
									__g_list_free__g_object_unref0_0 (parts);
									_g_object_unref0 (pi);
								}
								_g_object_unref0 (vol);
							}
						}
					}
					exogenesis_hard_disk_SortPartitions (hd);
					gee_abstract_collection_add ((GeeAbstractCollection*) self->HardDisks, hd);
					exogenesis_hd_manager_set_HardDiskCount (self, self->priv->_HardDiskCount + 1);
					__g_list_free__g_object_unref0_0 (vols);
					_g_object_unref0 (hd);
				}
				_g_object_unref0 (drv);
			}
		}
	}
	__g_list_free__g_object_unref0_0 (drvs);
	goto __finally15;
	__catch15_g_error:
	{
		GError * _error_;
		gchar* _tmp29_ = NULL;
		gchar* _tmp30_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp29_ = g_strdup_printf ("ERROR ENUMERATING DEVICES - %s\n", _error_->message);
		_tmp30_ = _tmp29_;
		exogenesis_general_functions_LogIt (_tmp30_);
		_g_free0 (_tmp30_);
		_g_error_free0 (_error_);
	}
	__finally15:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static ExogenesisPartitionInfo* exogenesis_hd_manager_PopulatePartition (ExogenesisHDManager* self, GduVolume* vol) {
	ExogenesisPartitionInfo* result = NULL;
	ExogenesisPartitionInfo* _tmp0_ = NULL;
	ExogenesisPartitionInfo* pi;
	guint64 _tmp1_;
	const gchar* _tmp2_ = NULL;
	guint64 _tmp3_;
	guint64 _tmp4_;
	guint64 _tmp5_;
	guint64 _tmp6_;
	const gchar* _tmp7_ = NULL;
	GduPresentable* _tmp8_ = NULL;
	GduDevice* _tmp9_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	gboolean _tmp16_;
	gboolean _tmp17_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (vol != NULL, NULL);
	_tmp0_ = exogenesis_partition_info_new ();
	pi = _tmp0_;
	_tmp1_ = gdu_presentable_get_size ((GduPresentable*) vol);
	_tmp2_ = gdu_util_get_size_for_display (_tmp1_, FALSE, FALSE);
	exogenesis_partition_info_set_CapacityDescription (pi, _tmp2_);
	_tmp3_ = gdu_presentable_get_size ((GduPresentable*) vol);
	exogenesis_partition_info_set_Capacity (pi, _tmp3_);
	_tmp4_ = gdu_presentable_get_offset ((GduPresentable*) vol);
	exogenesis_partition_info_set_StartSector (pi, _tmp4_);
	_tmp5_ = gdu_presentable_get_offset ((GduPresentable*) vol);
	_tmp6_ = gdu_presentable_get_size ((GduPresentable*) vol);
	exogenesis_partition_info_set_EndSector (pi, _tmp5_ + _tmp6_);
	_tmp8_ = gdu_presentable_get_enclosing_presentable ((GduPresentable*) vol);
	_tmp9_ = gdu_presentable_get_device (_tmp8_);
	if (_tmp9_ != NULL) {
		GduPresentable* _tmp10_ = NULL;
		GduDevice* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		_tmp10_ = gdu_presentable_get_enclosing_presentable ((GduPresentable*) vol);
		_tmp11_ = gdu_presentable_get_device (_tmp10_);
		_tmp12_ = gdu_device_get_device_file (_tmp11_);
		_tmp7_ = _tmp12_;
	} else {
		_tmp7_ = "";
	}
	exogenesis_partition_info_set_ParentDevice (pi, _tmp7_);
	_tmp13_ = gdu_presentable_get_description ((GduPresentable*) vol);
	_tmp14_ = g_utf8_strdown (_tmp13_, (gssize) (-1));
	_tmp15_ = _tmp14_;
	_tmp16_ = string_contains (_tmp15_, "unknown");
	_tmp17_ = _tmp16_;
	_g_free0 (_tmp15_);
	if (_tmp17_) {
		GduDevice* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		_tmp18_ = gdu_presentable_get_device ((GduPresentable*) vol);
		_tmp19_ = gdu_device_get_device_file (_tmp18_);
		exogenesis_partition_info_set_Device (pi, _tmp19_);
		exogenesis_partition_info_set_OSType (pi, "Unknown");
		exogenesis_partition_info_set_PartitionType (pi, "Unknown");
	} else {
		GType _tmp20_;
		_tmp20_ = G_TYPE_FROM_INSTANCE ((GObject*) vol);
		if (_tmp20_ != GDU_TYPE_VOLUME_HOLE) {
			GduDevice* _tmp21_ = NULL;
			GduDevice* _tmp22_;
			GduDevice* dev;
			const gchar* _tmp23_ = NULL;
			GduDevice* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			GduDevice* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			const gchar* _tmp28_ = NULL;
			GduDevice* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			const gchar* _tmp32_ = NULL;
			const gchar* _tmp33_ = NULL;
			const gchar* _tmp34_ = NULL;
			const gchar* _tmp35_ = NULL;
			GduDevice* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			GduDevice* _tmp38_ = NULL;
			const gchar* _tmp39_ = NULL;
			GduDevice* _tmp40_ = NULL;
			gint _tmp41_;
			GduDevice* _tmp42_ = NULL;
			const gchar* _tmp43_ = NULL;
			_tmp21_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp22_ = _g_object_ref0 (_tmp21_);
			dev = _tmp22_;
			_tmp23_ = gdu_device_get_device_file (dev);
			exogenesis_partition_info_set_Device (pi, _tmp23_);
			_tmp24_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp25_ = gdu_device_partition_get_scheme (_tmp24_);
			_tmp26_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp27_ = gdu_device_partition_get_type (_tmp26_);
			_tmp28_ = gdu_util_get_desc_for_part_type (_tmp25_, _tmp27_);
			exogenesis_partition_info_set_PartitionType (pi, _tmp28_);
			_tmp29_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp30_ = gdu_device_partition_get_flags (_tmp29_);
			exogenesis_partition_info_set_PartitionFlags (pi, _tmp30_);
			_tmp31_ = gdu_device_id_get_type (dev);
			_tmp32_ = gdu_device_id_get_version (dev);
			_tmp33_ = gdu_util_get_fstype_for_display (_tmp31_, _tmp32_, TRUE);
			exogenesis_partition_info_set_OSType (pi, _tmp33_);
			_tmp34_ = gdu_device_id_get_type (dev);
			_tmp35_ = string_to_string (_tmp34_);
			exogenesis_partition_info_set_OSTypeID (pi, _tmp35_);
			_tmp36_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp37_ = gdu_device_id_get_usage (_tmp36_);
			exogenesis_partition_info_set_Usage (pi, _tmp37_);
			_tmp38_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp39_ = gdu_device_id_get_label (_tmp38_);
			exogenesis_partition_info_set_Label (pi, _tmp39_);
			exogenesis_partition_info_set_PartitionLabel (pi, "");
			_tmp40_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp41_ = gdu_device_partition_get_number (_tmp40_);
			exogenesis_partition_info_set_PartitionNumber (pi, _tmp41_);
			_tmp42_ = gdu_presentable_get_device ((GduPresentable*) vol);
			_tmp43_ = gdu_device_id_get_uuid (_tmp42_);
			exogenesis_partition_info_set_UUID (pi, _tmp43_);
			exogenesis_partition_info_set_FSTabMountPoint (pi, "");
			_g_object_unref0 (dev);
		} else {
			GduDrive* _tmp44_ = NULL;
			const gchar* _tmp45_ = NULL;
			_tmp44_ = gdu_volume_get_drive (vol);
			_tmp45_ = gdu_presentable_get_name ((GduPresentable*) _tmp44_);
			exogenesis_partition_info_set_Device (pi, _tmp45_);
			exogenesis_partition_info_set_OSType (pi, "Unallocated");
			exogenesis_partition_info_set_PartitionType (pi, "UNALLOCATED");
		}
	}
	result = pi;
	return result;
}


static GList* exogenesis_hd_manager_GetDrives (ExogenesisHDManager* self) {
	GList* result = NULL;
	GList* _tmp0_ = NULL;
	GList* devs;
	GList* drvs;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gdu_pool_get_devices (self->priv->_drivepool);
	devs = _tmp0_;
	drvs = NULL;
	{
		GList* d_collection;
		GList* d_it;
		d_collection = devs;
		for (d_it = d_collection; d_it != NULL; d_it = d_it->next) {
			GduDevice* _tmp1_;
			GduDevice* d;
			_tmp1_ = _g_object_ref0 ((GduDevice*) d_it->data);
			d = _tmp1_;
			{
				gboolean _tmp2_ = FALSE;
				gboolean _tmp3_;
				_tmp3_ = gdu_device_is_drive (d);
				if (_tmp3_) {
					gboolean _tmp4_;
					_tmp4_ = gdu_device_is_optical_disc (d);
					_tmp2_ = !_tmp4_;
				} else {
					_tmp2_ = FALSE;
				}
				if (_tmp2_) {
					const gchar* _tmp5_ = NULL;
					gchar* _tmp6_ = NULL;
					gchar* _tmp7_;
					GduPresentable* _tmp8_ = NULL;
					GduDrive* _tmp9_;
					_tmp5_ = gdu_device_get_device_file (d);
					_tmp6_ = g_strdup_printf ("DEVICE FOUND %s\n", _tmp5_);
					_tmp7_ = _tmp6_;
					exogenesis_general_functions_LogIt (_tmp7_);
					_g_free0 (_tmp7_);
					_tmp8_ = gdu_pool_get_drive_by_device (self->priv->_drivepool, d);
					_tmp9_ = _g_object_ref0 (GDU_DRIVE (_tmp8_));
					drvs = g_list_append (drvs, _tmp9_);
				}
				_g_object_unref0 (d);
			}
		}
	}
	result = drvs;
	return result;
}


void exogenesis_hd_manager_PopulateFileSystemTypes (ExogenesisHDManager* self, gboolean includeExtended) {
	GduPool* _tmp0_ = NULL;
	GduPool* pool;
	GList* _tmp1_ = NULL;
	ExogenesisFilesystemType* _tmp16_ = NULL;
	ExogenesisFilesystemType* fs;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gdu_pool_new ();
	pool = _tmp0_;
	_tmp1_ = gdu_pool_get_known_filesystems (pool);
	{
		GList* kfs_collection;
		GList* kfs_it;
		kfs_collection = (GList*) _tmp1_;
		for (kfs_it = kfs_collection; kfs_it != NULL; kfs_it = kfs_it->next) {
			GduKnownFilesystem* _tmp2_;
			GduKnownFilesystem* kfs;
			_tmp2_ = _g_object_ref0 ((GduKnownFilesystem*) kfs_it->data);
			kfs = _tmp2_;
			{
				ExogenesisFilesystemType* _tmp3_ = NULL;
				ExogenesisFilesystemType* fs;
				const gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				gboolean _tmp6_;
				gboolean _tmp7_;
				guint _tmp8_;
				gboolean _tmp9_;
				gboolean _tmp10_;
				gboolean _tmp11_;
				gboolean _tmp12_;
				gboolean _tmp13_;
				gboolean _tmp14_;
				gboolean _tmp15_;
				_tmp3_ = exogenesis_filesystem_type_new ();
				fs = _tmp3_;
				_tmp4_ = gdu_known_filesystem_get_id (kfs);
				exogenesis_filesystem_type_set_ID (fs, _tmp4_);
				_tmp5_ = gdu_known_filesystem_get_name (kfs);
				exogenesis_filesystem_type_set_Name (fs, _tmp5_);
				_tmp6_ = gdu_known_filesystem_get_can_create (kfs);
				exogenesis_filesystem_type_set_CanCreate (fs, _tmp6_);
				_tmp7_ = gdu_known_filesystem_get_can_mount (kfs);
				exogenesis_filesystem_type_set_CanMount (fs, _tmp7_);
				_tmp8_ = gdu_known_filesystem_get_max_label_len (kfs);
				exogenesis_filesystem_type_set_MaxLabelLen (fs, (gint) _tmp8_);
				_tmp9_ = gdu_known_filesystem_get_supports_unix_owners (kfs);
				exogenesis_filesystem_type_set_SupportUnixOwner (fs, _tmp9_);
				_tmp10_ = gdu_known_filesystem_get_supports_label_rename (kfs);
				exogenesis_filesystem_type_set_AllowLabelRename (fs, _tmp10_);
				_tmp11_ = gdu_known_filesystem_get_supports_fsck (kfs);
				exogenesis_filesystem_type_set_SupportFsck (fs, _tmp11_);
				_tmp12_ = gdu_known_filesystem_get_supports_resize_enlarge (kfs);
				exogenesis_filesystem_type_set_SupportResizeEnlarge (fs, _tmp12_);
				_tmp13_ = gdu_known_filesystem_get_supports_resize_shrink (kfs);
				exogenesis_filesystem_type_set_SupportResizeShrink (fs, _tmp13_);
				_tmp14_ = gdu_known_filesystem_get_supports_online_resize_enlarge (kfs);
				exogenesis_filesystem_type_set_SupportEnlargeOnline (fs, _tmp14_);
				_tmp15_ = gdu_known_filesystem_get_supports_online_resize_shrink (kfs);
				exogenesis_filesystem_type_set_SupportShrinkOnline (fs, _tmp15_);
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_fsTypes, fs);
				_g_object_unref0 (fs);
				_g_object_unref0 (kfs);
			}
		}
	}
	_tmp16_ = exogenesis_filesystem_type_new ();
	fs = _tmp16_;
	exogenesis_filesystem_type_set_ID (fs, "0x05");
	exogenesis_filesystem_type_set_Name (fs, "Extended Partition");
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_fsTypes, fs);
	_g_object_unref0 (fs);
	_g_object_unref0 (pool);
	goto __finally16;
	__catch16_g_error:
	{
		GError * _error_;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp17_ = g_strdup_printf ("ERROR: Can't retrieve known filesystems : %s\n", _error_->message);
		_tmp18_ = _tmp17_;
		exogenesis_general_functions_LogIt (_tmp18_);
		_g_free0 (_tmp18_);
		_g_error_free0 (_error_);
	}
	__finally16:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void exogenesis_hd_manager_AddMountPath (ExogenesisHDManager* self, const gchar* uuid, const gchar* MountPath) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (uuid != NULL);
	g_return_if_fail (MountPath != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _hd_list;
		gint _tmp1_;
		gint _hd_size;
		gint _hd_index;
		_tmp0_ = _g_object_ref0 (self->HardDisks);
		_hd_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _hd_list);
		_hd_size = _tmp1_;
		_hd_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* hd;
			_hd_index = _hd_index + 1;
			if (!(_hd_index < _hd_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
			hd = (ExogenesisHardDisk*) _tmp2_;
			{
				GeeIterator* _tmp3_ = NULL;
				GeeIterator* _pi_it;
				_tmp3_ = gee_iterable_iterator ((GeeIterable*) hd);
				_pi_it = _tmp3_;
				while (TRUE) {
					gboolean _tmp4_;
					gpointer _tmp5_ = NULL;
					ExogenesisPartitionInfo* pi;
					const gchar* _tmp6_ = NULL;
					_tmp4_ = gee_iterator_next (_pi_it);
					if (!_tmp4_) {
						break;
					}
					_tmp5_ = gee_iterator_get (_pi_it);
					pi = (ExogenesisPartitionInfo*) _tmp5_;
					_tmp6_ = exogenesis_partition_info_get_UUID (pi);
					if (g_strcmp0 (_tmp6_, uuid) == 0) {
						exogenesis_partition_info_set_IsMounted (pi, TRUE);
						exogenesis_partition_info_set_MountPoint (pi, MountPath);
					}
					_g_object_unref0 (pi);
				}
				_g_object_unref0 (_pi_it);
			}
			_g_object_unref0 (hd);
		}
		_g_object_unref0 (_hd_list);
	}
}


static GduDrive* exogenesis_hd_manager_GetDriveFromDeviceName (ExogenesisHDManager* self, const gchar* DeviceName) {
	GduDrive* result = NULL;
	GduDevice* _tmp0_ = NULL;
	GduDevice* _tmp1_;
	GduDevice* dev;
	GduPresentable* _tmp2_ = NULL;
	GduDrive* _tmp3_;
	GduDrive* drv;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (DeviceName != NULL, NULL);
	_tmp0_ = gdu_pool_get_by_device_file (self->priv->_drivepool, DeviceName);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	dev = _tmp1_;
	_tmp2_ = gdu_pool_get_drive_by_device (self->priv->_drivepool, dev);
	_tmp3_ = _g_object_ref0 (GDU_DRIVE (_tmp2_));
	drv = _tmp3_;
	result = drv;
	_g_object_unref0 (dev);
	return result;
}


static void _exogenesis_hd_manager_UnMountCallBackEvt_gdu_device_filesystem_unmount_completed_func (GduDevice* device, GError* _error_, gpointer self) {
	exogenesis_hd_manager_UnMountCallBackEvt (self, device, _error_);
}


static void _exogenesis_hd_manager_PartitionDeletedCallBack_gdu_device_partition_delete_completed_func (GduDevice* device, GError* _error_, gpointer self) {
	exogenesis_hd_manager_PartitionDeletedCallBack (self, device, _error_);
}


static void _exogenesis_hd_manager_FileSystemCreateCallBack_gdu_device_filesystem_create_completed_func (GduDevice* device, GError* _error_, gpointer self) {
	exogenesis_hd_manager_FileSystemCreateCallBack (self, device, _error_);
}


static void _exogenesis_hd_manager_CreatePartitionCallBack_gdu_device_partition_create_completed_func (GduDevice* device, const gchar* created_device_object_path, GError* _error_, gpointer self) {
	exogenesis_hd_manager_CreatePartitionCallBack (self, device, created_device_object_path, _error_);
}


gboolean exogenesis_hd_manager_CreatePartitionA (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, gint pindex, gint eindex, ExogenesisInstallHardDisk* ihd, gboolean primary) {
	gboolean result = FALSE;
	gchar* flags = NULL;
	gchar* parttype = NULL;
	GduDevice* dev = NULL;
	gchar* dpidevice = NULL;
	gchar* upidevice = NULL;
	ExogenesisInstallHardDisk* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	const gchar* _tmp4_ = NULL;
	ExogenesisHardDisk* _tmp5_ = NULL;
	ExogenesisHardDisk* hd;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ip != NULL, FALSE);
	g_return_val_if_fail (ihd != NULL, FALSE);
	self->priv->_currentPIdx = pindex;
	self->priv->_currentEIdx = eindex;
	_tmp0_ = _g_object_ref0 (ihd);
	_g_object_unref0 (self->priv->_currentIDH);
	self->priv->_currentIDH = _tmp0_;
	_tmp1_ = exogenesis_install_hard_disk_get_DeviceName (ihd);
	_tmp2_ = g_strdup_printf ("\n\nCreate Partition Process Start on %s\n", _tmp1_);
	_tmp3_ = _tmp2_;
	exogenesis_general_functions_LogIt (_tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = exogenesis_install_hard_disk_get_SerialNumber (ihd);
	_tmp5_ = exogenesis_hd_manager_GetHDBySerial (self, _tmp4_);
	hd = _tmp5_;
	if (hd != NULL) {
		gboolean _tmp6_ = FALSE;
		gchar* _tmp7_ = NULL;
		gboolean _tmp8_;
		_tmp8_ = exogenesis_hd_manager_UnMountRequired (self, ip, hd, &_tmp7_);
		_g_free0 (upidevice);
		upidevice = _tmp7_;
		if (_tmp8_) {
			_tmp6_ = primary;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			GduDevice* _tmp9_ = NULL;
			GduDevice* _tmp10_;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp9_ = gdu_pool_get_by_device_file (self->priv->_drivepool, upidevice);
			_tmp10_ = _g_object_ref0 (_tmp9_);
			_g_object_unref0 (dev);
			dev = _tmp10_;
			_tmp11_ = g_strdup_printf ("UNMOUNTING DEVICE %s\n", upidevice);
			_tmp12_ = _tmp11_;
			exogenesis_general_functions_LogIt (_tmp12_);
			_g_free0 (_tmp12_);
			gdu_device_op_filesystem_unmount (dev, _exogenesis_hd_manager_UnMountCallBackEvt_gdu_device_filesystem_unmount_completed_func, self);
			_tmp13_ = g_strdup ("");
			_g_free0 (upidevice);
			upidevice = _tmp13_;
			_g_object_unref0 (dev);
			dev = NULL;
			_g_object_unref0 (hd);
			hd = NULL;
			result = FALSE;
			_g_object_unref0 (hd);
			_g_free0 (upidevice);
			_g_free0 (dpidevice);
			_g_object_unref0 (dev);
			_g_free0 (parttype);
			_g_free0 (flags);
			return result;
		} else {
			gboolean _tmp14_ = FALSE;
			gchar* _tmp15_ = NULL;
			gboolean _tmp16_;
			_tmp16_ = exogenesis_hd_manager_DeleteRequired (self, ip, &hd, &_tmp15_);
			_g_free0 (dpidevice);
			dpidevice = _tmp15_;
			if (_tmp16_) {
				_tmp14_ = primary;
			} else {
				_tmp14_ = FALSE;
			}
			if (_tmp14_) {
				GduDevice* _tmp17_ = NULL;
				GduDevice* _tmp18_;
				gchar* _tmp19_ = NULL;
				gchar* _tmp20_;
				_tmp17_ = gdu_pool_get_by_device_file (self->priv->_drivepool, dpidevice);
				_tmp18_ = _g_object_ref0 (_tmp17_);
				_g_object_unref0 (dev);
				dev = _tmp18_;
				_tmp19_ = g_strdup_printf ("DELETING DEVICE %s\n", dpidevice);
				_tmp20_ = _tmp19_;
				exogenesis_general_functions_LogIt (_tmp20_);
				_g_free0 (_tmp20_);
				gdu_device_op_partition_delete (dev, _exogenesis_hd_manager_PartitionDeletedCallBack_gdu_device_partition_delete_completed_func, self);
				_g_object_unref0 (dev);
				dev = NULL;
			} else {
				const gchar* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				gboolean _tmp23_;
				gboolean ownit;
				gboolean _tmp24_ = FALSE;
				gboolean _tmp25_;
				_tmp21_ = exogenesis_install_partition_get_Type (ip);
				_tmp22_ = string_to_string (_tmp21_);
				_tmp23_ = exogenesis_hd_manager_Ownership (self, _tmp22_);
				ownit = _tmp23_;
				_tmp25_ = exogenesis_install_partition_get_Format (ip);
				if (_tmp25_) {
					gboolean _tmp26_;
					_tmp26_ = exogenesis_install_partition_get_NewPartition (ip);
					_tmp24_ = !_tmp26_;
				} else {
					_tmp24_ = FALSE;
				}
				if (_tmp24_) {
					const gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					gchar* _tmp29_;
					const gchar* _tmp30_ = NULL;
					GduDevice* _tmp31_ = NULL;
					GduDevice* _tmp32_;
					const gchar* _tmp33_ = NULL;
					const gchar* _tmp34_ = NULL;
					gchar* _tmp35_ = NULL;
					gchar* _tmp36_;
					const gchar* _tmp37_ = NULL;
					const gchar* _tmp38_ = NULL;
					_tmp27_ = exogenesis_install_partition_get_Device (ip);
					_tmp28_ = g_strdup_printf ("USING EXISTING PARTITION DATA, FORMATTING %s\n", _tmp27_);
					_tmp29_ = _tmp28_;
					exogenesis_general_functions_LogIt (_tmp29_);
					_g_free0 (_tmp29_);
					_tmp30_ = exogenesis_install_partition_get_Device (ip);
					_tmp31_ = gdu_pool_get_by_device_file (self->priv->_drivepool, _tmp30_);
					_tmp32_ = _g_object_ref0 (_tmp31_);
					_g_object_unref0 (dev);
					dev = _tmp32_;
					_tmp33_ = gdu_device_get_device_file (dev);
					_tmp34_ = exogenesis_install_partition_get_TypeID (ip);
					_tmp35_ = g_strdup_printf ("FORMATTING PARTITION ON DEVICE %s TO %s\n", _tmp33_, _tmp34_);
					_tmp36_ = _tmp35_;
					exogenesis_general_functions_LogIt (_tmp36_);
					_g_free0 (_tmp36_);
					_tmp37_ = exogenesis_install_partition_get_TypeID (ip);
					_tmp38_ = exogenesis_install_partition_get_Label (ip);
					gdu_device_op_filesystem_create (dev, _tmp37_, _tmp38_, "", ownit, _exogenesis_hd_manager_FileSystemCreateCallBack_gdu_device_filesystem_create_completed_func, self);
					_g_object_unref0 (dev);
					dev = NULL;
				} else {
					gboolean _tmp39_;
					_tmp39_ = exogenesis_install_partition_get_NewPartition (ip);
					if (_tmp39_) {
						const gchar* _tmp40_ = NULL;
						GduDevice* _tmp41_ = NULL;
						GduDevice* _tmp42_;
						const gchar* _tmp43_ = NULL;
						guint64 _tmp44_;
						gchar* _tmp45_ = NULL;
						gchar* _tmp46_;
						guint64 _tmp47_;
						gchar* _tmp48_ = NULL;
						gchar* _tmp49_;
						guint64 _tmp50_;
						guint64 _tmp51_;
						gchar* _tmp52_ = NULL;
						gchar* _tmp53_;
						const gchar* _tmp54_ = NULL;
						const gchar* _tmp55_ = NULL;
						const gchar* _tmp56_ = NULL;
						gchar* _tmp57_ = NULL;
						gchar* _tmp58_;
						gboolean _tmp59_ = FALSE;
						const gchar* _tmp60_ = NULL;
						_tmp40_ = exogenesis_hard_disk_get_Device (hd);
						_tmp41_ = gdu_pool_get_by_device_file (self->priv->_drivepool, _tmp40_);
						_tmp42_ = _g_object_ref0 (_tmp41_);
						_g_object_unref0 (dev);
						dev = _tmp42_;
						_tmp43_ = gdu_device_get_device_file (dev);
						_tmp44_ = exogenesis_install_partition_get_ByteSize (ip);
						_tmp45_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp44_);
						_tmp46_ = _tmp45_;
						_tmp47_ = exogenesis_install_partition_get_Start (ip);
						_tmp48_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp47_);
						_tmp49_ = _tmp48_;
						_tmp50_ = exogenesis_install_partition_get_Start (ip);
						_tmp51_ = exogenesis_install_partition_get_ByteSize (ip);
						_tmp52_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp50_ + _tmp51_);
						_tmp53_ = _tmp52_;
						_tmp54_ = exogenesis_install_partition_get_Type (ip);
						_tmp55_ = string_to_string (_tmp54_);
						_tmp56_ = exogenesis_install_partition_get_TypeID (ip);
						_tmp57_ = g_strdup_printf ("CREATING PARTITION ON DEVICE %s : Size = %s  : Start = %s : End = %s :" \
" Type = %s TypeID = %s\n", _tmp43_, _tmp46_, _tmp49_, _tmp53_, _tmp55_, _tmp56_);
						_tmp58_ = _tmp57_;
						exogenesis_general_functions_LogIt (_tmp58_);
						_g_free0 (_tmp58_);
						_g_free0 (_tmp53_);
						_g_free0 (_tmp49_);
						_g_free0 (_tmp46_);
						_tmp60_ = exogenesis_install_partition_get_TypeID (ip);
						if (g_strcmp0 (_tmp60_, "0x05") != 0) {
							const gchar* _tmp61_ = NULL;
							_tmp61_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp59_ = g_strcmp0 (_tmp61_, "swap") != 0;
						} else {
							_tmp59_ = FALSE;
						}
						if (_tmp59_) {
							const gchar* _tmp62_ = NULL;
							guint64 _tmp63_;
							const gchar* _tmp64_ = NULL;
							gchar* _tmp65_;
							guint64 _tmp66_;
							guint64 _tmp67_;
							const gchar* _tmp68_ = NULL;
							const gchar* _tmp69_ = NULL;
							const gchar* _tmp70_ = NULL;
							gchar* _tmp71_;
							_tmp62_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp63_ = exogenesis_install_partition_get_ByteSize (ip);
							_tmp64_ = gdu_util_get_default_part_type_for_scheme_and_fstype ("mbr", _tmp62_, _tmp63_);
							_tmp65_ = g_strdup (_tmp64_);
							_g_free0 (parttype);
							parttype = _tmp65_;
							_tmp66_ = exogenesis_install_partition_get_Start (ip);
							_tmp67_ = exogenesis_install_partition_get_ByteSize (ip);
							_tmp68_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp69_ = exogenesis_install_partition_get_Label (ip);
							gdu_device_op_partition_create (dev, _tmp66_, _tmp67_, parttype, NULL, &_tmp70_, _tmp68_, _tmp69_, "", ownit, _exogenesis_hd_manager_CreatePartitionCallBack_gdu_device_partition_create_completed_func, self);
							_g_free0 (flags);
							_tmp71_ = g_strdup (_tmp70_);
							flags = _tmp71_;
						} else {
							const gchar* _tmp72_ = NULL;
							_tmp72_ = exogenesis_install_partition_get_TypeID (ip);
							if (g_strcmp0 (_tmp72_, "0x05") == 0) {
								guint64 _tmp73_;
								guint64 _tmp74_;
								const gchar* _tmp75_ = NULL;
								const gchar* _tmp76_ = NULL;
								const gchar* _tmp77_ = NULL;
								gchar* _tmp78_;
								_tmp73_ = exogenesis_install_partition_get_Start (ip);
								_tmp74_ = exogenesis_install_partition_get_ByteSize (ip);
								_tmp75_ = exogenesis_install_partition_get_TypeID (ip);
								_tmp76_ = exogenesis_install_partition_get_Label (ip);
								gdu_device_op_partition_create (dev, _tmp73_, _tmp74_, _tmp75_, NULL, &_tmp77_, NULL, _tmp76_, "", ownit, _exogenesis_hd_manager_CreatePartitionCallBack_gdu_device_partition_create_completed_func, self);
								_g_free0 (flags);
								_tmp78_ = g_strdup (_tmp77_);
								flags = _tmp78_;
							} else {
								guint64 _tmp79_;
								guint64 _tmp80_;
								const gchar* _tmp81_ = NULL;
								const gchar* _tmp82_ = NULL;
								const gchar* _tmp83_ = NULL;
								gchar* _tmp84_;
								_tmp79_ = exogenesis_install_partition_get_Start (ip);
								_tmp80_ = exogenesis_install_partition_get_ByteSize (ip);
								_tmp81_ = exogenesis_install_partition_get_TypeID (ip);
								_tmp82_ = exogenesis_install_partition_get_Label (ip);
								gdu_device_op_partition_create (dev, _tmp79_, _tmp80_, "0x82", NULL, &_tmp83_, _tmp81_, _tmp82_, "", FALSE, _exogenesis_hd_manager_CreatePartitionCallBack_gdu_device_partition_create_completed_func, self);
								_g_free0 (flags);
								_tmp84_ = g_strdup (_tmp83_);
								flags = _tmp84_;
							}
						}
						_g_object_unref0 (dev);
						dev = NULL;
					} else {
						g_signal_emit_by_name (self, "device-action-complete", "create", self->priv->_currentPIdx, self->priv->_currentEIdx, self->priv->_currentIDH);
					}
				}
			}
		}
	}
	_g_object_unref0 (dev);
	dev = NULL;
	_g_object_unref0 (hd);
	hd = NULL;
	_g_object_unref0 (hd);
	goto __finally17;
	__catch17_g_error:
	{
		GError * _error_;
		gchar* _tmp85_ = NULL;
		gchar* _tmp86_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp85_ = g_strdup_printf ("ERROR ON CREATE = %s\n", _error_->message);
		_tmp86_ = _tmp85_;
		exogenesis_general_functions_LogIt (_tmp86_);
		_g_free0 (_tmp86_);
		_g_error_free0 (_error_);
	}
	__finally17:
	if (_inner_error_ != NULL) {
		_g_free0 (upidevice);
		_g_free0 (dpidevice);
		_g_object_unref0 (dev);
		_g_free0 (parttype);
		_g_free0 (flags);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	_g_free0 (upidevice);
	_g_free0 (dpidevice);
	_g_object_unref0 (dev);
	_g_free0 (parttype);
	_g_free0 (flags);
	return result;
}


static gboolean exogenesis_hd_manager_Ownership (ExogenesisHDManager* self, const gchar* parttype) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gboolean ret;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	GQuark _tmp4_;
	static GQuark _tmp4__label0 = 0;
	static GQuark _tmp4__label1 = 0;
	static GQuark _tmp4__label2 = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (parttype != NULL, FALSE);
	_tmp0_ = g_strdup_printf ("OWNERSHIP PARTTYPE = %s\n", parttype);
	_tmp1_ = _tmp0_;
	exogenesis_general_functions_LogIt (_tmp1_);
	_g_free0 (_tmp1_);
	ret = FALSE;
	_tmp2_ = g_utf8_strdown (parttype, (gssize) (-1));
	_tmp3_ = _tmp2_;
	_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	g_free (_tmp3_);
	if (((_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("ntfs")))) || (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("fat"))))) || (_tmp4_ == ((0 != _tmp4__label2) ? _tmp4__label2 : (_tmp4__label2 = g_quark_from_static_string ("swap"))))) {
		switch (0) {
			default:
			{
				ret = FALSE;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				ret = TRUE;
				break;
			}
		}
	}
	result = ret;
	return result;
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static gboolean exogenesis_hd_manager_UnMountRequired (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, ExogenesisHardDisk* hd, gchar** pidevice) {
	gchar* _pidevice = NULL;
	gboolean result = FALSE;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ip != NULL, FALSE);
	g_return_val_if_fail (hd != NULL, FALSE);
	ret = FALSE;
	exogenesis_general_functions_LogIt ("CHECKING IF UMOUNT REQUIRED\n");
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _pi_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) hd);
		_pi_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			ExogenesisPartitionInfo* pi;
			const gchar* _tmp3_ = NULL;
			GduDevice* _tmp4_ = NULL;
			GduDevice* _tmp5_;
			GduDevice* d;
			gboolean _tmp6_ = FALSE;
			const gchar* _tmp7_ = NULL;
			gchar* _tmp8_ = NULL;
			gchar* _tmp9_;
			gboolean _tmp10_;
			_tmp1_ = gee_iterator_next (_pi_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_pi_it);
			pi = (ExogenesisPartitionInfo*) _tmp2_;
			_tmp3_ = exogenesis_partition_info_get_Device (pi);
			_tmp4_ = gdu_pool_get_by_device_file (self->priv->_drivepool, _tmp3_);
			_tmp5_ = _g_object_ref0 (_tmp4_);
			d = _tmp5_;
			_tmp7_ = exogenesis_partition_info_get_PartitionType (pi);
			_tmp8_ = g_utf8_strdown (_tmp7_, (gssize) (-1));
			_tmp9_ = _tmp8_;
			_tmp10_ = g_strcmp0 (_tmp9_, "unallocated") != 0;
			_g_free0 (_tmp9_);
			if (_tmp10_) {
				gboolean _tmp11_;
				_tmp11_ = gdu_device_is_mounted (d);
				_tmp6_ = _tmp11_;
			} else {
				_tmp6_ = FALSE;
			}
			if (_tmp6_) {
				const gchar* _tmp12_ = NULL;
				gboolean _tmp13_;
				gchar* _tmp14_ = NULL;
				gchar* _tmp15_;
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_;
				const gchar* _tmp18_ = NULL;
				gchar* _tmp19_;
				_tmp12_ = gdu_device_get_device_file (d);
				_tmp13_ = gdu_device_is_mounted (d);
				_tmp14_ = bool_to_string (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = g_strdup_printf ("MOUNT CHECK - %s - Device Mounted = %s\n", _tmp12_, _tmp15_);
				_tmp17_ = _tmp16_;
				exogenesis_general_functions_LogIt (_tmp17_);
				_g_free0 (_tmp17_);
				_g_free0 (_tmp15_);
				_tmp18_ = exogenesis_partition_info_get_Device (pi);
				_tmp19_ = g_strdup (_tmp18_);
				_g_free0 (_pidevice);
				_pidevice = _tmp19_;
				ret = TRUE;
				_g_object_unref0 (d);
				d = NULL;
				_g_object_unref0 (d);
				_g_object_unref0 (pi);
				break;
			}
			_g_object_unref0 (d);
			_g_object_unref0 (pi);
		}
		_g_object_unref0 (_pi_it);
	}
	if (ret == TRUE) {
		exogenesis_general_functions_LogIt ("UMOUNT REQUIRED\n");
	} else {
		exogenesis_general_functions_LogIt ("UMOUNT NOT REQUIRED\n");
	}
	result = ret;
	if (pidevice) {
		*pidevice = _pidevice;
	} else {
		_g_free0 (_pidevice);
	}
	return result;
}


static gboolean exogenesis_hd_manager_DeleteRequired (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, ExogenesisHardDisk** hd, gchar** pidevice) {
	gchar* _pidevice = NULL;
	gboolean result = FALSE;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ip != NULL, FALSE);
	g_return_val_if_fail (hd != NULL, FALSE);
	ret = FALSE;
	exogenesis_general_functions_LogIt ("CHECKING IF DELETE REQUIRED\n");
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _pi_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) (*hd));
		_pi_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			ExogenesisPartitionInfo* pi;
			gboolean _tmp3_ = FALSE;
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_ = FALSE;
			gboolean _tmp6_ = FALSE;
			guint64 _tmp7_;
			guint64 _tmp8_;
			_tmp1_ = gee_iterator_next (_pi_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_pi_it);
			pi = (ExogenesisPartitionInfo*) _tmp2_;
			_tmp7_ = exogenesis_partition_info_get_EndSector (pi);
			_tmp8_ = exogenesis_install_partition_get_Start (ip);
			if (_tmp7_ <= _tmp8_) {
				_tmp6_ = TRUE;
			} else {
				guint64 _tmp9_;
				guint64 _tmp10_;
				_tmp9_ = exogenesis_partition_info_get_StartSector (pi);
				_tmp10_ = exogenesis_install_partition_get_End (ip);
				_tmp6_ = _tmp9_ >= _tmp10_;
			}
			if (_tmp6_) {
				_tmp5_ = TRUE;
			} else {
				const gchar* _tmp11_ = NULL;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				_tmp11_ = exogenesis_partition_info_get_PartitionType (pi);
				_tmp12_ = g_utf8_strdown (_tmp11_, (gssize) (-1));
				_tmp13_ = _tmp12_;
				_tmp5_ = g_strcmp0 (_tmp13_, "unallocated") == 0;
				_g_free0 (_tmp13_);
			}
			if (_tmp5_) {
				_tmp4_ = TRUE;
			} else {
				gboolean _tmp14_ = FALSE;
				gboolean _tmp15_;
				_tmp15_ = exogenesis_install_partition_get_Format (ip);
				if (!_tmp15_) {
					gboolean _tmp16_;
					_tmp16_ = exogenesis_install_partition_get_NewPartition (ip);
					_tmp14_ = !_tmp16_;
				} else {
					_tmp14_ = FALSE;
				}
				_tmp4_ = _tmp14_;
			}
			if (_tmp4_) {
				_tmp3_ = TRUE;
			} else {
				gboolean _tmp17_ = FALSE;
				gboolean _tmp18_;
				_tmp18_ = exogenesis_install_partition_get_NewPartition (ip);
				if (!_tmp18_) {
					gboolean _tmp19_;
					_tmp19_ = exogenesis_install_partition_get_Use (ip);
					_tmp17_ = _tmp19_;
				} else {
					_tmp17_ = FALSE;
				}
				_tmp3_ = _tmp17_;
			}
			if (_tmp3_) {
				gchar* _tmp20_;
				_tmp20_ = g_strdup ("");
				_g_free0 (_pidevice);
				_pidevice = _tmp20_;
				ret = FALSE;
				_g_object_unref0 (pi);
				continue;
			} else {
				const gchar* _tmp21_ = NULL;
				gchar* _tmp22_;
				exogenesis_hard_disk_RemovePartition (*hd, pi);
				_tmp21_ = exogenesis_partition_info_get_Device (pi);
				_tmp22_ = g_strdup (_tmp21_);
				_g_free0 (_pidevice);
				_pidevice = _tmp22_;
				ret = TRUE;
				_g_object_unref0 (pi);
				break;
			}
			_g_object_unref0 (pi);
		}
		_g_object_unref0 (_pi_it);
	}
	if (ret) {
		exogenesis_general_functions_LogIt ("DELETE REQUIRED\n");
	} else {
		exogenesis_general_functions_LogIt ("DELETE NOT REQUIRED\n");
	}
	result = ret;
	if (pidevice) {
		*pidevice = _pidevice;
	} else {
		_g_free0 (_pidevice);
	}
	return result;
}


gboolean exogenesis_hd_manager_FormatPartition (ExogenesisHDManager* self, const gchar* DeviceName, const gchar* FSType) {
	gboolean result = FALSE;
	GduDevice* _tmp0_ = NULL;
	GduDevice* _tmp1_;
	GduDevice* dev;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (DeviceName != NULL, FALSE);
	g_return_val_if_fail (FSType != NULL, FALSE);
	_tmp0_ = gdu_pool_get_by_device_file (self->priv->_drivepool, DeviceName);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	dev = _tmp1_;
	result = TRUE;
	_g_object_unref0 (dev);
	return result;
}


void exogenesis_hd_manager_OnDeviceConnected (ExogenesisHDManager* self, GduDevice* dev) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dev != NULL);
	_tmp0_ = gdu_device_get_device_file (dev);
	_tmp1_ = g_strdup_printf ("Device Connected %s\n", _tmp0_);
	_tmp2_ = _tmp1_;
	exogenesis_general_functions_LogIt (_tmp2_);
	_g_free0 (_tmp2_);
}


void exogenesis_hd_manager_OnDeviceRemoved (ExogenesisHDManager* self, GduDevice* dev) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (dev != NULL);
	if (!self->PartitionerRunning) {
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		_tmp0_ = gdu_device_get_device_file (dev);
		_tmp1_ = g_strdup_printf ("Device Removed %s\n", _tmp0_);
		_tmp2_ = _tmp1_;
		exogenesis_general_functions_LogIt (_tmp2_);
		_g_free0 (_tmp2_);
		exogenesis_hd_manager_RefreshDisks (self);
	}
}


void exogenesis_hd_manager_OnDeviceChanged (ExogenesisHDManager* self, GduDevice* dev) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (dev != NULL);
	if (!self->PartitionerRunning) {
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		_tmp0_ = gdu_device_get_device_file (dev);
		_tmp1_ = g_strdup_printf ("Device Changed %s\n", _tmp0_);
		_tmp2_ = _tmp1_;
		exogenesis_general_functions_LogIt (_tmp2_);
		_g_free0 (_tmp2_);
		exogenesis_hd_manager_RefreshDisks (self);
	}
}


static void exogenesis_hd_manager_UnMountCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	if (_error_ == NULL) {
		g_signal_emit_by_name (self, "drive-un-mounted");
	} else {
		g_signal_emit_by_name (self, "disk-manager-error", _error_);
	}
}


static void exogenesis_hd_manager_UnMountCallBackEvt (ExogenesisHDManager* self, GduDevice* d, GError* _error_) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	_tmp0_ = gdu_device_get_device_file (d);
	_tmp1_ = g_strdup_printf ("CALLBACK CALLED UNMOUNT %s\n", _tmp0_);
	_tmp2_ = _tmp1_;
	exogenesis_general_functions_LogIt (_tmp2_);
	_g_free0 (_tmp2_);
	if (_error_ == NULL) {
		g_signal_emit_by_name (self, "device-action-complete", "unmount", self->priv->_currentPIdx, self->priv->_currentEIdx, self->priv->_currentIDH);
	} else {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		_tmp3_ = gdu_device_get_device_file (d);
		_tmp4_ = g_strdup_printf ("Error UNMOUNTING device %s\n", _tmp3_);
		_tmp5_ = _tmp4_;
		exogenesis_general_functions_LogIt (_tmp5_);
		_g_free0 (_tmp5_);
	}
}


static void exogenesis_hd_manager_FileSystemCreateCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	if (_error_ == NULL) {
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		_tmp0_ = gdu_device_get_device_file (d);
		_tmp1_ = g_strdup_printf ("FILESYSTEM CREATED %s\n", _tmp0_);
		_tmp2_ = _tmp1_;
		exogenesis_general_functions_LogIt (_tmp2_);
		_g_free0 (_tmp2_);
		g_signal_emit_by_name (self, "device-action-complete", "create", self->priv->_currentPIdx, self->priv->_currentEIdx, self->priv->_currentIDH);
	} else {
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp3_ = g_strdup_printf ("ERROR CREATING FILESYSTEM %s\n", _error_->message);
		_tmp4_ = _tmp3_;
		exogenesis_general_functions_LogIt (_tmp4_);
		_g_free0 (_tmp4_);
	}
}


static void exogenesis_hd_manager_PartitionTableCreateCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
}


static void exogenesis_hd_manager_MountCallBack (ExogenesisHDManager* self, GduDevice* d, const gchar* mountpoint, GError* _error_) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	g_return_if_fail (mountpoint != NULL);
	if (_error_ == NULL) {
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		const gchar* _tmp3_ = NULL;
		_tmp0_ = gdu_device_get_device_file (d);
		_tmp1_ = g_strdup_printf ("DEVICE MOUNTED %s\n", _tmp0_);
		_tmp2_ = _tmp1_;
		exogenesis_general_functions_LogIt (_tmp2_);
		_g_free0 (_tmp2_);
		_tmp3_ = gdu_device_id_get_uuid (d);
		exogenesis_hd_manager_AddMountPath (self, _tmp3_, mountpoint);
		g_signal_emit_by_name (self, "drive-mounted", mountpoint);
	} else {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gboolean _tmp6_;
		gboolean _tmp7_;
		_tmp4_ = g_utf8_strdown (_error_->message, (gssize) (-1));
		_tmp5_ = _tmp4_;
		_tmp6_ = string_contains (_tmp5_, "is mounted");
		_tmp7_ = _tmp6_;
		_g_free0 (_tmp5_);
		if (_tmp7_) {
			const gchar* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			_tmp8_ = gdu_device_id_get_uuid (d);
			_tmp9_ = gdu_device_get_mount_path (d);
			exogenesis_hd_manager_AddMountPath (self, _tmp8_, _tmp9_);
			_tmp10_ = gdu_device_get_mount_path (d);
			g_signal_emit_by_name (self, "drive-mounted", _tmp10_);
		} else {
			exogenesis_general_functions_LogIt ("MOUNT CALLBACK ERROR: ");
			g_signal_emit_by_name (self, "disk-manager-error", _error_);
		}
	}
	self->priv->_MountComplete = TRUE;
}


static void exogenesis_hd_manager_PartitionDeletedCallBack (ExogenesisHDManager* self, GduDevice* d, GError* _error_) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	if (_error_ == NULL) {
		exogenesis_general_functions_LogIt ("PARTITION DELETED\n");
		g_signal_emit_by_name (self, "device-action-complete", "delete", self->priv->_currentPIdx, self->priv->_currentEIdx, self->priv->_currentIDH);
	} else {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		_tmp0_ = g_strdup_printf ("ERROR DELETING DEVICE %s\n", _error_->message);
		_tmp1_ = _tmp0_;
		exogenesis_general_functions_LogIt (_tmp1_);
		_g_free0 (_tmp1_);
	}
}


void exogenesis_hd_manager_CreatePartitionCallBack (ExogenesisHDManager* self, GduDevice* d, const gchar* objectPath, GError* _error_) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (d != NULL);
	g_return_if_fail (objectPath != NULL);
	if (_error_ == NULL) {
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* cmd;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp0_ = gdu_device_get_device_file (d);
		_tmp1_ = g_strdup_printf ("sfdisk -R %s", _tmp0_);
		cmd = _tmp1_;
		_tmp2_ = gdu_device_get_device_file (d);
		_tmp3_ = g_strdup_printf ("PARTITION CREATED %s\n", _tmp2_);
		_tmp4_ = _tmp3_;
		exogenesis_general_functions_LogIt (_tmp4_);
		_g_free0 (_tmp4_);
		g_spawn_command_line_sync (cmd, NULL, NULL, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		g_signal_emit_by_name (self, "device-action-complete", "create", self->priv->_currentPIdx, self->priv->_currentEIdx, self->priv->_currentIDH);
		_g_free0 (cmd);
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		_tmp5_ = g_strdup_printf ("CREATE PARTITION ERROR %s\n", _error_->message);
		_tmp6_ = _tmp5_;
		exogenesis_general_functions_LogIt (_tmp6_);
		_g_free0 (_tmp6_);
	}
}


gint exogenesis_hd_manager_get_HardDiskCount (ExogenesisHDManager* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_HardDiskCount;
	return result;
}


void exogenesis_hd_manager_set_HardDiskCount (ExogenesisHDManager* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_HardDiskCount = value;
}


GeeArrayList* exogenesis_hd_manager_get_FileSystemTypes (ExogenesisHDManager* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_fsTypes;
	return result;
}


static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_STRING) (gpointer data1, gint arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__STRING_INT_INT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_INT_INT_OBJECT) (gpointer data1, const char* arg_1, gint arg_2, gint arg_3, gpointer arg_4, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT_INT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT_INT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), g_value_get_int (param_values + 3), g_value_get_object (param_values + 4), data2);
}


static void exogenesis_value_hd_manager_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_hd_manager_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_hd_manager_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_hd_manager_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_hd_manager_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_hd_manager_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_hd_manager_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisHDManager* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_hd_manager_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_hd_manager_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisHDManager** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_hd_manager_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecHDManager* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_HD_MANAGER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_hd_manager (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_HD_MANAGER), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object) {
	ExogenesisHDManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_HD_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_HD_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_hd_manager_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_hd_manager_unref (old);
	}
}


void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object) {
	ExogenesisHDManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_HD_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_HD_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_hd_manager_unref (old);
	}
}


static void exogenesis_hd_manager_class_init (ExogenesisHDManagerClass * klass) {
	exogenesis_hd_manager_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_HD_MANAGER_CLASS (klass)->finalize = exogenesis_hd_manager_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisHDManagerPrivate));
	g_signal_new ("drive_mounted", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("drive_un_mounted", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("partition_created", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_STRING, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_STRING);
	g_signal_new ("partition_deleted", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("disk_manager_error", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__POINTER, G_TYPE_NONE, 1, G_TYPE_POINTER);
	g_signal_new ("device_added", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EXOGENESIS_TYPE_HARD_DISK);
	g_signal_new ("device_removed", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EXOGENESIS_TYPE_HARD_DISK);
	g_signal_new ("device_changed", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EXOGENESIS_TYPE_HARD_DISK);
	g_signal_new ("device_connected", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("device_action_complete", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT_INT_OBJECT, G_TYPE_NONE, 4, G_TYPE_STRING, G_TYPE_INT, G_TYPE_INT, EXOGENESIS_TYPE_INSTALL_HARD_DISK);
	g_signal_new ("devices_refreshed", EXOGENESIS_TYPE_HD_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void exogenesis_hd_manager_instance_init (ExogenesisHDManager * self) {
	ExogenesisMountPoints* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	self->priv = EXOGENESIS_HD_MANAGER_GET_PRIVATE (self);
	self->ThreadStop = FALSE;
	self->PartitionerRunning = FALSE;
	_tmp0_ = exogenesis_mount_points_new ();
	self->priv->_MountPoints = _tmp0_;
	self->priv->_MountComplete = FALSE;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_str_hash, g_str_equal, NULL);
	self->priv->FSTab = _tmp1_;
	_tmp2_ = gee_array_list_new (EXOGENESIS_TYPE_HARD_DISK, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->HardDisks = _tmp2_;
	_tmp3_ = gee_array_list_new (EXOGENESIS_TYPE_FILESYSTEM_TYPE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_fsTypes = _tmp3_;
	self->ref_count = 1;
}


static void exogenesis_hd_manager_finalize (ExogenesisHDManager* obj) {
	ExogenesisHDManager * self;
	self = EXOGENESIS_HD_MANAGER (obj);
	_g_object_unref0 (self->priv->_drivepool);
	_g_object_unref0 (self->priv->_MountPoints);
	_g_object_unref0 (self->priv->FSTab);
	_g_object_unref0 (self->HardDisks);
	_g_object_unref0 (self->priv->_fsTypes);
	_g_object_unref0 (self->priv->_currentIDH);
}


GType exogenesis_hd_manager_get_type (void) {
	static volatile gsize exogenesis_hd_manager_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_hd_manager_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_hd_manager_init, exogenesis_value_hd_manager_free_value, exogenesis_value_hd_manager_copy_value, exogenesis_value_hd_manager_peek_pointer, "p", exogenesis_value_hd_manager_collect_value, "p", exogenesis_value_hd_manager_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisHDManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_hd_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisHDManager), 0, (GInstanceInitFunc) exogenesis_hd_manager_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_hd_manager_type_id;
		exogenesis_hd_manager_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisHDManager", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_hd_manager_type_id__volatile, exogenesis_hd_manager_type_id);
	}
	return exogenesis_hd_manager_type_id__volatile;
}


gpointer exogenesis_hd_manager_ref (gpointer instance) {
	ExogenesisHDManager* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_hd_manager_unref (gpointer instance) {
	ExogenesisHDManager* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_HD_MANAGER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisHardDisk* exogenesis_hard_disk_construct (GType object_type) {
	ExogenesisHardDisk * self = NULL;
	self = (ExogenesisHardDisk*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisHardDisk* exogenesis_hard_disk_new (void) {
	return exogenesis_hard_disk_construct (EXOGENESIS_TYPE_HARD_DISK);
}


static gint exogenesis_hard_disk_GetPartitionCount (ExogenesisHardDisk* self) {
	gint result = 0;
	gint i;
	g_return_val_if_fail (self != NULL, 0);
	i = 0;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _pi_list;
		gint _tmp1_;
		gint _pi_size;
		gint _pi_index;
		_tmp0_ = _g_object_ref0 (self->_partitions);
		_pi_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _pi_list);
		_pi_size = _tmp1_;
		_pi_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisPartitionInfo* pi;
			const gchar* _tmp3_ = NULL;
			gboolean _tmp4_;
			_pi_index = _pi_index + 1;
			if (!(_pi_index < _pi_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _pi_list, _pi_index);
			pi = (ExogenesisPartitionInfo*) _tmp2_;
			_tmp3_ = exogenesis_partition_info_get_PartitionType (pi);
			_tmp4_ = string_contains (_tmp3_, "Extended");
			if (!_tmp4_) {
				i++;
			}
			_g_object_unref0 (pi);
		}
		_g_object_unref0 (_pi_list);
	}
	result = i;
	return result;
}


static guint64 exogenesis_hard_disk_GetFirstStartSector (ExogenesisHardDisk* self) {
	guint64 result = 0ULL;
	ExogenesisPartitionInfo* p;
	g_return_val_if_fail (self != NULL, 0ULL);
	p = NULL;
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _pi_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) self);
		_pi_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			ExogenesisPartitionInfo* pi;
			_tmp1_ = gee_iterator_next (_pi_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_pi_it);
			pi = (ExogenesisPartitionInfo*) _tmp2_;
			{
				GeeIterator* _tmp3_ = NULL;
				GeeIterator* _ip_it;
				_tmp3_ = gee_iterable_iterator ((GeeIterable*) self);
				_ip_it = _tmp3_;
				while (TRUE) {
					gboolean _tmp4_;
					gpointer _tmp5_ = NULL;
					ExogenesisPartitionInfo* ip;
					guint64 _tmp6_;
					guint64 _tmp7_;
					_tmp4_ = gee_iterator_next (_ip_it);
					if (!_tmp4_) {
						break;
					}
					_tmp5_ = gee_iterator_get (_ip_it);
					ip = (ExogenesisPartitionInfo*) _tmp5_;
					_tmp6_ = exogenesis_partition_info_get_StartSector (pi);
					_tmp7_ = exogenesis_partition_info_get_StartSector (ip);
					if (_tmp6_ < _tmp7_) {
						ExogenesisPartitionInfo* _tmp8_;
						_tmp8_ = _g_object_ref0 (pi);
						_g_object_unref0 (p);
						p = _tmp8_;
					}
					_g_object_unref0 (ip);
				}
				_g_object_unref0 (_ip_it);
			}
			_g_object_unref0 (pi);
		}
		_g_object_unref0 (_pi_it);
	}
	if (p == NULL) {
		guint64 _tmp9_ = 0ULL;
		gint _tmp10_;
		_tmp10_ = gee_collection_get_size ((GeeCollection*) self->_partitions);
		if (_tmp10_ == 0) {
			_tmp9_ = (guint64) 0;
		} else {
			gpointer _tmp11_ = NULL;
			ExogenesisPartitionInfo* _tmp12_;
			guint64 _tmp13_;
			_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) self->_partitions, 0);
			_tmp12_ = (ExogenesisPartitionInfo*) _tmp11_;
			_tmp13_ = exogenesis_partition_info_get_StartSector (_tmp12_);
			_tmp9_ = _tmp13_;
			_g_object_unref0 (_tmp12_);
		}
		result = _tmp9_;
		_g_object_unref0 (p);
		return result;
	} else {
		guint64 _tmp14_;
		_tmp14_ = exogenesis_partition_info_get_StartSector (p);
		result = _tmp14_;
		_g_object_unref0 (p);
		return result;
	}
	_g_object_unref0 (p);
}


guint64 exogenesis_hard_disk_FirstPartitionStartSector (ExogenesisHardDisk* self) {
	guint64 result = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = (guint64) 0;
	return result;
}


void exogenesis_hard_disk_RemovePartition (ExogenesisHardDisk* self, ExogenesisPartitionInfo* pi) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (pi != NULL);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->_partitions, pi);
}


void exogenesis_hard_disk_AddPartition (ExogenesisHardDisk* self, ExogenesisPartitionInfo* pi) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (pi != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->_partitions, pi);
}


void exogenesis_hard_disk_SortPartitions (ExogenesisHardDisk* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->_partitions, NULL);
}


static GeeIterator* exogenesis_hard_disk_real_iterator (GeeIterable* base) {
	ExogenesisHardDisk * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisHardDisk*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->_partitions);
	result = _tmp0_;
	return result;
}


const gchar* exogenesis_hard_disk_get_Model (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Model;
	return result;
}


void exogenesis_hard_disk_set_Model (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Model);
	self->priv->_Model = _tmp0_;
	g_object_notify ((GObject *) self, "Model");
}


const gchar* exogenesis_hard_disk_get_Firmware (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Firmware;
	return result;
}


void exogenesis_hard_disk_set_Firmware (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Firmware);
	self->priv->_Firmware = _tmp0_;
	g_object_notify ((GObject *) self, "Firmware");
}


const gchar* exogenesis_hard_disk_get_Location (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Location;
	return result;
}


void exogenesis_hard_disk_set_Location (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Location);
	self->priv->_Location = _tmp0_;
	g_object_notify ((GObject *) self, "Location");
}


gboolean exogenesis_hard_disk_get_WriteCacheEnabled (ExogenesisHardDisk* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_WriteCacheEnabled;
	return result;
}


void exogenesis_hard_disk_set_WriteCacheEnabled (ExogenesisHardDisk* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_WriteCacheEnabled = value;
	g_object_notify ((GObject *) self, "WriteCacheEnabled");
}


guint64 exogenesis_hard_disk_get_Capacity (ExogenesisHardDisk* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_Capacity;
	return result;
}


void exogenesis_hard_disk_set_Capacity (ExogenesisHardDisk* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Capacity = value;
	g_object_notify ((GObject *) self, "Capacity");
}


const gchar* exogenesis_hard_disk_get_CapacityDescription (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_CapacityDescription;
	return result;
}


void exogenesis_hard_disk_set_CapacityDescription (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_CapacityDescription);
	self->priv->_CapacityDescription = _tmp0_;
	g_object_notify ((GObject *) self, "CapacityDescription");
}


const gchar* exogenesis_hard_disk_get_Partitioning (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Partitioning;
	return result;
}


void exogenesis_hard_disk_set_Partitioning (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Partitioning);
	self->priv->_Partitioning = _tmp0_;
	g_object_notify ((GObject *) self, "Partitioning");
}


const gchar* exogenesis_hard_disk_get_SerialNumber (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_SerialNumber;
	return result;
}


void exogenesis_hard_disk_set_SerialNumber (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_SerialNumber);
	self->priv->_SerialNumber = _tmp0_;
	g_object_notify ((GObject *) self, "SerialNumber");
}


const gchar* exogenesis_hard_disk_get_Device (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Device;
	return result;
}


void exogenesis_hard_disk_set_Device (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Device);
	self->priv->_Device = _tmp0_;
	g_object_notify ((GObject *) self, "Device");
}


const gchar* exogenesis_hard_disk_get_Connection (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Connection;
	return result;
}


void exogenesis_hard_disk_set_Connection (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Connection);
	self->priv->_Connection = _tmp0_;
	g_object_notify ((GObject *) self, "Connection");
}


const gchar* exogenesis_hard_disk_get_SmartStatus (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_SmartStatus;
	return result;
}


void exogenesis_hard_disk_set_SmartStatus (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_SmartStatus);
	self->priv->_SmartStatus = _tmp0_;
	g_object_notify ((GObject *) self, "SmartStatus");
}


gint exogenesis_hard_disk_get_PartitionCount (ExogenesisHardDisk* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = exogenesis_hard_disk_GetPartitionCount (self);
	result = _tmp0_;
	return result;
}


gboolean exogenesis_hard_disk_get_IsOptical (ExogenesisHardDisk* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_IsOptical;
	return result;
}


void exogenesis_hard_disk_set_IsOptical (ExogenesisHardDisk* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_IsOptical = value;
	g_object_notify ((GObject *) self, "IsOptical");
}


const gchar* exogenesis_hard_disk_get_PreviousOS (ExogenesisHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_PreviousOS;
	return result;
}


void exogenesis_hard_disk_set_PreviousOS (ExogenesisHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_PreviousOS);
	self->priv->_PreviousOS = _tmp0_;
	g_object_notify ((GObject *) self, "PreviousOS");
}


guint64 exogenesis_hard_disk_get_StartSector (ExogenesisHardDisk* self) {
	guint64 result;
	guint64 _tmp0_;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = exogenesis_hard_disk_GetFirstStartSector (self);
	result = _tmp0_;
	return result;
}


gboolean exogenesis_hard_disk_get_HasHomePartition (ExogenesisHardDisk* self) {
	gboolean result;
	gboolean bHasHome;
	g_return_val_if_fail (self != NULL, FALSE);
	bHasHome = FALSE;
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _pi_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) self);
		_pi_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			ExogenesisPartitionInfo* pi;
			const gchar* _tmp3_ = NULL;
			gboolean _tmp4_;
			_tmp1_ = gee_iterator_next (_pi_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_pi_it);
			pi = (ExogenesisPartitionInfo*) _tmp2_;
			_tmp3_ = exogenesis_partition_info_get_MountPoint (pi);
			_tmp4_ = string_contains (_tmp3_, "home");
			if (_tmp4_) {
				bHasHome = TRUE;
				_g_object_unref0 (pi);
				break;
			}
			_g_object_unref0 (pi);
		}
		_g_object_unref0 (_pi_it);
	}
	result = bHasHome;
	return result;
}


static GType exogenesis_hard_disk_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisHardDisk* self;
	self = (ExogenesisHardDisk*) base;
	result = EXOGENESIS_TYPE_PARTITION_INFO;
	return result;
}


static void exogenesis_hard_disk_class_init (ExogenesisHardDiskClass * klass) {
	exogenesis_hard_disk_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisHardDiskPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_hard_disk_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_hard_disk_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_hard_disk_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_MODEL, g_param_spec_string ("Model", "Model", "Model", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_FIRMWARE, g_param_spec_string ("Firmware", "Firmware", "Firmware", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_LOCATION, g_param_spec_string ("Location", "Location", "Location", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_WRITE_CACHE_ENABLED, g_param_spec_boolean ("WriteCacheEnabled", "WriteCacheEnabled", "WriteCacheEnabled", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_CAPACITY, g_param_spec_uint64 ("Capacity", "Capacity", "Capacity", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_CAPACITY_DESCRIPTION, g_param_spec_string ("CapacityDescription", "CapacityDescription", "CapacityDescription", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_PARTITIONING, g_param_spec_string ("Partitioning", "Partitioning", "Partitioning", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_SERIAL_NUMBER, g_param_spec_string ("SerialNumber", "SerialNumber", "SerialNumber", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_DEVICE, g_param_spec_string ("Device", "Device", "Device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_CONNECTION, g_param_spec_string ("Connection", "Connection", "Connection", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_SMART_STATUS, g_param_spec_string ("SmartStatus", "SmartStatus", "SmartStatus", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_PARTITION_COUNT, g_param_spec_int ("PartitionCount", "PartitionCount", "PartitionCount", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_IS_OPTICAL, g_param_spec_boolean ("IsOptical", "IsOptical", "IsOptical", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_PREVIOUS_OS, g_param_spec_string ("PreviousOS", "PreviousOS", "PreviousOS", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_START_SECTOR, g_param_spec_uint64 ("StartSector", "StartSector", "StartSector", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_HAS_HOME_PARTITION, g_param_spec_boolean ("HasHomePartition", "HasHomePartition", "HasHomePartition", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_HARD_DISK_ELEMENT_TYPE, "element-type");
}


static void exogenesis_hard_disk_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_hard_disk_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_hard_disk_real_iterator;
	iface->get_element_type = exogenesis_hard_disk_real_get_element_type;
}


static void exogenesis_hard_disk_instance_init (ExogenesisHardDisk * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = EXOGENESIS_HARD_DISK_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_PARTITION_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->_partitions = _tmp0_;
}


static void exogenesis_hard_disk_finalize (GObject* obj) {
	ExogenesisHardDisk * self;
	self = EXOGENESIS_HARD_DISK (obj);
	_g_free0 (self->priv->_Model);
	_g_free0 (self->priv->_Firmware);
	_g_free0 (self->priv->_Location);
	_g_free0 (self->priv->_CapacityDescription);
	_g_free0 (self->priv->_Partitioning);
	_g_free0 (self->priv->_SerialNumber);
	_g_free0 (self->priv->_Device);
	_g_free0 (self->priv->_Connection);
	_g_free0 (self->priv->_SmartStatus);
	_g_free0 (self->priv->_PreviousOS);
	_g_object_unref0 (self->_partitions);
	G_OBJECT_CLASS (exogenesis_hard_disk_parent_class)->finalize (obj);
}


GType exogenesis_hard_disk_get_type (void) {
	static volatile gsize exogenesis_hard_disk_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_hard_disk_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisHardDiskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_hard_disk_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisHardDisk), 0, (GInstanceInitFunc) exogenesis_hard_disk_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_hard_disk_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_hard_disk_type_id;
		exogenesis_hard_disk_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisHardDisk", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_hard_disk_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_hard_disk_type_id__volatile, exogenesis_hard_disk_type_id);
	}
	return exogenesis_hard_disk_type_id__volatile;
}


static void _vala_exogenesis_hard_disk_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisHardDisk * self;
	self = EXOGENESIS_HARD_DISK (object);
	switch (property_id) {
		case EXOGENESIS_HARD_DISK_MODEL:
		g_value_set_string (value, exogenesis_hard_disk_get_Model (self));
		break;
		case EXOGENESIS_HARD_DISK_FIRMWARE:
		g_value_set_string (value, exogenesis_hard_disk_get_Firmware (self));
		break;
		case EXOGENESIS_HARD_DISK_LOCATION:
		g_value_set_string (value, exogenesis_hard_disk_get_Location (self));
		break;
		case EXOGENESIS_HARD_DISK_WRITE_CACHE_ENABLED:
		g_value_set_boolean (value, exogenesis_hard_disk_get_WriteCacheEnabled (self));
		break;
		case EXOGENESIS_HARD_DISK_CAPACITY:
		g_value_set_uint64 (value, exogenesis_hard_disk_get_Capacity (self));
		break;
		case EXOGENESIS_HARD_DISK_CAPACITY_DESCRIPTION:
		g_value_set_string (value, exogenesis_hard_disk_get_CapacityDescription (self));
		break;
		case EXOGENESIS_HARD_DISK_PARTITIONING:
		g_value_set_string (value, exogenesis_hard_disk_get_Partitioning (self));
		break;
		case EXOGENESIS_HARD_DISK_SERIAL_NUMBER:
		g_value_set_string (value, exogenesis_hard_disk_get_SerialNumber (self));
		break;
		case EXOGENESIS_HARD_DISK_DEVICE:
		g_value_set_string (value, exogenesis_hard_disk_get_Device (self));
		break;
		case EXOGENESIS_HARD_DISK_CONNECTION:
		g_value_set_string (value, exogenesis_hard_disk_get_Connection (self));
		break;
		case EXOGENESIS_HARD_DISK_SMART_STATUS:
		g_value_set_string (value, exogenesis_hard_disk_get_SmartStatus (self));
		break;
		case EXOGENESIS_HARD_DISK_PARTITION_COUNT:
		g_value_set_int (value, exogenesis_hard_disk_get_PartitionCount (self));
		break;
		case EXOGENESIS_HARD_DISK_IS_OPTICAL:
		g_value_set_boolean (value, exogenesis_hard_disk_get_IsOptical (self));
		break;
		case EXOGENESIS_HARD_DISK_PREVIOUS_OS:
		g_value_set_string (value, exogenesis_hard_disk_get_PreviousOS (self));
		break;
		case EXOGENESIS_HARD_DISK_START_SECTOR:
		g_value_set_uint64 (value, exogenesis_hard_disk_get_StartSector (self));
		break;
		case EXOGENESIS_HARD_DISK_HAS_HOME_PARTITION:
		g_value_set_boolean (value, exogenesis_hard_disk_get_HasHomePartition (self));
		break;
		case EXOGENESIS_HARD_DISK_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_hard_disk_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisHardDisk * self;
	self = EXOGENESIS_HARD_DISK (object);
	switch (property_id) {
		case EXOGENESIS_HARD_DISK_MODEL:
		exogenesis_hard_disk_set_Model (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_FIRMWARE:
		exogenesis_hard_disk_set_Firmware (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_LOCATION:
		exogenesis_hard_disk_set_Location (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_WRITE_CACHE_ENABLED:
		exogenesis_hard_disk_set_WriteCacheEnabled (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_HARD_DISK_CAPACITY:
		exogenesis_hard_disk_set_Capacity (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_HARD_DISK_CAPACITY_DESCRIPTION:
		exogenesis_hard_disk_set_CapacityDescription (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_PARTITIONING:
		exogenesis_hard_disk_set_Partitioning (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_SERIAL_NUMBER:
		exogenesis_hard_disk_set_SerialNumber (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_DEVICE:
		exogenesis_hard_disk_set_Device (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_CONNECTION:
		exogenesis_hard_disk_set_Connection (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_SMART_STATUS:
		exogenesis_hard_disk_set_SmartStatus (self, g_value_get_string (value));
		break;
		case EXOGENESIS_HARD_DISK_IS_OPTICAL:
		exogenesis_hard_disk_set_IsOptical (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_HARD_DISK_PREVIOUS_OS:
		exogenesis_hard_disk_set_PreviousOS (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gint exogenesis_partition_info_real_compare_to (GeeComparable* base, ExogenesisPartitionInfo* comp) {
	ExogenesisPartitionInfo * self;
	gint result = 0;
	self = (ExogenesisPartitionInfo*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (self->priv->_StartSector < comp->priv->_StartSector) {
		result = -1;
		return result;
	}
	if (self->priv->_StartSector > comp->priv->_StartSector) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


void exogenesis_partition_info_AddPartition (ExogenesisPartitionInfo* self, ExogenesisPartitionInfo* pi) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (pi != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_lstPartitions, pi);
	gee_list_sort ((GeeList*) self->priv->_lstPartitions, NULL);
}


void exogenesis_partition_info_RemovePartition (ExogenesisPartitionInfo* self, ExogenesisPartitionInfo* pi) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (pi != NULL);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_lstPartitions, pi);
}


static GeeIterator* exogenesis_partition_info_real_iterator (GeeIterable* base) {
	ExogenesisPartitionInfo * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisPartitionInfo*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_lstPartitions);
	result = _tmp0_;
	return result;
}


void exogenesis_partition_info_SortPartitions (ExogenesisPartitionInfo* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->priv->_lstPartitions, NULL);
}


ExogenesisPartitionInfo* exogenesis_partition_info_construct (GType object_type) {
	ExogenesisPartitionInfo * self = NULL;
	self = (ExogenesisPartitionInfo*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisPartitionInfo* exogenesis_partition_info_new (void) {
	return exogenesis_partition_info_construct (EXOGENESIS_TYPE_PARTITION_INFO);
}


const gchar* exogenesis_partition_info_get_Usage (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Usage;
	return result;
}


void exogenesis_partition_info_set_Usage (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Usage);
	self->priv->_Usage = _tmp0_;
	g_object_notify ((GObject *) self, "Usage");
}


const gchar* exogenesis_partition_info_get_PartitionType (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_PartitionType;
	return result;
}


void exogenesis_partition_info_set_PartitionType (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_PartitionType);
	self->priv->_PartitionType = _tmp0_;
	g_object_notify ((GObject *) self, "PartitionType");
}


const gchar* exogenesis_partition_info_get_OSType (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_OSType;
	return result;
}


void exogenesis_partition_info_set_OSType (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_OSType);
	self->priv->_OSType = _tmp0_;
	g_object_notify ((GObject *) self, "OSType");
}


const gchar* exogenesis_partition_info_get_OSTypeID (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_OSTypeID;
	return result;
}


void exogenesis_partition_info_set_OSTypeID (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_OSTypeID);
	self->priv->_OSTypeID = _tmp0_;
	g_object_notify ((GObject *) self, "OSTypeID");
}


const gchar* exogenesis_partition_info_get_Label (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Label;
	return result;
}


void exogenesis_partition_info_set_Label (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Label);
	self->priv->_Label = _tmp0_;
	g_object_notify ((GObject *) self, "Label");
}


const gchar* exogenesis_partition_info_get_Device (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Device;
	return result;
}


void exogenesis_partition_info_set_Device (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Device);
	self->priv->_Device = _tmp0_;
	g_object_notify ((GObject *) self, "Device");
}


const gchar* exogenesis_partition_info_get_PartitionLabel (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_PartitionLabel;
	return result;
}


void exogenesis_partition_info_set_PartitionLabel (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_PartitionLabel);
	self->priv->_PartitionLabel = _tmp0_;
	g_object_notify ((GObject *) self, "PartitionLabel");
}


const gchar* exogenesis_partition_info_get_CapacityDescription (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_CapacityDescription;
	return result;
}


void exogenesis_partition_info_set_CapacityDescription (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_CapacityDescription);
	self->priv->_CapacityDescription = _tmp0_;
	g_object_notify ((GObject *) self, "CapacityDescription");
}


guint64 exogenesis_partition_info_get_Capacity (ExogenesisPartitionInfo* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_Capacity;
	return result;
}


void exogenesis_partition_info_set_Capacity (ExogenesisPartitionInfo* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Capacity = value;
	g_object_notify ((GObject *) self, "Capacity");
}


const gchar* exogenesis_partition_info_get_AvailableDescription (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_AvailableDescription;
	return result;
}


void exogenesis_partition_info_set_AvailableDescription (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_AvailableDescription);
	self->priv->_AvailableDescription = _tmp0_;
	g_object_notify ((GObject *) self, "AvailableDescription");
}


guint64 exogenesis_partition_info_get_AvailableCapacity (ExogenesisPartitionInfo* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_AvailableCapacity;
	return result;
}


void exogenesis_partition_info_set_AvailableCapacity (ExogenesisPartitionInfo* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_AvailableCapacity = value;
	g_object_notify ((GObject *) self, "AvailableCapacity");
}


const gchar* exogenesis_partition_info_get_MountPoint (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_MountPoint;
	return result;
}


void exogenesis_partition_info_set_MountPoint (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_MountPoint);
	self->priv->_MountPoint = _tmp0_;
	g_object_notify ((GObject *) self, "MountPoint");
}


const gchar* exogenesis_partition_info_get_PartitionFlags (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_PartitionFlags;
	return result;
}


void exogenesis_partition_info_set_PartitionFlags (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_PartitionFlags);
	self->priv->_PartitionFlags = _tmp0_;
	g_object_notify ((GObject *) self, "PartitionFlags");
}


gint exogenesis_partition_info_get_PartitionNumber (ExogenesisPartitionInfo* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_PartitionNumber;
	return result;
}


void exogenesis_partition_info_set_PartitionNumber (ExogenesisPartitionInfo* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_PartitionNumber = value;
	g_object_notify ((GObject *) self, "PartitionNumber");
}


guint64 exogenesis_partition_info_get_StartSector (ExogenesisPartitionInfo* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_StartSector;
	return result;
}


void exogenesis_partition_info_set_StartSector (ExogenesisPartitionInfo* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_StartSector = value;
	g_object_notify ((GObject *) self, "StartSector");
}


guint64 exogenesis_partition_info_get_EndSector (ExogenesisPartitionInfo* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_EndSector;
	return result;
}


void exogenesis_partition_info_set_EndSector (ExogenesisPartitionInfo* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_EndSector = value;
	g_object_notify ((GObject *) self, "EndSector");
}


const gchar* exogenesis_partition_info_get_UUID (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_UUID;
	return result;
}


void exogenesis_partition_info_set_UUID (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_UUID);
	self->priv->_UUID = _tmp0_;
	g_object_notify ((GObject *) self, "UUID");
}


const gchar* exogenesis_partition_info_get_FSTabMountPoint (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_FSTabMountPoint;
	return result;
}


void exogenesis_partition_info_set_FSTabMountPoint (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_FSTabMountPoint);
	self->priv->_FSTabMountPoint = _tmp0_;
	g_object_notify ((GObject *) self, "FSTabMountPoint");
}


gboolean exogenesis_partition_info_get_IsMounted (ExogenesisPartitionInfo* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_IsMounted;
	return result;
}


void exogenesis_partition_info_set_IsMounted (ExogenesisPartitionInfo* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_IsMounted = value;
	g_object_notify ((GObject *) self, "IsMounted");
}


const gchar* exogenesis_partition_info_get_ParentDevice (ExogenesisPartitionInfo* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_ParentDevice;
	return result;
}


void exogenesis_partition_info_set_ParentDevice (ExogenesisPartitionInfo* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_ParentDevice);
	self->priv->_ParentDevice = _tmp0_;
	g_object_notify ((GObject *) self, "ParentDevice");
}


static GType exogenesis_partition_info_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisPartitionInfo* self;
	self = (ExogenesisPartitionInfo*) base;
	result = EXOGENESIS_TYPE_PARTITION_INFO;
	return result;
}


static void exogenesis_partition_info_class_init (ExogenesisPartitionInfoClass * klass) {
	exogenesis_partition_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisPartitionInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_partition_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_partition_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_partition_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_USAGE, g_param_spec_string ("Usage", "Usage", "Usage", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_PARTITION_TYPE, g_param_spec_string ("PartitionType", "PartitionType", "PartitionType", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_OS_TYPE, g_param_spec_string ("OSType", "OSType", "OSType", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_OS_TYPE_ID, g_param_spec_string ("OSTypeID", "OSTypeID", "OSTypeID", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_LABEL, g_param_spec_string ("Label", "Label", "Label", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_DEVICE, g_param_spec_string ("Device", "Device", "Device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_PARTITION_LABEL, g_param_spec_string ("PartitionLabel", "PartitionLabel", "PartitionLabel", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_CAPACITY_DESCRIPTION, g_param_spec_string ("CapacityDescription", "CapacityDescription", "CapacityDescription", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_CAPACITY, g_param_spec_uint64 ("Capacity", "Capacity", "Capacity", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_AVAILABLE_DESCRIPTION, g_param_spec_string ("AvailableDescription", "AvailableDescription", "AvailableDescription", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_AVAILABLE_CAPACITY, g_param_spec_uint64 ("AvailableCapacity", "AvailableCapacity", "AvailableCapacity", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_MOUNT_POINT, g_param_spec_string ("MountPoint", "MountPoint", "MountPoint", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_PARTITION_FLAGS, g_param_spec_string ("PartitionFlags", "PartitionFlags", "PartitionFlags", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_PARTITION_NUMBER, g_param_spec_int ("PartitionNumber", "PartitionNumber", "PartitionNumber", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_START_SECTOR, g_param_spec_uint64 ("StartSector", "StartSector", "StartSector", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_END_SECTOR, g_param_spec_uint64 ("EndSector", "EndSector", "EndSector", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_UUID, g_param_spec_string ("UUID", "UUID", "UUID", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_FS_TAB_MOUNT_POINT, g_param_spec_string ("FSTabMountPoint", "FSTabMountPoint", "FSTabMountPoint", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_IS_MOUNTED, g_param_spec_boolean ("IsMounted", "IsMounted", "IsMounted", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_PARENT_DEVICE, g_param_spec_string ("ParentDevice", "ParentDevice", "ParentDevice", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_PARTITION_INFO_ELEMENT_TYPE, "element-type");
}


static void exogenesis_partition_info_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_partition_info_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_partition_info_real_compare_to;
}


static void exogenesis_partition_info_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_partition_info_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_partition_info_real_iterator;
	iface->get_element_type = exogenesis_partition_info_real_get_element_type;
}


static void exogenesis_partition_info_instance_init (ExogenesisPartitionInfo * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	GeeArrayList* _tmp13_ = NULL;
	self->priv = EXOGENESIS_PARTITION_INFO_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->priv->_Usage = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->priv->_PartitionType = _tmp1_;
	_tmp2_ = g_strdup ("");
	self->priv->_OSType = _tmp2_;
	_tmp3_ = g_strdup ("");
	self->priv->_OSTypeID = _tmp3_;
	_tmp4_ = g_strdup ("");
	self->priv->_Label = _tmp4_;
	_tmp5_ = g_strdup ("");
	self->priv->_Device = _tmp5_;
	_tmp6_ = g_strdup ("");
	self->priv->_PartitionLabel = _tmp6_;
	_tmp7_ = g_strdup ("");
	self->priv->_CapacityDescription = _tmp7_;
	_tmp8_ = g_strdup ("");
	self->priv->_AvailableDescription = _tmp8_;
	_tmp9_ = g_strdup ("");
	self->priv->_MountPoint = _tmp9_;
	_tmp10_ = g_strdup ("");
	self->priv->_PartitionFlags = _tmp10_;
	_tmp11_ = g_strdup ("");
	self->priv->_UUID = _tmp11_;
	_tmp12_ = g_strdup ("");
	self->priv->_FSTabMountPoint = _tmp12_;
	_tmp13_ = gee_array_list_new (EXOGENESIS_TYPE_PARTITION_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_lstPartitions = _tmp13_;
}


static void exogenesis_partition_info_finalize (GObject* obj) {
	ExogenesisPartitionInfo * self;
	self = EXOGENESIS_PARTITION_INFO (obj);
	_g_free0 (self->priv->_Usage);
	_g_free0 (self->priv->_PartitionType);
	_g_free0 (self->priv->_OSType);
	_g_free0 (self->priv->_OSTypeID);
	_g_free0 (self->priv->_Label);
	_g_free0 (self->priv->_Device);
	_g_free0 (self->priv->_PartitionLabel);
	_g_free0 (self->priv->_CapacityDescription);
	_g_free0 (self->priv->_AvailableDescription);
	_g_free0 (self->priv->_MountPoint);
	_g_free0 (self->priv->_PartitionFlags);
	_g_free0 (self->priv->_UUID);
	_g_free0 (self->priv->_FSTabMountPoint);
	_g_free0 (self->priv->_ParentDevice);
	_g_object_unref0 (self->priv->_lstPartitions);
	G_OBJECT_CLASS (exogenesis_partition_info_parent_class)->finalize (obj);
}


GType exogenesis_partition_info_get_type (void) {
	static volatile gsize exogenesis_partition_info_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_partition_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisPartitionInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_partition_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisPartitionInfo), 0, (GInstanceInitFunc) exogenesis_partition_info_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_partition_info_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_partition_info_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_partition_info_type_id;
		exogenesis_partition_info_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisPartitionInfo", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_partition_info_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_type_add_interface_static (exogenesis_partition_info_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_partition_info_type_id__volatile, exogenesis_partition_info_type_id);
	}
	return exogenesis_partition_info_type_id__volatile;
}


static void _vala_exogenesis_partition_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisPartitionInfo * self;
	self = EXOGENESIS_PARTITION_INFO (object);
	switch (property_id) {
		case EXOGENESIS_PARTITION_INFO_USAGE:
		g_value_set_string (value, exogenesis_partition_info_get_Usage (self));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_TYPE:
		g_value_set_string (value, exogenesis_partition_info_get_PartitionType (self));
		break;
		case EXOGENESIS_PARTITION_INFO_OS_TYPE:
		g_value_set_string (value, exogenesis_partition_info_get_OSType (self));
		break;
		case EXOGENESIS_PARTITION_INFO_OS_TYPE_ID:
		g_value_set_string (value, exogenesis_partition_info_get_OSTypeID (self));
		break;
		case EXOGENESIS_PARTITION_INFO_LABEL:
		g_value_set_string (value, exogenesis_partition_info_get_Label (self));
		break;
		case EXOGENESIS_PARTITION_INFO_DEVICE:
		g_value_set_string (value, exogenesis_partition_info_get_Device (self));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_LABEL:
		g_value_set_string (value, exogenesis_partition_info_get_PartitionLabel (self));
		break;
		case EXOGENESIS_PARTITION_INFO_CAPACITY_DESCRIPTION:
		g_value_set_string (value, exogenesis_partition_info_get_CapacityDescription (self));
		break;
		case EXOGENESIS_PARTITION_INFO_CAPACITY:
		g_value_set_uint64 (value, exogenesis_partition_info_get_Capacity (self));
		break;
		case EXOGENESIS_PARTITION_INFO_AVAILABLE_DESCRIPTION:
		g_value_set_string (value, exogenesis_partition_info_get_AvailableDescription (self));
		break;
		case EXOGENESIS_PARTITION_INFO_AVAILABLE_CAPACITY:
		g_value_set_uint64 (value, exogenesis_partition_info_get_AvailableCapacity (self));
		break;
		case EXOGENESIS_PARTITION_INFO_MOUNT_POINT:
		g_value_set_string (value, exogenesis_partition_info_get_MountPoint (self));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_FLAGS:
		g_value_set_string (value, exogenesis_partition_info_get_PartitionFlags (self));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_NUMBER:
		g_value_set_int (value, exogenesis_partition_info_get_PartitionNumber (self));
		break;
		case EXOGENESIS_PARTITION_INFO_START_SECTOR:
		g_value_set_uint64 (value, exogenesis_partition_info_get_StartSector (self));
		break;
		case EXOGENESIS_PARTITION_INFO_END_SECTOR:
		g_value_set_uint64 (value, exogenesis_partition_info_get_EndSector (self));
		break;
		case EXOGENESIS_PARTITION_INFO_UUID:
		g_value_set_string (value, exogenesis_partition_info_get_UUID (self));
		break;
		case EXOGENESIS_PARTITION_INFO_FS_TAB_MOUNT_POINT:
		g_value_set_string (value, exogenesis_partition_info_get_FSTabMountPoint (self));
		break;
		case EXOGENESIS_PARTITION_INFO_IS_MOUNTED:
		g_value_set_boolean (value, exogenesis_partition_info_get_IsMounted (self));
		break;
		case EXOGENESIS_PARTITION_INFO_PARENT_DEVICE:
		g_value_set_string (value, exogenesis_partition_info_get_ParentDevice (self));
		break;
		case EXOGENESIS_PARTITION_INFO_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_partition_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisPartitionInfo * self;
	self = EXOGENESIS_PARTITION_INFO (object);
	switch (property_id) {
		case EXOGENESIS_PARTITION_INFO_USAGE:
		exogenesis_partition_info_set_Usage (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_TYPE:
		exogenesis_partition_info_set_PartitionType (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_OS_TYPE:
		exogenesis_partition_info_set_OSType (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_OS_TYPE_ID:
		exogenesis_partition_info_set_OSTypeID (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_LABEL:
		exogenesis_partition_info_set_Label (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_DEVICE:
		exogenesis_partition_info_set_Device (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_LABEL:
		exogenesis_partition_info_set_PartitionLabel (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_CAPACITY_DESCRIPTION:
		exogenesis_partition_info_set_CapacityDescription (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_CAPACITY:
		exogenesis_partition_info_set_Capacity (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_PARTITION_INFO_AVAILABLE_DESCRIPTION:
		exogenesis_partition_info_set_AvailableDescription (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_AVAILABLE_CAPACITY:
		exogenesis_partition_info_set_AvailableCapacity (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_PARTITION_INFO_MOUNT_POINT:
		exogenesis_partition_info_set_MountPoint (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_FLAGS:
		exogenesis_partition_info_set_PartitionFlags (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_PARTITION_NUMBER:
		exogenesis_partition_info_set_PartitionNumber (self, g_value_get_int (value));
		break;
		case EXOGENESIS_PARTITION_INFO_START_SECTOR:
		exogenesis_partition_info_set_StartSector (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_PARTITION_INFO_END_SECTOR:
		exogenesis_partition_info_set_EndSector (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_PARTITION_INFO_UUID:
		exogenesis_partition_info_set_UUID (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_FS_TAB_MOUNT_POINT:
		exogenesis_partition_info_set_FSTabMountPoint (self, g_value_get_string (value));
		break;
		case EXOGENESIS_PARTITION_INFO_IS_MOUNTED:
		exogenesis_partition_info_set_IsMounted (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_PARTITION_INFO_PARENT_DEVICE:
		exogenesis_partition_info_set_ParentDevice (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisFilesystemType* exogenesis_filesystem_type_construct (GType object_type) {
	ExogenesisFilesystemType * self = NULL;
	self = (ExogenesisFilesystemType*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisFilesystemType* exogenesis_filesystem_type_new (void) {
	return exogenesis_filesystem_type_construct (EXOGENESIS_TYPE_FILESYSTEM_TYPE);
}


gchar* exogenesis_filesystem_type_to_string (ExogenesisFilesystemType* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	gchar* ret;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = bool_to_string (self->priv->_CanCreate);
	_tmp1_ = _tmp0_;
	_tmp2_ = bool_to_string (self->priv->_CanMount);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup_printf ("%i", self->priv->_MaxLabelLen);
	_tmp5_ = _tmp4_;
	_tmp6_ = bool_to_string (self->priv->_SupportUnixOwner);
	_tmp7_ = _tmp6_;
	_tmp8_ = bool_to_string (self->priv->_AllowLabelRename);
	_tmp9_ = _tmp8_;
	_tmp10_ = bool_to_string (self->priv->_SupportFsck);
	_tmp11_ = _tmp10_;
	_tmp12_ = bool_to_string (self->priv->_SupportResizeEnlarge);
	_tmp13_ = _tmp12_;
	_tmp14_ = bool_to_string (self->priv->_SupportResizeShrink);
	_tmp15_ = _tmp14_;
	_tmp16_ = bool_to_string (self->priv->_SupportEnlargeOnline);
	_tmp17_ = _tmp16_;
	_tmp18_ = bool_to_string (self->priv->_SupportShrinkOnline);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strdup_printf ("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n", self->priv->_ID, self->priv->_Name, _tmp1_, _tmp3_, _tmp5_, _tmp7_, _tmp9_, _tmp11_, _tmp13_, _tmp15_, _tmp17_, _tmp19_);
	_tmp21_ = _tmp20_;
	_g_free0 (_tmp19_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	ret = _tmp21_;
	result = ret;
	return result;
}


const gchar* exogenesis_filesystem_type_get_ID (ExogenesisFilesystemType* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_ID;
	return result;
}


void exogenesis_filesystem_type_set_ID (ExogenesisFilesystemType* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_ID);
	self->priv->_ID = _tmp0_;
	g_object_notify ((GObject *) self, "ID");
}


const gchar* exogenesis_filesystem_type_get_Name (ExogenesisFilesystemType* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Name;
	return result;
}


void exogenesis_filesystem_type_set_Name (ExogenesisFilesystemType* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Name);
	self->priv->_Name = _tmp0_;
	g_object_notify ((GObject *) self, "Name");
}


gboolean exogenesis_filesystem_type_get_CanCreate (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_CanCreate;
	return result;
}


void exogenesis_filesystem_type_set_CanCreate (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_CanCreate = value;
	g_object_notify ((GObject *) self, "CanCreate");
}


gboolean exogenesis_filesystem_type_get_CanMount (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_CanMount;
	return result;
}


void exogenesis_filesystem_type_set_CanMount (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_CanMount = value;
	g_object_notify ((GObject *) self, "CanMount");
}


gint exogenesis_filesystem_type_get_MaxLabelLen (ExogenesisFilesystemType* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_MaxLabelLen;
	return result;
}


void exogenesis_filesystem_type_set_MaxLabelLen (ExogenesisFilesystemType* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_MaxLabelLen = value;
	g_object_notify ((GObject *) self, "MaxLabelLen");
}


gboolean exogenesis_filesystem_type_get_SupportUnixOwner (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportUnixOwner;
	return result;
}


void exogenesis_filesystem_type_set_SupportUnixOwner (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportUnixOwner = value;
	g_object_notify ((GObject *) self, "SupportUnixOwner");
}


gboolean exogenesis_filesystem_type_get_AllowLabelRename (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_AllowLabelRename;
	return result;
}


void exogenesis_filesystem_type_set_AllowLabelRename (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_AllowLabelRename = value;
	g_object_notify ((GObject *) self, "AllowLabelRename");
}


gboolean exogenesis_filesystem_type_get_SupportFsck (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportFsck;
	return result;
}


void exogenesis_filesystem_type_set_SupportFsck (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportFsck = value;
	g_object_notify ((GObject *) self, "SupportFsck");
}


gboolean exogenesis_filesystem_type_get_SupportResizeEnlarge (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportResizeEnlarge;
	return result;
}


void exogenesis_filesystem_type_set_SupportResizeEnlarge (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportResizeEnlarge = value;
	g_object_notify ((GObject *) self, "SupportResizeEnlarge");
}


gboolean exogenesis_filesystem_type_get_SupportResizeShrink (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportResizeShrink;
	return result;
}


void exogenesis_filesystem_type_set_SupportResizeShrink (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportResizeShrink = value;
	g_object_notify ((GObject *) self, "SupportResizeShrink");
}


gboolean exogenesis_filesystem_type_get_SupportEnlargeOnline (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportEnlargeOnline;
	return result;
}


void exogenesis_filesystem_type_set_SupportEnlargeOnline (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportEnlargeOnline = value;
	g_object_notify ((GObject *) self, "SupportEnlargeOnline");
}


gboolean exogenesis_filesystem_type_get_SupportShrinkOnline (ExogenesisFilesystemType* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SupportShrinkOnline;
	return result;
}


void exogenesis_filesystem_type_set_SupportShrinkOnline (ExogenesisFilesystemType* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SupportShrinkOnline = value;
	g_object_notify ((GObject *) self, "SupportShrinkOnline");
}


static void exogenesis_filesystem_type_class_init (ExogenesisFilesystemTypeClass * klass) {
	exogenesis_filesystem_type_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisFilesystemTypePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_filesystem_type_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_filesystem_type_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_filesystem_type_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_ID, g_param_spec_string ("ID", "ID", "ID", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_NAME, g_param_spec_string ("Name", "Name", "Name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_CAN_CREATE, g_param_spec_boolean ("CanCreate", "CanCreate", "CanCreate", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_CAN_MOUNT, g_param_spec_boolean ("CanMount", "CanMount", "CanMount", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_MAX_LABEL_LEN, g_param_spec_int ("MaxLabelLen", "MaxLabelLen", "MaxLabelLen", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_UNIX_OWNER, g_param_spec_boolean ("SupportUnixOwner", "SupportUnixOwner", "SupportUnixOwner", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_ALLOW_LABEL_RENAME, g_param_spec_boolean ("AllowLabelRename", "AllowLabelRename", "AllowLabelRename", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_FSCK, g_param_spec_boolean ("SupportFsck", "SupportFsck", "SupportFsck", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_ENLARGE, g_param_spec_boolean ("SupportResizeEnlarge", "SupportResizeEnlarge", "SupportResizeEnlarge", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_SHRINK, g_param_spec_boolean ("SupportResizeShrink", "SupportResizeShrink", "SupportResizeShrink", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_ENLARGE_ONLINE, g_param_spec_boolean ("SupportEnlargeOnline", "SupportEnlargeOnline", "SupportEnlargeOnline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_SHRINK_ONLINE, g_param_spec_boolean ("SupportShrinkOnline", "SupportShrinkOnline", "SupportShrinkOnline", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void exogenesis_filesystem_type_instance_init (ExogenesisFilesystemType * self) {
	self->priv = EXOGENESIS_FILESYSTEM_TYPE_GET_PRIVATE (self);
}


static void exogenesis_filesystem_type_finalize (GObject* obj) {
	ExogenesisFilesystemType * self;
	self = EXOGENESIS_FILESYSTEM_TYPE (obj);
	_g_free0 (self->priv->_ID);
	_g_free0 (self->priv->_Name);
	G_OBJECT_CLASS (exogenesis_filesystem_type_parent_class)->finalize (obj);
}


GType exogenesis_filesystem_type_get_type (void) {
	static volatile gsize exogenesis_filesystem_type_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_filesystem_type_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisFilesystemTypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_filesystem_type_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisFilesystemType), 0, (GInstanceInitFunc) exogenesis_filesystem_type_instance_init, NULL };
		GType exogenesis_filesystem_type_type_id;
		exogenesis_filesystem_type_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisFilesystemType", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_filesystem_type_type_id__volatile, exogenesis_filesystem_type_type_id);
	}
	return exogenesis_filesystem_type_type_id__volatile;
}


static void _vala_exogenesis_filesystem_type_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisFilesystemType * self;
	self = EXOGENESIS_FILESYSTEM_TYPE (object);
	switch (property_id) {
		case EXOGENESIS_FILESYSTEM_TYPE_ID:
		g_value_set_string (value, exogenesis_filesystem_type_get_ID (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_NAME:
		g_value_set_string (value, exogenesis_filesystem_type_get_Name (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_CAN_CREATE:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_CanCreate (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_CAN_MOUNT:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_CanMount (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_MAX_LABEL_LEN:
		g_value_set_int (value, exogenesis_filesystem_type_get_MaxLabelLen (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_UNIX_OWNER:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportUnixOwner (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_ALLOW_LABEL_RENAME:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_AllowLabelRename (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_FSCK:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportFsck (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_ENLARGE:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportResizeEnlarge (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_SHRINK:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportResizeShrink (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_ENLARGE_ONLINE:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportEnlargeOnline (self));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_SHRINK_ONLINE:
		g_value_set_boolean (value, exogenesis_filesystem_type_get_SupportShrinkOnline (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_filesystem_type_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisFilesystemType * self;
	self = EXOGENESIS_FILESYSTEM_TYPE (object);
	switch (property_id) {
		case EXOGENESIS_FILESYSTEM_TYPE_ID:
		exogenesis_filesystem_type_set_ID (self, g_value_get_string (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_NAME:
		exogenesis_filesystem_type_set_Name (self, g_value_get_string (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_CAN_CREATE:
		exogenesis_filesystem_type_set_CanCreate (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_CAN_MOUNT:
		exogenesis_filesystem_type_set_CanMount (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_MAX_LABEL_LEN:
		exogenesis_filesystem_type_set_MaxLabelLen (self, g_value_get_int (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_UNIX_OWNER:
		exogenesis_filesystem_type_set_SupportUnixOwner (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_ALLOW_LABEL_RENAME:
		exogenesis_filesystem_type_set_AllowLabelRename (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_FSCK:
		exogenesis_filesystem_type_set_SupportFsck (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_ENLARGE:
		exogenesis_filesystem_type_set_SupportResizeEnlarge (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_RESIZE_SHRINK:
		exogenesis_filesystem_type_set_SupportResizeShrink (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_ENLARGE_ONLINE:
		exogenesis_filesystem_type_set_SupportEnlargeOnline (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_FILESYSTEM_TYPE_SUPPORT_SHRINK_ONLINE:
		exogenesis_filesystem_type_set_SupportShrinkOnline (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


void exogenesis_mount_points_AddMountPointValues (ExogenesisMountPoints* self, const gchar* key, const gchar* mountpoint, gint order) {
	ExogenesisMountPoint* _tmp0_ = NULL;
	ExogenesisMountPoint* mp;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (mountpoint != NULL);
	_tmp0_ = exogenesis_mount_point_new ();
	mp = _tmp0_;
	exogenesis_mount_point_set_Key (mp, key);
	exogenesis_mount_point_set_Path (mp, mountpoint);
	exogenesis_mount_point_set_DisplayOrder (mp, order);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->_MountPoints, mp);
	_g_object_unref0 (mp);
}


void exogenesis_mount_points_AddMountPoint (ExogenesisMountPoints* self, ExogenesisMountPoint* mp) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (mp != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->_MountPoints, mp);
}


void exogenesis_mount_points_Sort (ExogenesisMountPoints* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->_MountPoints, NULL);
}


static GeeIterator* exogenesis_mount_points_real_iterator (GeeIterable* base) {
	ExogenesisMountPoints * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisMountPoints*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->_MountPoints);
	result = _tmp0_;
	return result;
}


ExogenesisMountPoints* exogenesis_mount_points_construct (GType object_type) {
	ExogenesisMountPoints * self = NULL;
	self = (ExogenesisMountPoints*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisMountPoints* exogenesis_mount_points_new (void) {
	return exogenesis_mount_points_construct (EXOGENESIS_TYPE_MOUNT_POINTS);
}


static GType exogenesis_mount_points_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisMountPoints* self;
	self = (ExogenesisMountPoints*) base;
	result = EXOGENESIS_TYPE_MOUNT_POINT;
	return result;
}


static void exogenesis_mount_points_class_init (ExogenesisMountPointsClass * klass) {
	exogenesis_mount_points_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_mount_points_get_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_mount_points_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_MOUNT_POINTS_ELEMENT_TYPE, "element-type");
}


static void exogenesis_mount_points_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_mount_points_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_mount_points_real_iterator;
	iface->get_element_type = exogenesis_mount_points_real_get_element_type;
}


static void exogenesis_mount_points_instance_init (ExogenesisMountPoints * self) {
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_MOUNT_POINT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->_MountPoints = _tmp0_;
}


static void exogenesis_mount_points_finalize (GObject* obj) {
	ExogenesisMountPoints * self;
	self = EXOGENESIS_MOUNT_POINTS (obj);
	_g_object_unref0 (self->_MountPoints);
	G_OBJECT_CLASS (exogenesis_mount_points_parent_class)->finalize (obj);
}


GType exogenesis_mount_points_get_type (void) {
	static volatile gsize exogenesis_mount_points_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_mount_points_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisMountPointsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_mount_points_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisMountPoints), 0, (GInstanceInitFunc) exogenesis_mount_points_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_mount_points_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_mount_points_type_id;
		exogenesis_mount_points_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisMountPoints", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_mount_points_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_mount_points_type_id__volatile, exogenesis_mount_points_type_id);
	}
	return exogenesis_mount_points_type_id__volatile;
}


static void _vala_exogenesis_mount_points_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisMountPoints * self;
	self = EXOGENESIS_MOUNT_POINTS (object);
	switch (property_id) {
		case EXOGENESIS_MOUNT_POINTS_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisMountPoint* exogenesis_mount_point_construct (GType object_type) {
	ExogenesisMountPoint * self = NULL;
	self = (ExogenesisMountPoint*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisMountPoint* exogenesis_mount_point_new (void) {
	return exogenesis_mount_point_construct (EXOGENESIS_TYPE_MOUNT_POINT);
}


static gint exogenesis_mount_point_real_compare_to (GeeComparable* base, ExogenesisMountPoint* comp) {
	ExogenesisMountPoint * self;
	gint result = 0;
	self = (ExogenesisMountPoint*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (self->priv->_DisplayOrder < comp->priv->_DisplayOrder) {
		result = -1;
		return result;
	}
	if (self->priv->_DisplayOrder > comp->priv->_DisplayOrder) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


const gchar* exogenesis_mount_point_get_Key (ExogenesisMountPoint* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Key;
	return result;
}


void exogenesis_mount_point_set_Key (ExogenesisMountPoint* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Key);
	self->priv->_Key = _tmp0_;
	g_object_notify ((GObject *) self, "Key");
}


const gchar* exogenesis_mount_point_get_Path (ExogenesisMountPoint* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Path;
	return result;
}


void exogenesis_mount_point_set_Path (ExogenesisMountPoint* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Path);
	self->priv->_Path = _tmp0_;
	g_object_notify ((GObject *) self, "Path");
}


gint exogenesis_mount_point_get_DisplayOrder (ExogenesisMountPoint* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_DisplayOrder;
	return result;
}


void exogenesis_mount_point_set_DisplayOrder (ExogenesisMountPoint* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_DisplayOrder = value;
	g_object_notify ((GObject *) self, "DisplayOrder");
}


static void exogenesis_mount_point_class_init (ExogenesisMountPointClass * klass) {
	exogenesis_mount_point_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisMountPointPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_mount_point_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_mount_point_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_mount_point_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_MOUNT_POINT_KEY, g_param_spec_string ("Key", "Key", "Key", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_MOUNT_POINT_PATH, g_param_spec_string ("Path", "Path", "Path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_MOUNT_POINT_DISPLAY_ORDER, g_param_spec_int ("DisplayOrder", "DisplayOrder", "DisplayOrder", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void exogenesis_mount_point_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_mount_point_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_mount_point_real_compare_to;
}


static void exogenesis_mount_point_instance_init (ExogenesisMountPoint * self) {
	self->priv = EXOGENESIS_MOUNT_POINT_GET_PRIVATE (self);
}


static void exogenesis_mount_point_finalize (GObject* obj) {
	ExogenesisMountPoint * self;
	self = EXOGENESIS_MOUNT_POINT (obj);
	_g_free0 (self->priv->_Key);
	_g_free0 (self->priv->_Path);
	G_OBJECT_CLASS (exogenesis_mount_point_parent_class)->finalize (obj);
}


GType exogenesis_mount_point_get_type (void) {
	static volatile gsize exogenesis_mount_point_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_mount_point_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisMountPointClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_mount_point_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisMountPoint), 0, (GInstanceInitFunc) exogenesis_mount_point_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_mount_point_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_mount_point_type_id;
		exogenesis_mount_point_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisMountPoint", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_mount_point_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&exogenesis_mount_point_type_id__volatile, exogenesis_mount_point_type_id);
	}
	return exogenesis_mount_point_type_id__volatile;
}


static void _vala_exogenesis_mount_point_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisMountPoint * self;
	self = EXOGENESIS_MOUNT_POINT (object);
	switch (property_id) {
		case EXOGENESIS_MOUNT_POINT_KEY:
		g_value_set_string (value, exogenesis_mount_point_get_Key (self));
		break;
		case EXOGENESIS_MOUNT_POINT_PATH:
		g_value_set_string (value, exogenesis_mount_point_get_Path (self));
		break;
		case EXOGENESIS_MOUNT_POINT_DISPLAY_ORDER:
		g_value_set_int (value, exogenesis_mount_point_get_DisplayOrder (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_mount_point_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisMountPoint * self;
	self = EXOGENESIS_MOUNT_POINT (object);
	switch (property_id) {
		case EXOGENESIS_MOUNT_POINT_KEY:
		exogenesis_mount_point_set_Key (self, g_value_get_string (value));
		break;
		case EXOGENESIS_MOUNT_POINT_PATH:
		exogenesis_mount_point_set_Path (self, g_value_get_string (value));
		break;
		case EXOGENESIS_MOUNT_POINT_DISPLAY_ORDER:
		exogenesis_mount_point_set_DisplayOrder (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


void exogenesis_default_schema_AddPartitionData (ExogenesisDefaultSchema* self, ExogenesisDefaultPartitionData* dpd) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (dpd != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_dpd, dpd);
}


static GeeIterator* exogenesis_default_schema_real_iterator (GeeIterable* base) {
	ExogenesisDefaultSchema * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisDefaultSchema*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_dpd);
	result = _tmp0_;
	return result;
}


ExogenesisDefaultSchema* exogenesis_default_schema_construct (GType object_type) {
	ExogenesisDefaultSchema * self = NULL;
	self = (ExogenesisDefaultSchema*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisDefaultSchema* exogenesis_default_schema_new (void) {
	return exogenesis_default_schema_construct (EXOGENESIS_TYPE_DEFAULT_SCHEMA);
}


static GType exogenesis_default_schema_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisDefaultSchema* self;
	self = (ExogenesisDefaultSchema*) base;
	result = EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA;
	return result;
}


static void exogenesis_default_schema_class_init (ExogenesisDefaultSchemaClass * klass) {
	exogenesis_default_schema_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisDefaultSchemaPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_default_schema_get_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_default_schema_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_DEFAULT_SCHEMA_ELEMENT_TYPE, "element-type");
}


static void exogenesis_default_schema_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_default_schema_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_default_schema_real_iterator;
	iface->get_element_type = exogenesis_default_schema_real_get_element_type;
}


static void exogenesis_default_schema_instance_init (ExogenesisDefaultSchema * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = EXOGENESIS_DEFAULT_SCHEMA_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA, (GBoxedCopyFunc) exogenesis_default_partition_data_ref, exogenesis_default_partition_data_unref, NULL);
	self->priv->_dpd = _tmp0_;
}


static void exogenesis_default_schema_finalize (GObject* obj) {
	ExogenesisDefaultSchema * self;
	self = EXOGENESIS_DEFAULT_SCHEMA (obj);
	_g_object_unref0 (self->priv->_dpd);
	G_OBJECT_CLASS (exogenesis_default_schema_parent_class)->finalize (obj);
}


GType exogenesis_default_schema_get_type (void) {
	static volatile gsize exogenesis_default_schema_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_default_schema_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisDefaultSchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_default_schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisDefaultSchema), 0, (GInstanceInitFunc) exogenesis_default_schema_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_default_schema_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_default_schema_type_id;
		exogenesis_default_schema_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisDefaultSchema", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_default_schema_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_default_schema_type_id__volatile, exogenesis_default_schema_type_id);
	}
	return exogenesis_default_schema_type_id__volatile;
}


static void _vala_exogenesis_default_schema_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisDefaultSchema * self;
	self = EXOGENESIS_DEFAULT_SCHEMA (object);
	switch (property_id) {
		case EXOGENESIS_DEFAULT_SCHEMA_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisDefaultPartitionData* exogenesis_default_partition_data_construct (GType object_type) {
	ExogenesisDefaultPartitionData* self = NULL;
	self = (ExogenesisDefaultPartitionData*) g_type_create_instance (object_type);
	return self;
}


ExogenesisDefaultPartitionData* exogenesis_default_partition_data_new (void) {
	return exogenesis_default_partition_data_construct (EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA);
}


static const gchar* exogenesis_default_partition_data_get_MountPoint (ExogenesisDefaultPartitionData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_MountPoint;
	return result;
}


static void exogenesis_default_partition_data_set_MountPoint (ExogenesisDefaultPartitionData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_MountPoint);
	self->priv->_MountPoint = _tmp0_;
}


static const gchar* exogenesis_default_partition_data_get_Label (ExogenesisDefaultPartitionData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Label;
	return result;
}


static void exogenesis_default_partition_data_set_Label (ExogenesisDefaultPartitionData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Label);
	self->priv->_Label = _tmp0_;
}


static gint exogenesis_default_partition_data_get_Percentage (ExogenesisDefaultPartitionData* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_Percentage;
	return result;
}


static void exogenesis_default_partition_data_set_Percentage (ExogenesisDefaultPartitionData* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_Percentage = value;
}


static void exogenesis_value_default_partition_data_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_default_partition_data_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_default_partition_data_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_default_partition_data_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_default_partition_data_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_default_partition_data_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_default_partition_data_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisDefaultPartitionData* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_default_partition_data_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_default_partition_data_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisDefaultPartitionData** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_default_partition_data_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_default_partition_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecDefaultPartitionData* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_default_partition_data (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_default_partition_data (GValue* value, gpointer v_object) {
	ExogenesisDefaultPartitionData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_default_partition_data_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_default_partition_data_unref (old);
	}
}


void exogenesis_value_take_default_partition_data (GValue* value, gpointer v_object) {
	ExogenesisDefaultPartitionData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_DEFAULT_PARTITION_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_default_partition_data_unref (old);
	}
}


static void exogenesis_default_partition_data_class_init (ExogenesisDefaultPartitionDataClass * klass) {
	exogenesis_default_partition_data_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_DEFAULT_PARTITION_DATA_CLASS (klass)->finalize = exogenesis_default_partition_data_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisDefaultPartitionDataPrivate));
}


static void exogenesis_default_partition_data_instance_init (ExogenesisDefaultPartitionData * self) {
	self->priv = EXOGENESIS_DEFAULT_PARTITION_DATA_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void exogenesis_default_partition_data_finalize (ExogenesisDefaultPartitionData* obj) {
	ExogenesisDefaultPartitionData * self;
	self = EXOGENESIS_DEFAULT_PARTITION_DATA (obj);
	_g_free0 (self->priv->_MountPoint);
	_g_free0 (self->priv->_Label);
}


GType exogenesis_default_partition_data_get_type (void) {
	static volatile gsize exogenesis_default_partition_data_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_default_partition_data_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_default_partition_data_init, exogenesis_value_default_partition_data_free_value, exogenesis_value_default_partition_data_copy_value, exogenesis_value_default_partition_data_peek_pointer, "p", exogenesis_value_default_partition_data_collect_value, "p", exogenesis_value_default_partition_data_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisDefaultPartitionDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_default_partition_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisDefaultPartitionData), 0, (GInstanceInitFunc) exogenesis_default_partition_data_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_default_partition_data_type_id;
		exogenesis_default_partition_data_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisDefaultPartitionData", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_default_partition_data_type_id__volatile, exogenesis_default_partition_data_type_id);
	}
	return exogenesis_default_partition_data_type_id__volatile;
}


gpointer exogenesis_default_partition_data_ref (gpointer instance) {
	ExogenesisDefaultPartitionData* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_default_partition_data_unref (gpointer instance) {
	ExogenesisDefaultPartitionData* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_DEFAULT_PARTITION_DATA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



