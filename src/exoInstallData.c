/* exoInstallData.c generated by valac 0.12.1, the Vala compiler
 * generated from exoInstallData.vala, do not modify */

/*

    To install the system needs to know
    
    Details of the main user
    
    Location for install
    
        - disk and partition schema
        
    Language and location
    
    Timezone

*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define EXOGENESIS_TYPE_INSTALL_DATA (exogenesis_install_data_get_type ())
#define EXOGENESIS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallData))
#define EXOGENESIS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))
#define EXOGENESIS_IS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_IS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_INSTALL_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))

typedef struct _ExogenesisInstallData ExogenesisInstallData;
typedef struct _ExogenesisInstallDataClass ExogenesisInstallDataClass;
typedef struct _ExogenesisInstallDataPrivate ExogenesisInstallDataPrivate;

#define EXOGENESIS_TYPE_INSTALL_HARD_DISK (exogenesis_install_hard_disk_get_type ())
#define EXOGENESIS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDisk))
#define EXOGENESIS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))
#define EXOGENESIS_IS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_IS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_INSTALL_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))

typedef struct _ExogenesisInstallHardDisk ExogenesisInstallHardDisk;
typedef struct _ExogenesisInstallHardDiskClass ExogenesisInstallHardDiskClass;

#define EXOGENESIS_TYPE_INSTALL_USERS (exogenesis_install_users_get_type ())
#define EXOGENESIS_INSTALL_USERS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_USERS, ExogenesisInstallUsers))
#define EXOGENESIS_INSTALL_USERS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_USERS, ExogenesisInstallUsersClass))
#define EXOGENESIS_IS_INSTALL_USERS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_USERS))
#define EXOGENESIS_IS_INSTALL_USERS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_USERS))
#define EXOGENESIS_INSTALL_USERS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_USERS, ExogenesisInstallUsersClass))

typedef struct _ExogenesisInstallUsers ExogenesisInstallUsers;
typedef struct _ExogenesisInstallUsersClass ExogenesisInstallUsersClass;

#define EXOGENESIS_TYPE_INSTALL_GROUPS (exogenesis_install_groups_get_type ())
#define EXOGENESIS_INSTALL_GROUPS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_GROUPS, ExogenesisInstallGroups))
#define EXOGENESIS_INSTALL_GROUPS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_GROUPS, ExogenesisInstallGroupsClass))
#define EXOGENESIS_IS_INSTALL_GROUPS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_GROUPS))
#define EXOGENESIS_IS_INSTALL_GROUPS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_GROUPS))
#define EXOGENESIS_INSTALL_GROUPS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_GROUPS, ExogenesisInstallGroupsClass))

typedef struct _ExogenesisInstallGroups ExogenesisInstallGroups;
typedef struct _ExogenesisInstallGroupsClass ExogenesisInstallGroupsClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define EXOGENESIS_TYPE_USER_DETAIL (exogenesis_user_detail_get_type ())
#define EXOGENESIS_USER_DETAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetail))
#define EXOGENESIS_USER_DETAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetailClass))
#define EXOGENESIS_IS_USER_DETAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_USER_DETAIL))
#define EXOGENESIS_IS_USER_DETAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_USER_DETAIL))
#define EXOGENESIS_USER_DETAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetailClass))

typedef struct _ExogenesisUserDetail ExogenesisUserDetail;
typedef struct _ExogenesisUserDetailClass ExogenesisUserDetailClass;

#define EXOGENESIS_TYPE_GROUP (exogenesis_group_get_type ())
#define EXOGENESIS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_GROUP, ExogenesisGroup))
#define EXOGENESIS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_GROUP, ExogenesisGroupClass))
#define EXOGENESIS_IS_GROUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_GROUP))
#define EXOGENESIS_IS_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_GROUP))
#define EXOGENESIS_GROUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_GROUP, ExogenesisGroupClass))

typedef struct _ExogenesisGroup ExogenesisGroup;
typedef struct _ExogenesisGroupClass ExogenesisGroupClass;

#define EXOGENESIS_TYPE_INSTALLER (exogenesis_installer_get_type ())
#define EXOGENESIS_INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALLER, ExogenesisInstaller))
#define EXOGENESIS_INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALLER, ExogenesisInstallerClass))
#define EXOGENESIS_IS_INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALLER))
#define EXOGENESIS_IS_INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALLER))
#define EXOGENESIS_INSTALLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALLER, ExogenesisInstallerClass))

typedef struct _ExogenesisInstaller ExogenesisInstaller;
typedef struct _ExogenesisInstallerClass ExogenesisInstallerClass;
typedef struct _ExogenesisInstallerPrivate ExogenesisInstallerPrivate;

#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;
typedef struct _ExogenesisHDManagerPrivate ExogenesisHDManagerPrivate;

#define EXOGENESIS_TYPE_HARD_DISK (exogenesis_hard_disk_get_type ())
#define EXOGENESIS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDisk))
#define EXOGENESIS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))
#define EXOGENESIS_IS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_IS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))

typedef struct _ExogenesisHardDisk ExogenesisHardDisk;
typedef struct _ExogenesisHardDiskClass ExogenesisHardDiskClass;

#define EXOGENESIS_TYPE_INSTALL_PARTITION (exogenesis_install_partition_get_type ())
#define EXOGENESIS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartition))
#define EXOGENESIS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))
#define EXOGENESIS_IS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_IS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_INSTALL_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))

typedef struct _ExogenesisInstallPartition ExogenesisInstallPartition;
typedef struct _ExogenesisInstallPartitionClass ExogenesisInstallPartitionClass;
typedef struct _ExogenesisParamSpecInstaller ExogenesisParamSpecInstaller;
typedef struct _ExogenesisInstallHardDiskPrivate ExogenesisInstallHardDiskPrivate;
typedef struct _ExogenesisInstallPartitionPrivate ExogenesisInstallPartitionPrivate;
typedef struct _ExogenesisInstallUsersPrivate ExogenesisInstallUsersPrivate;
typedef struct _ExogenesisUserDetailPrivate ExogenesisUserDetailPrivate;
typedef struct _ExogenesisInstallGroupsPrivate ExogenesisInstallGroupsPrivate;
typedef struct _ExogenesisGroupPrivate ExogenesisGroupPrivate;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

struct _ExogenesisInstallData {
	GObject parent_instance;
	ExogenesisInstallDataPrivate * priv;
};

struct _ExogenesisInstallDataClass {
	GObjectClass parent_class;
};

struct _ExogenesisInstallDataPrivate {
	GeeArrayList* _installTargets;
	ExogenesisInstallUsers* _UserData;
	ExogenesisInstallGroups* _groups;
	gchar* _TimeZone;
	gchar* _Language;
	gchar* _KeyboardLayout;
	gchar* _KeyboardVariant;
	gchar* _SelectedTimeZone;
	gboolean _ManualTime;
	gchar* _GrubTarget;
};

struct _ExogenesisInstaller {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisInstallerPrivate * priv;
};

struct _ExogenesisInstallerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisInstaller *self);
};

struct _ExogenesisInstallerPrivate {
	ExogenesisInstallHardDisk* _currentiHD;
	gint copy_ticks;
	gint adjust_ticks;
	gint system_config_ticks;
	gint add_user_ticks;
	gint grub_ticks;
	gint total_ticks;
	gboolean _PartitionError;
	gchar* mountpoint;
};

struct _ExogenesisHDManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisHDManagerPrivate * priv;
	gboolean ThreadStop;
	gboolean PartitionerRunning;
	GeeArrayList* HardDisks;
};

struct _ExogenesisHDManagerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisHDManager *self);
};

struct _ExogenesisParamSpecInstaller {
	GParamSpec parent_instance;
};

struct _ExogenesisInstallHardDisk {
	GObject parent_instance;
	ExogenesisInstallHardDiskPrivate * priv;
};

struct _ExogenesisInstallHardDiskClass {
	GObjectClass parent_class;
};

struct _ExogenesisInstallHardDiskPrivate {
	gchar* _DeviceName;
	gchar* _Model;
	gchar* _SerialNumber;
	gboolean _IsGrubTarget;
	guint64 _DriveSize;
	GeeArrayList* _partitions;
};

struct _ExogenesisInstallPartition {
	GObject parent_instance;
	ExogenesisInstallPartitionPrivate * priv;
};

struct _ExogenesisInstallPartitionClass {
	GObjectClass parent_class;
};

struct _ExogenesisInstallPartitionPrivate {
	guint64 _ByteSize;
	gchar* _DisplaySize;
	gboolean _Format;
	gboolean _Use;
	gboolean _NewPartition;
	gchar* _MountPoint;
	gchar* _Type;
	gchar* _TypeID;
	gchar* _Label;
	guint64 _Start;
	guint64 _End;
	gchar* _Device;
	gchar* _ID;
	GeeArrayList* _lstPartitions;
};

struct _ExogenesisInstallUsers {
	GObject parent_instance;
	ExogenesisInstallUsersPrivate * priv;
	GeeArrayList* _Users;
};

struct _ExogenesisInstallUsersClass {
	GObjectClass parent_class;
};

struct _ExogenesisUserDetail {
	GObject parent_instance;
	ExogenesisUserDetailPrivate * priv;
};

struct _ExogenesisUserDetailClass {
	GObjectClass parent_class;
};

struct _ExogenesisUserDetailPrivate {
	gint _UserId;
	gint _GroupId;
	gchar* _Username;
	gchar* _Fullname;
	gchar* _OfficeLocation;
	gchar* _WorkPhone;
	gchar* _HomePhone;
	gchar* _HomeFolder;
	gchar* _Shell;
	gchar _Type;
	gchar* _Password;
	gboolean _EncryptHome;
	gboolean _AutoLogon;
	gboolean _RequirePassword;
	gboolean _MainAccount;
};

struct _ExogenesisInstallGroups {
	GObject parent_instance;
	ExogenesisInstallGroupsPrivate * priv;
	GeeArrayList* _Groups;
};

struct _ExogenesisInstallGroupsClass {
	GObjectClass parent_class;
};

struct _ExogenesisGroup {
	GObject parent_instance;
	ExogenesisGroupPrivate * priv;
};

struct _ExogenesisGroupClass {
	GObjectClass parent_class;
};

struct _ExogenesisGroupPrivate {
	gint _Id;
	gchar* _Name;
	gchar _Type;
	GList* _Users;
};


static gpointer exogenesis_install_data_parent_class = NULL;
static GeeIterableIface* exogenesis_install_data_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_installer_parent_class = NULL;
extern ExogenesisHDManager* exogenesis_gHDManager;
static gpointer exogenesis_install_hard_disk_parent_class = NULL;
static GeeIterableIface* exogenesis_install_hard_disk_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_install_partition_parent_class = NULL;
static GeeComparableIface* exogenesis_install_partition_gee_comparable_parent_iface = NULL;
static GeeIterableIface* exogenesis_install_partition_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_install_users_parent_class = NULL;
static GeeIterableIface* exogenesis_install_users_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_user_detail_parent_class = NULL;
static GeeComparableIface* exogenesis_user_detail_gee_comparable_parent_iface = NULL;
static gpointer exogenesis_install_groups_parent_class = NULL;
static GeeIterableIface* exogenesis_install_groups_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_group_parent_class = NULL;
static GeeComparableIface* exogenesis_group_gee_comparable_parent_iface = NULL;

GType exogenesis_install_data_get_type (void) G_GNUC_CONST;
GType exogenesis_install_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_install_users_get_type (void) G_GNUC_CONST;
GType exogenesis_install_groups_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_INSTALL_DATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataPrivate))
enum  {
	EXOGENESIS_INSTALL_DATA_DUMMY_PROPERTY,
	EXOGENESIS_INSTALL_DATA_TIME_ZONE,
	EXOGENESIS_INSTALL_DATA_LANGUAGE,
	EXOGENESIS_INSTALL_DATA_KEYBOARD_LAYOUT,
	EXOGENESIS_INSTALL_DATA_KEYBOARD_VARIANT,
	EXOGENESIS_INSTALL_DATA_SELECTED_TIME_ZONE,
	EXOGENESIS_INSTALL_DATA_MANUAL_TIME,
	EXOGENESIS_INSTALL_DATA_GRUB_TARGET,
	EXOGENESIS_INSTALL_DATA_HARD_DISK_COUNT,
	EXOGENESIS_INSTALL_DATA_ELEMENT_TYPE
};
ExogenesisInstallUsers* exogenesis_install_users_new (void);
ExogenesisInstallUsers* exogenesis_install_users_construct (GType object_type);
ExogenesisInstallGroups* exogenesis_install_groups_new (void);
ExogenesisInstallGroups* exogenesis_install_groups_construct (GType object_type);
GType exogenesis_user_detail_get_type (void) G_GNUC_CONST;
void exogenesis_install_data_AddUser (ExogenesisInstallData* self, ExogenesisUserDetail* user);
void exogenesis_install_users_AddUser (ExogenesisInstallUsers* self, ExogenesisUserDetail* user);
ExogenesisUserDetail* exogenesis_install_data_GetMainUser (ExogenesisInstallData* self);
gboolean exogenesis_user_detail_get_MainAccount (ExogenesisUserDetail* self);
GType exogenesis_group_get_type (void) G_GNUC_CONST;
void exogenesis_install_data_AddGroup (ExogenesisInstallData* self, ExogenesisGroup* group);
void exogenesis_install_groups_AddGroup (ExogenesisInstallGroups* self, ExogenesisGroup* group);
void exogenesis_install_data_AddInstallDisk (ExogenesisInstallData* self, ExogenesisInstallHardDisk* hd);
void exogenesis_install_data_ClearInstallDisks (ExogenesisInstallData* self);
ExogenesisInstallHardDisk* exogenesis_install_data_GetTargetHD (ExogenesisInstallData* self, gint index);
static GeeIterator* exogenesis_install_data_real_iterator (GeeIterable* base);
ExogenesisInstallData* exogenesis_install_data_new (void);
ExogenesisInstallData* exogenesis_install_data_construct (GType object_type);
const gchar* exogenesis_install_data_get_TimeZone (ExogenesisInstallData* self);
void exogenesis_install_data_set_TimeZone (ExogenesisInstallData* self, const gchar* value);
const gchar* exogenesis_install_data_get_Language (ExogenesisInstallData* self);
void exogenesis_install_data_set_Language (ExogenesisInstallData* self, const gchar* value);
const gchar* exogenesis_install_data_get_KeyboardLayout (ExogenesisInstallData* self);
void exogenesis_install_data_set_KeyboardLayout (ExogenesisInstallData* self, const gchar* value);
const gchar* exogenesis_install_data_get_KeyboardVariant (ExogenesisInstallData* self);
void exogenesis_install_data_set_KeyboardVariant (ExogenesisInstallData* self, const gchar* value);
const gchar* exogenesis_install_data_get_SelectedTimeZone (ExogenesisInstallData* self);
void exogenesis_install_data_set_SelectedTimeZone (ExogenesisInstallData* self, const gchar* value);
gboolean exogenesis_install_data_get_ManualTime (ExogenesisInstallData* self);
void exogenesis_install_data_set_ManualTime (ExogenesisInstallData* self, gboolean value);
const gchar* exogenesis_install_data_get_GrubTarget (ExogenesisInstallData* self);
void exogenesis_install_data_set_GrubTarget (ExogenesisInstallData* self, const gchar* value);
gint exogenesis_install_data_get_HardDiskCount (ExogenesisInstallData* self);
static void exogenesis_install_data_finalize (GObject* obj);
static void _vala_exogenesis_install_data_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_install_data_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gpointer exogenesis_installer_ref (gpointer instance);
void exogenesis_installer_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_installer (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_installer (GValue* value, gpointer v_object);
void exogenesis_value_take_installer (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_installer (const GValue* value);
GType exogenesis_installer_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_INSTALLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_INSTALLER, ExogenesisInstallerPrivate))
enum  {
	EXOGENESIS_INSTALLER_DUMMY_PROPERTY
};
#define EXOGENESIS_INSTALLER_MISC_TICKS 10
#define EXOGENESIS_INSTALLER_FORMAT_TICKS 1000
#define EXOGENESIS_INSTALLER_COPY_TICKS 10000
ExogenesisInstaller* exogenesis_installer_new (void);
ExogenesisInstaller* exogenesis_installer_construct (GType object_type);
gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
static void exogenesis_installer_DeviceAction (ExogenesisInstaller* self, const gchar* action, gint curpindex, gint cureindex, ExogenesisInstallHardDisk* ihd);
static void _exogenesis_installer_DeviceAction_exogenesis_hd_manager_device_action_complete (ExogenesisHDManager* _sender, const gchar* action, gint currentPindex, gint currentEindex, ExogenesisInstallHardDisk* ihd, gpointer self);
static void exogenesis_installer_OnDiskManagerError (ExogenesisInstaller* self, GError* err);
static void _exogenesis_installer_OnDiskManagerError_exogenesis_hd_manager_disk_manager_error (ExogenesisHDManager* _sender, GError* err, gpointer self);
void exogenesis_installer_CreatePartitionsStart (ExogenesisInstaller* self, ExogenesisInstallHardDisk* iHD);
GType exogenesis_hard_disk_get_type (void) G_GNUC_CONST;
gint exogenesis_install_hard_disk_get_PartitionCount (ExogenesisInstallHardDisk* self);
void exogenesis_general_functions_LogIt (const gchar* Message);
GType exogenesis_install_partition_get_type (void) G_GNUC_CONST;
gboolean exogenesis_hd_manager_CreatePartitionA (ExogenesisHDManager* self, ExogenesisInstallPartition* ip, gint pindex, gint eindex, ExogenesisInstallHardDisk* ihd, gboolean primary);
ExogenesisInstallPartition* exogenesis_install_hard_disk_GetPartition (ExogenesisInstallHardDisk* self, gint index);
gint exogenesis_install_partition_ExtPartitionCount (ExogenesisInstallPartition* self);
ExogenesisInstallPartition* exogenesis_install_partition_GetPartition (ExogenesisInstallPartition* self, gint idx);
static gboolean exogenesis_installer_CopyFiles (ExogenesisInstaller* self);
gboolean exogenesis_installer_ValidInstallData (ExogenesisInstaller* self);
gboolean exogenesis_installer_Install (ExogenesisInstaller* self);
gboolean exogenesis_installer_CreateUsers (ExogenesisInstaller* self);
gboolean exogenesis_installer_CreateGroups (ExogenesisInstaller* self);
gboolean exogenesis_installer_SaveConfigs (ExogenesisInstaller* self);
gboolean exogenesis_installer_ApplyConfigs (ExogenesisInstaller* self);
gboolean exogenesis_installer_CreateOS (ExogenesisInstaller* self);
static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void exogenesis_installer_finalize (ExogenesisInstaller* obj);
#define EXOGENESIS_INSTALL_HARD_DISK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskPrivate))
enum  {
	EXOGENESIS_INSTALL_HARD_DISK_DUMMY_PROPERTY,
	EXOGENESIS_INSTALL_HARD_DISK_DEVICE_NAME,
	EXOGENESIS_INSTALL_HARD_DISK_MODEL,
	EXOGENESIS_INSTALL_HARD_DISK_SERIAL_NUMBER,
	EXOGENESIS_INSTALL_HARD_DISK_IS_GRUB_TARGET,
	EXOGENESIS_INSTALL_HARD_DISK_DRIVE_SIZE,
	EXOGENESIS_INSTALL_HARD_DISK_PARTITION_COUNT,
	EXOGENESIS_INSTALL_HARD_DISK_ELEMENT_TYPE
};
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_new (void);
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_construct (GType object_type);
guint64 exogenesis_install_hard_disk_AvailableSize (ExogenesisInstallHardDisk* self);
guint64 exogenesis_install_hard_disk_get_DriveSize (ExogenesisInstallHardDisk* self);
const gchar* exogenesis_install_hard_disk_get_DeviceName (ExogenesisInstallHardDisk* self);
const gchar* exogenesis_install_partition_get_Type (ExogenesisInstallPartition* self);
guint64 exogenesis_install_partition_get_ByteSize (ExogenesisInstallPartition* self);
gint exogenesis_install_hard_disk_IndexOf (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* ip);
void exogenesis_install_hard_disk_AddPartition (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* partition);
static GeeIterator* exogenesis_install_hard_disk_real_iterator (GeeIterable* base);
void exogenesis_install_hard_disk_SortPartitions (ExogenesisInstallHardDisk* self);
void exogenesis_install_partition_SortPartitions (ExogenesisInstallPartition* self);
void exogenesis_install_hard_disk_set_DeviceName (ExogenesisInstallHardDisk* self, const gchar* value);
const gchar* exogenesis_install_hard_disk_get_Model (ExogenesisInstallHardDisk* self);
void exogenesis_install_hard_disk_set_Model (ExogenesisInstallHardDisk* self, const gchar* value);
const gchar* exogenesis_install_hard_disk_get_SerialNumber (ExogenesisInstallHardDisk* self);
void exogenesis_install_hard_disk_set_SerialNumber (ExogenesisInstallHardDisk* self, const gchar* value);
gboolean exogenesis_install_hard_disk_get_IsGrubTarget (ExogenesisInstallHardDisk* self);
void exogenesis_install_hard_disk_set_IsGrubTarget (ExogenesisInstallHardDisk* self, gboolean value);
void exogenesis_install_hard_disk_set_DriveSize (ExogenesisInstallHardDisk* self, guint64 value);
static void exogenesis_install_hard_disk_finalize (GObject* obj);
static void _vala_exogenesis_install_hard_disk_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_install_hard_disk_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define EXOGENESIS_INSTALL_PARTITION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionPrivate))
enum  {
	EXOGENESIS_INSTALL_PARTITION_DUMMY_PROPERTY,
	EXOGENESIS_INSTALL_PARTITION_BYTE_SIZE,
	EXOGENESIS_INSTALL_PARTITION_DISPLAY_SIZE,
	EXOGENESIS_INSTALL_PARTITION_FORMAT,
	EXOGENESIS_INSTALL_PARTITION_USE,
	EXOGENESIS_INSTALL_PARTITION_NEW_PARTITION,
	EXOGENESIS_INSTALL_PARTITION_MOUNT_POINT,
	EXOGENESIS_INSTALL_PARTITION_TYPE,
	EXOGENESIS_INSTALL_PARTITION_TYPE_ID,
	EXOGENESIS_INSTALL_PARTITION_LABEL,
	EXOGENESIS_INSTALL_PARTITION_START,
	EXOGENESIS_INSTALL_PARTITION_END,
	EXOGENESIS_INSTALL_PARTITION_DEVICE,
	EXOGENESIS_INSTALL_PARTITION_ID,
	EXOGENESIS_INSTALL_PARTITION_ELEMENT_TYPE
};
ExogenesisInstallPartition* exogenesis_install_partition_new (void);
ExogenesisInstallPartition* exogenesis_install_partition_construct (GType object_type);
void exogenesis_install_partition_AddInstallPartition (ExogenesisInstallPartition* self, ExogenesisInstallPartition* ip);
static gint exogenesis_install_partition_real_compare_to (GeeComparable* base, ExogenesisInstallPartition* comp);
guint64 exogenesis_install_partition_get_Start (ExogenesisInstallPartition* self);
static GeeIterator* exogenesis_install_partition_real_iterator (GeeIterable* base);
void exogenesis_install_partition_set_ByteSize (ExogenesisInstallPartition* self, guint64 value);
const gchar* exogenesis_install_partition_get_DisplaySize (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_DisplaySize (ExogenesisInstallPartition* self, const gchar* value);
gboolean exogenesis_install_partition_get_Format (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_Format (ExogenesisInstallPartition* self, gboolean value);
gboolean exogenesis_install_partition_get_Use (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_Use (ExogenesisInstallPartition* self, gboolean value);
gboolean exogenesis_install_partition_get_NewPartition (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_NewPartition (ExogenesisInstallPartition* self, gboolean value);
const gchar* exogenesis_install_partition_get_MountPoint (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_MountPoint (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Type (ExogenesisInstallPartition* self, const gchar* value);
const gchar* exogenesis_install_partition_get_TypeID (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_TypeID (ExogenesisInstallPartition* self, const gchar* value);
const gchar* exogenesis_install_partition_get_Label (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_Label (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Start (ExogenesisInstallPartition* self, guint64 value);
guint64 exogenesis_install_partition_get_End (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_End (ExogenesisInstallPartition* self, guint64 value);
const gchar* exogenesis_install_partition_get_Device (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_Device (ExogenesisInstallPartition* self, const gchar* value);
const gchar* exogenesis_install_partition_get_ID (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_ID (ExogenesisInstallPartition* self, const gchar* value);
static void exogenesis_install_partition_finalize (GObject* obj);
static void _vala_exogenesis_install_partition_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_install_partition_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	EXOGENESIS_INSTALL_USERS_DUMMY_PROPERTY,
	EXOGENESIS_INSTALL_USERS_COUNT,
	EXOGENESIS_INSTALL_USERS_ELEMENT_TYPE
};
void exogenesis_install_users_Sort (ExogenesisInstallUsers* self);
static GeeIterator* exogenesis_install_users_real_iterator (GeeIterable* base);
gint exogenesis_install_users_get_Count (ExogenesisInstallUsers* self);
static void exogenesis_install_users_finalize (GObject* obj);
static void _vala_exogenesis_install_users_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define EXOGENESIS_USER_DETAIL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_USER_DETAIL, ExogenesisUserDetailPrivate))
enum  {
	EXOGENESIS_USER_DETAIL_DUMMY_PROPERTY,
	EXOGENESIS_USER_DETAIL_USER_ID,
	EXOGENESIS_USER_DETAIL_GROUP_ID,
	EXOGENESIS_USER_DETAIL_USERNAME,
	EXOGENESIS_USER_DETAIL_FULLNAME,
	EXOGENESIS_USER_DETAIL_OFFICE_LOCATION,
	EXOGENESIS_USER_DETAIL_WORK_PHONE,
	EXOGENESIS_USER_DETAIL_HOME_PHONE,
	EXOGENESIS_USER_DETAIL_HOME_FOLDER,
	EXOGENESIS_USER_DETAIL_SHELL,
	EXOGENESIS_USER_DETAIL_TYPE,
	EXOGENESIS_USER_DETAIL_PASSWORD,
	EXOGENESIS_USER_DETAIL_ENCRYPT_HOME,
	EXOGENESIS_USER_DETAIL_AUTO_LOGON,
	EXOGENESIS_USER_DETAIL_REQUIRE_PASSWORD,
	EXOGENESIS_USER_DETAIL_MAIN_ACCOUNT
};
static gint exogenesis_user_detail_real_compare_to (GeeComparable* base, ExogenesisUserDetail* comp);
gint exogenesis_user_detail_get_UserId (ExogenesisUserDetail* self);
ExogenesisUserDetail* exogenesis_user_detail_new (void);
ExogenesisUserDetail* exogenesis_user_detail_construct (GType object_type);
void exogenesis_user_detail_set_UserId (ExogenesisUserDetail* self, gint value);
gint exogenesis_user_detail_get_GroupId (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_GroupId (ExogenesisUserDetail* self, gint value);
const gchar* exogenesis_user_detail_get_Username (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_Username (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_Fullname (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_Fullname (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_OfficeLocation (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_OfficeLocation (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_WorkPhone (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_WorkPhone (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_HomePhone (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_HomePhone (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_HomeFolder (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_HomeFolder (ExogenesisUserDetail* self, const gchar* value);
const gchar* exogenesis_user_detail_get_Shell (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_Shell (ExogenesisUserDetail* self, const gchar* value);
gchar exogenesis_user_detail_get_Type (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_Type (ExogenesisUserDetail* self, gchar value);
const gchar* exogenesis_user_detail_get_Password (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_Password (ExogenesisUserDetail* self, const gchar* value);
gboolean exogenesis_user_detail_get_EncryptHome (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_EncryptHome (ExogenesisUserDetail* self, gboolean value);
gboolean exogenesis_user_detail_get_AutoLogon (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_AutoLogon (ExogenesisUserDetail* self, gboolean value);
gboolean exogenesis_user_detail_get_RequirePassword (ExogenesisUserDetail* self);
void exogenesis_user_detail_set_RequirePassword (ExogenesisUserDetail* self, gboolean value);
void exogenesis_user_detail_set_MainAccount (ExogenesisUserDetail* self, gboolean value);
static void exogenesis_user_detail_finalize (GObject* obj);
static void _vala_exogenesis_user_detail_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_user_detail_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	EXOGENESIS_INSTALL_GROUPS_DUMMY_PROPERTY,
	EXOGENESIS_INSTALL_GROUPS_ELEMENT_TYPE
};
void exogenesis_install_groups_Sort (ExogenesisInstallGroups* self);
static GeeIterator* exogenesis_install_groups_real_iterator (GeeIterable* base);
static void exogenesis_install_groups_finalize (GObject* obj);
static void _vala_exogenesis_install_groups_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define EXOGENESIS_GROUP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_GROUP, ExogenesisGroupPrivate))
enum  {
	EXOGENESIS_GROUP_DUMMY_PROPERTY,
	EXOGENESIS_GROUP_ID,
	EXOGENESIS_GROUP_NAME,
	EXOGENESIS_GROUP_TYPE
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
void exogenesis_group_AddUser (ExogenesisGroup* self, ExogenesisUserDetail* user);
static gint exogenesis_group_real_compare_to (GeeComparable* base, ExogenesisGroup* comp);
const gchar* exogenesis_group_get_Name (ExogenesisGroup* self);
ExogenesisGroup* exogenesis_group_new (void);
ExogenesisGroup* exogenesis_group_construct (GType object_type);
gint exogenesis_group_get_Id (ExogenesisGroup* self);
void exogenesis_group_set_Id (ExogenesisGroup* self, gint value);
void exogenesis_group_set_Name (ExogenesisGroup* self, const gchar* value);
gchar exogenesis_group_get_Type (ExogenesisGroup* self);
void exogenesis_group_set_Type (ExogenesisGroup* self, gchar value);
static void exogenesis_group_finalize (GObject* obj);
static void _vala_exogenesis_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_group_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


void exogenesis_install_data_AddUser (ExogenesisInstallData* self, ExogenesisUserDetail* user) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (user != NULL);
	exogenesis_install_users_AddUser (self->priv->_UserData, user);
}


ExogenesisUserDetail* exogenesis_install_data_GetMainUser (ExogenesisInstallData* self) {
	ExogenesisUserDetail* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _ud_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) self->priv->_UserData);
		_ud_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			ExogenesisUserDetail* ud;
			gboolean _tmp3_;
			_tmp1_ = gee_iterator_next (_ud_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_ud_it);
			ud = (ExogenesisUserDetail*) _tmp2_;
			_tmp3_ = exogenesis_user_detail_get_MainAccount (ud);
			if (_tmp3_) {
				result = ud;
				_g_object_unref0 (_ud_it);
				return result;
			}
			_g_object_unref0 (ud);
		}
		_g_object_unref0 (_ud_it);
	}
	result = NULL;
	return result;
}


void exogenesis_install_data_AddGroup (ExogenesisInstallData* self, ExogenesisGroup* group) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (group != NULL);
	exogenesis_install_groups_AddGroup (self->priv->_groups, group);
}


void exogenesis_install_data_AddInstallDisk (ExogenesisInstallData* self, ExogenesisInstallHardDisk* hd) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_installTargets, hd);
}


void exogenesis_install_data_ClearInstallDisks (ExogenesisInstallData* self) {
	g_return_if_fail (self != NULL);
	gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->_installTargets);
}


ExogenesisInstallHardDisk* exogenesis_install_data_GetTargetHD (ExogenesisInstallData* self, gint index) {
	ExogenesisInstallHardDisk* result = NULL;
	gpointer _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_installTargets, index);
	result = (ExogenesisInstallHardDisk*) _tmp0_;
	return result;
}


static GeeIterator* exogenesis_install_data_real_iterator (GeeIterable* base) {
	ExogenesisInstallData * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisInstallData*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_installTargets);
	result = _tmp0_;
	return result;
}


ExogenesisInstallData* exogenesis_install_data_construct (GType object_type) {
	ExogenesisInstallData * self = NULL;
	self = (ExogenesisInstallData*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisInstallData* exogenesis_install_data_new (void) {
	return exogenesis_install_data_construct (EXOGENESIS_TYPE_INSTALL_DATA);
}


const gchar* exogenesis_install_data_get_TimeZone (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_TimeZone;
	return result;
}


void exogenesis_install_data_set_TimeZone (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_TimeZone);
	self->priv->_TimeZone = _tmp0_;
	g_object_notify ((GObject *) self, "TimeZone");
}


const gchar* exogenesis_install_data_get_Language (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Language;
	return result;
}


void exogenesis_install_data_set_Language (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Language);
	self->priv->_Language = _tmp0_;
	g_object_notify ((GObject *) self, "Language");
}


const gchar* exogenesis_install_data_get_KeyboardLayout (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_KeyboardLayout;
	return result;
}


void exogenesis_install_data_set_KeyboardLayout (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_KeyboardLayout);
	self->priv->_KeyboardLayout = _tmp0_;
	g_object_notify ((GObject *) self, "KeyboardLayout");
}


const gchar* exogenesis_install_data_get_KeyboardVariant (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_KeyboardVariant;
	return result;
}


void exogenesis_install_data_set_KeyboardVariant (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_KeyboardVariant);
	self->priv->_KeyboardVariant = _tmp0_;
	g_object_notify ((GObject *) self, "KeyboardVariant");
}


const gchar* exogenesis_install_data_get_SelectedTimeZone (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_SelectedTimeZone;
	return result;
}


void exogenesis_install_data_set_SelectedTimeZone (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_SelectedTimeZone);
	self->priv->_SelectedTimeZone = _tmp0_;
	g_object_notify ((GObject *) self, "SelectedTimeZone");
}


gboolean exogenesis_install_data_get_ManualTime (ExogenesisInstallData* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_ManualTime;
	return result;
}


void exogenesis_install_data_set_ManualTime (ExogenesisInstallData* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_ManualTime = value;
	g_object_notify ((GObject *) self, "ManualTime");
}


const gchar* exogenesis_install_data_get_GrubTarget (ExogenesisInstallData* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_GrubTarget;
	return result;
}


void exogenesis_install_data_set_GrubTarget (ExogenesisInstallData* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_GrubTarget);
	self->priv->_GrubTarget = _tmp0_;
	g_object_notify ((GObject *) self, "GrubTarget");
}


gint exogenesis_install_data_get_HardDiskCount (ExogenesisInstallData* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->_installTargets);
	result = _tmp0_;
	return result;
}


static GType exogenesis_install_data_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisInstallData* self;
	self = (ExogenesisInstallData*) base;
	result = EXOGENESIS_TYPE_INSTALL_HARD_DISK;
	return result;
}


static void exogenesis_install_data_class_init (ExogenesisInstallDataClass * klass) {
	exogenesis_install_data_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisInstallDataPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_install_data_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_install_data_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_install_data_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_TIME_ZONE, g_param_spec_string ("TimeZone", "TimeZone", "TimeZone", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_LANGUAGE, g_param_spec_string ("Language", "Language", "Language", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_KEYBOARD_LAYOUT, g_param_spec_string ("KeyboardLayout", "KeyboardLayout", "KeyboardLayout", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_KEYBOARD_VARIANT, g_param_spec_string ("KeyboardVariant", "KeyboardVariant", "KeyboardVariant", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_SELECTED_TIME_ZONE, g_param_spec_string ("SelectedTimeZone", "SelectedTimeZone", "SelectedTimeZone", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_MANUAL_TIME, g_param_spec_boolean ("ManualTime", "ManualTime", "ManualTime", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_GRUB_TARGET, g_param_spec_string ("GrubTarget", "GrubTarget", "GrubTarget", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_HARD_DISK_COUNT, g_param_spec_int ("HardDiskCount", "HardDiskCount", "HardDiskCount", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_DATA_ELEMENT_TYPE, "element-type");
}


static void exogenesis_install_data_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_install_data_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_install_data_real_iterator;
	iface->get_element_type = exogenesis_install_data_real_get_element_type;
}


static void exogenesis_install_data_instance_init (ExogenesisInstallData * self) {
	GeeArrayList* _tmp0_ = NULL;
	ExogenesisInstallUsers* _tmp1_ = NULL;
	ExogenesisInstallGroups* _tmp2_ = NULL;
	self->priv = EXOGENESIS_INSTALL_DATA_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_INSTALL_HARD_DISK, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_installTargets = _tmp0_;
	_tmp1_ = exogenesis_install_users_new ();
	self->priv->_UserData = _tmp1_;
	_tmp2_ = exogenesis_install_groups_new ();
	self->priv->_groups = _tmp2_;
	self->priv->_ManualTime = FALSE;
}


static void exogenesis_install_data_finalize (GObject* obj) {
	ExogenesisInstallData * self;
	self = EXOGENESIS_INSTALL_DATA (obj);
	_g_object_unref0 (self->priv->_installTargets);
	_g_object_unref0 (self->priv->_UserData);
	_g_object_unref0 (self->priv->_groups);
	_g_free0 (self->priv->_TimeZone);
	_g_free0 (self->priv->_Language);
	_g_free0 (self->priv->_KeyboardLayout);
	_g_free0 (self->priv->_KeyboardVariant);
	_g_free0 (self->priv->_SelectedTimeZone);
	_g_free0 (self->priv->_GrubTarget);
	G_OBJECT_CLASS (exogenesis_install_data_parent_class)->finalize (obj);
}


GType exogenesis_install_data_get_type (void) {
	static volatile gsize exogenesis_install_data_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_install_data_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_install_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstallData), 0, (GInstanceInitFunc) exogenesis_install_data_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_install_data_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_install_data_type_id;
		exogenesis_install_data_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisInstallData", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_install_data_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_install_data_type_id__volatile, exogenesis_install_data_type_id);
	}
	return exogenesis_install_data_type_id__volatile;
}


static void _vala_exogenesis_install_data_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisInstallData * self;
	self = EXOGENESIS_INSTALL_DATA (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_DATA_TIME_ZONE:
		g_value_set_string (value, exogenesis_install_data_get_TimeZone (self));
		break;
		case EXOGENESIS_INSTALL_DATA_LANGUAGE:
		g_value_set_string (value, exogenesis_install_data_get_Language (self));
		break;
		case EXOGENESIS_INSTALL_DATA_KEYBOARD_LAYOUT:
		g_value_set_string (value, exogenesis_install_data_get_KeyboardLayout (self));
		break;
		case EXOGENESIS_INSTALL_DATA_KEYBOARD_VARIANT:
		g_value_set_string (value, exogenesis_install_data_get_KeyboardVariant (self));
		break;
		case EXOGENESIS_INSTALL_DATA_SELECTED_TIME_ZONE:
		g_value_set_string (value, exogenesis_install_data_get_SelectedTimeZone (self));
		break;
		case EXOGENESIS_INSTALL_DATA_MANUAL_TIME:
		g_value_set_boolean (value, exogenesis_install_data_get_ManualTime (self));
		break;
		case EXOGENESIS_INSTALL_DATA_GRUB_TARGET:
		g_value_set_string (value, exogenesis_install_data_get_GrubTarget (self));
		break;
		case EXOGENESIS_INSTALL_DATA_HARD_DISK_COUNT:
		g_value_set_int (value, exogenesis_install_data_get_HardDiskCount (self));
		break;
		case EXOGENESIS_INSTALL_DATA_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_install_data_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisInstallData * self;
	self = EXOGENESIS_INSTALL_DATA (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_DATA_TIME_ZONE:
		exogenesis_install_data_set_TimeZone (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_DATA_LANGUAGE:
		exogenesis_install_data_set_Language (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_DATA_KEYBOARD_LAYOUT:
		exogenesis_install_data_set_KeyboardLayout (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_DATA_KEYBOARD_VARIANT:
		exogenesis_install_data_set_KeyboardVariant (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_DATA_SELECTED_TIME_ZONE:
		exogenesis_install_data_set_SelectedTimeZone (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_DATA_MANUAL_TIME:
		exogenesis_install_data_set_ManualTime (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_INSTALL_DATA_GRUB_TARGET:
		exogenesis_install_data_set_GrubTarget (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _exogenesis_installer_DeviceAction_exogenesis_hd_manager_device_action_complete (ExogenesisHDManager* _sender, const gchar* action, gint currentPindex, gint currentEindex, ExogenesisInstallHardDisk* ihd, gpointer self) {
	exogenesis_installer_DeviceAction (self, action, currentPindex, currentEindex, ihd);
}


static void _exogenesis_installer_OnDiskManagerError_exogenesis_hd_manager_disk_manager_error (ExogenesisHDManager* _sender, GError* err, gpointer self) {
	exogenesis_installer_OnDiskManagerError (self, err);
}


ExogenesisInstaller* exogenesis_installer_construct (GType object_type) {
	ExogenesisInstaller* self = NULL;
	self = (ExogenesisInstaller*) g_type_create_instance (object_type);
	g_signal_connect (exogenesis_gHDManager, "device-action-complete", (GCallback) _exogenesis_installer_DeviceAction_exogenesis_hd_manager_device_action_complete, self);
	g_signal_connect (exogenesis_gHDManager, "disk-manager-error", (GCallback) _exogenesis_installer_OnDiskManagerError_exogenesis_hd_manager_disk_manager_error, self);
	return self;
}


ExogenesisInstaller* exogenesis_installer_new (void) {
	return exogenesis_installer_construct (EXOGENESIS_TYPE_INSTALLER);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void exogenesis_installer_CreatePartitionsStart (ExogenesisInstaller* self, ExogenesisInstallHardDisk* iHD) {
	ExogenesisInstallHardDisk* _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iHD != NULL);
	_tmp0_ = _g_object_ref0 (iHD);
	_g_object_unref0 (self->priv->_currentiHD);
	self->priv->_currentiHD = _tmp0_;
	exogenesis_gHDManager->PartitionerRunning = TRUE;
	_tmp1_ = exogenesis_install_hard_disk_get_PartitionCount (iHD);
	if (_tmp1_ > 0) {
		gint _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		ExogenesisInstallPartition* _tmp7_ = NULL;
		ExogenesisInstallPartition* _tmp8_;
		_tmp2_ = exogenesis_install_hard_disk_get_PartitionCount (iHD);
		_tmp3_ = g_strdup_printf ("%i", _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strdup_printf ("Partitions to create = %s\n", _tmp4_);
		_tmp6_ = _tmp5_;
		exogenesis_general_functions_LogIt (_tmp6_);
		_g_free0 (_tmp6_);
		_g_free0 (_tmp4_);
		_tmp7_ = exogenesis_install_hard_disk_GetPartition (iHD, 0);
		_tmp8_ = _tmp7_;
		exogenesis_hd_manager_CreatePartitionA (exogenesis_gHDManager, _tmp8_, 0, -1, iHD, TRUE);
		_g_object_unref0 (_tmp8_);
	}
}


static void exogenesis_installer_DeviceAction (ExogenesisInstaller* self, const gchar* action, gint curpindex, gint cureindex, ExogenesisInstallHardDisk* ihd) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GQuark _tmp6_;
	static GQuark _tmp6__label0 = 0;
	static GQuark _tmp6__label1 = 0;
	static GQuark _tmp6__label2 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (ihd != NULL);
	_tmp0_ = g_strdup_printf ("%i", curpindex);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup_printf ("DEVICE ACTION CALLBACK EVENT - ACTION = %s  Index = %s\n", action, _tmp1_);
	_tmp3_ = _tmp2_;
	exogenesis_general_functions_LogIt (_tmp3_);
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	_tmp4_ = g_utf8_strdown (action, (gssize) (-1));
	_tmp5_ = _tmp4_;
	_tmp6_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
	g_free (_tmp5_);
	if (_tmp6_ == ((0 != _tmp6__label0) ? _tmp6__label0 : (_tmp6__label0 = g_quark_from_static_string ("unmount")))) {
		switch (0) {
			default:
			{
				ExogenesisInstallPartition* _tmp7_ = NULL;
				ExogenesisInstallPartition* _tmp8_;
				exogenesis_general_functions_LogIt ("Partition UNMOUNTED, Proceed to NEXT STEP\n");
				_tmp7_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
				_tmp8_ = _tmp7_;
				exogenesis_hd_manager_CreatePartitionA (exogenesis_gHDManager, _tmp8_, curpindex, cureindex, ihd, TRUE);
				_g_object_unref0 (_tmp8_);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label1) ? _tmp6__label1 : (_tmp6__label1 = g_quark_from_static_string ("delete")))) {
		switch (0) {
			default:
			{
				ExogenesisInstallPartition* _tmp9_ = NULL;
				ExogenesisInstallPartition* _tmp10_;
				exogenesis_general_functions_LogIt ("Partition DELETED, Proceed to NEXT STEP\n");
				_tmp9_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
				_tmp10_ = _tmp9_;
				exogenesis_hd_manager_CreatePartitionA (exogenesis_gHDManager, _tmp10_, curpindex, cureindex, ihd, TRUE);
				_g_object_unref0 (_tmp10_);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label2) ? _tmp6__label2 : (_tmp6__label2 = g_quark_from_static_string ("create")))) {
		switch (0) {
			default:
			{
				gboolean _tmp11_ = FALSE;
				ExogenesisInstallPartition* _tmp12_ = NULL;
				ExogenesisInstallPartition* _tmp13_;
				gint _tmp14_;
				gboolean _tmp15_;
				exogenesis_general_functions_LogIt ("Partition CREATED, Proceed to NEXT\n");
				_tmp12_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
				_tmp13_ = _tmp12_;
				_tmp14_ = exogenesis_install_partition_ExtPartitionCount (_tmp13_);
				_tmp15_ = _tmp14_ > 0;
				_g_object_unref0 (_tmp13_);
				if (_tmp15_) {
					ExogenesisInstallPartition* _tmp16_ = NULL;
					ExogenesisInstallPartition* _tmp17_;
					gint _tmp18_;
					_tmp16_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
					_tmp17_ = _tmp16_;
					_tmp18_ = exogenesis_install_partition_ExtPartitionCount (_tmp17_);
					_tmp11_ = (cureindex + 1) < _tmp18_;
					_g_object_unref0 (_tmp17_);
				} else {
					_tmp11_ = FALSE;
				}
				if (_tmp11_) {
					ExogenesisInstallPartition* _tmp19_ = NULL;
					ExogenesisInstallPartition* _tmp20_;
					ExogenesisInstallPartition* _tmp21_ = NULL;
					ExogenesisInstallPartition* _tmp22_;
					cureindex = cureindex + 1;
					_tmp19_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
					_tmp20_ = _tmp19_;
					_tmp21_ = exogenesis_install_partition_GetPartition (_tmp20_, cureindex);
					_tmp22_ = _tmp21_;
					exogenesis_hd_manager_CreatePartitionA (exogenesis_gHDManager, _tmp22_, curpindex, cureindex, ihd, FALSE);
					_g_object_unref0 (_tmp22_);
					_g_object_unref0 (_tmp20_);
				} else {
					gint _tmp23_;
					curpindex = curpindex + 1;
					_tmp23_ = exogenesis_install_hard_disk_get_PartitionCount (ihd);
					if (curpindex < _tmp23_) {
						gint _tmp24_;
						gchar* _tmp25_ = NULL;
						gchar* _tmp26_;
						gchar* _tmp27_ = NULL;
						gchar* _tmp28_;
						ExogenesisInstallPartition* _tmp29_ = NULL;
						ExogenesisInstallPartition* _tmp30_;
						_tmp24_ = exogenesis_install_hard_disk_get_PartitionCount (ihd);
						_tmp25_ = g_strdup_printf ("%i", _tmp24_);
						_tmp26_ = _tmp25_;
						_tmp27_ = g_strdup_printf ("Partitions = %s\n", _tmp26_);
						_tmp28_ = _tmp27_;
						exogenesis_general_functions_LogIt (_tmp28_);
						_g_free0 (_tmp28_);
						_g_free0 (_tmp26_);
						_tmp29_ = exogenesis_install_hard_disk_GetPartition (ihd, curpindex);
						_tmp30_ = _tmp29_;
						exogenesis_hd_manager_CreatePartitionA (exogenesis_gHDManager, _tmp30_, curpindex, cureindex, ihd, TRUE);
						_g_object_unref0 (_tmp30_);
					} else {
						exogenesis_general_functions_LogIt ("ALL PARTITIONS CREATED\n");
						exogenesis_gHDManager->PartitionerRunning = FALSE;
					}
				}
				break;
			}
		}
	}
}


static gboolean exogenesis_installer_CopyFiles (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_ValidInstallData (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_Install (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	exogenesis_installer_CreatePartitionsStart (self, NULL);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_CreateUsers (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_CreateGroups (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_SaveConfigs (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_ApplyConfigs (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean exogenesis_installer_CreateOS (ExogenesisInstaller* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


static void exogenesis_installer_OnDiskManagerError (ExogenesisInstaller* self, GError* err) {
	gchar* _tmp0_ = NULL;
	gchar* Error;
	g_return_if_fail (self != NULL);
	self->priv->_PartitionError = TRUE;
	_tmp0_ = g_strdup_printf ("Partitioner Error Occurred \n%s", err->message);
	Error = _tmp0_;
	g_signal_emit_by_name (self, "installer-error", Error);
	_g_free0 (Error);
}


static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_STRING) (gpointer data1, gint arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void exogenesis_value_installer_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_installer_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_installer_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_installer_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_installer_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_installer_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_installer_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisInstaller* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_installer_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_installer_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisInstaller** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_installer_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_installer (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecInstaller* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_INSTALLER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_installer (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_INSTALLER), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_installer (GValue* value, gpointer v_object) {
	ExogenesisInstaller* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_INSTALLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_INSTALLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_installer_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_installer_unref (old);
	}
}


void exogenesis_value_take_installer (GValue* value, gpointer v_object) {
	ExogenesisInstaller* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_INSTALLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_INSTALLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_installer_unref (old);
	}
}


static void exogenesis_installer_class_init (ExogenesisInstallerClass * klass) {
	exogenesis_installer_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_INSTALLER_CLASS (klass)->finalize = exogenesis_installer_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisInstallerPrivate));
	g_signal_new ("install_started", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("user_created", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EXOGENESIS_TYPE_USER_DETAIL);
	g_signal_new ("group_created", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EXOGENESIS_TYPE_GROUP);
	g_signal_new ("language_set", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("timezone_set", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("partitions_created", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("file_copied", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("next_slide", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("progress_update", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_STRING, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_STRING);
	g_signal_new ("installer_error", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("install_complete", EXOGENESIS_TYPE_INSTALLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void exogenesis_installer_instance_init (ExogenesisInstaller * self) {
	gchar* _tmp0_;
	self->priv = EXOGENESIS_INSTALLER_GET_PRIVATE (self);
	self->priv->_PartitionError = FALSE;
	_tmp0_ = g_strdup ("/media/target");
	self->priv->mountpoint = _tmp0_;
	self->ref_count = 1;
}


static void exogenesis_installer_finalize (ExogenesisInstaller* obj) {
	ExogenesisInstaller * self;
	self = EXOGENESIS_INSTALLER (obj);
	_g_object_unref0 (self->priv->_currentiHD);
	_g_free0 (self->priv->mountpoint);
}


GType exogenesis_installer_get_type (void) {
	static volatile gsize exogenesis_installer_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_installer_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_installer_init, exogenesis_value_installer_free_value, exogenesis_value_installer_copy_value, exogenesis_value_installer_peek_pointer, "p", exogenesis_value_installer_collect_value, "p", exogenesis_value_installer_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_installer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstaller), 0, (GInstanceInitFunc) exogenesis_installer_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_installer_type_id;
		exogenesis_installer_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisInstaller", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_installer_type_id__volatile, exogenesis_installer_type_id);
	}
	return exogenesis_installer_type_id__volatile;
}


gpointer exogenesis_installer_ref (gpointer instance) {
	ExogenesisInstaller* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_installer_unref (gpointer instance) {
	ExogenesisInstaller* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_INSTALLER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisInstallHardDisk* exogenesis_install_hard_disk_construct (GType object_type) {
	ExogenesisInstallHardDisk * self = NULL;
	self = (ExogenesisInstallHardDisk*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisInstallHardDisk* exogenesis_install_hard_disk_new (void) {
	return exogenesis_install_hard_disk_construct (EXOGENESIS_TYPE_INSTALL_HARD_DISK);
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


guint64 exogenesis_install_hard_disk_AvailableSize (ExogenesisInstallHardDisk* self) {
	guint64 result = 0ULL;
	guint64 size;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, 0ULL);
	size = self->priv->_DriveSize;
	_tmp0_ = g_strdup_printf ("%" G_GUINT64_FORMAT, size);
	_tmp1_ = _tmp0_;
	fprintf (stdout, "Drive %s total size = %s\n", self->priv->_DeviceName, _tmp1_);
	_g_free0 (_tmp1_);
	{
		GeeArrayList* _tmp2_;
		GeeArrayList* _p_list;
		gint _tmp3_;
		gint _p_size;
		gint _p_index;
		_tmp2_ = _g_object_ref0 (self->priv->_partitions);
		_p_list = _tmp2_;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _p_list);
		_p_size = _tmp3_;
		_p_index = -1;
		while (TRUE) {
			gpointer _tmp4_ = NULL;
			ExogenesisInstallPartition* p;
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_ = NULL;
			gchar* _tmp7_;
			gboolean _tmp8_;
			gboolean _tmp9_;
			_p_index = _p_index + 1;
			if (!(_p_index < _p_size)) {
				break;
			}
			_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) _p_list, _p_index);
			p = (ExogenesisInstallPartition*) _tmp4_;
			_tmp5_ = exogenesis_install_partition_get_Type (p);
			_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) (-1));
			_tmp7_ = _tmp6_;
			_tmp8_ = string_contains (_tmp7_, "extended");
			_tmp9_ = _tmp8_;
			_g_free0 (_tmp7_);
			if (_tmp9_) {
				{
					GeeIterator* _tmp10_ = NULL;
					GeeIterator* _i_it;
					_tmp10_ = gee_iterable_iterator ((GeeIterable*) p);
					_i_it = _tmp10_;
					while (TRUE) {
						gboolean _tmp11_;
						gpointer _tmp12_ = NULL;
						ExogenesisInstallPartition* i;
						guint64 _tmp13_;
						_tmp11_ = gee_iterator_next (_i_it);
						if (!_tmp11_) {
							break;
						}
						_tmp12_ = gee_iterator_get (_i_it);
						i = (ExogenesisInstallPartition*) _tmp12_;
						_tmp13_ = exogenesis_install_partition_get_ByteSize (i);
						size = size - _tmp13_;
						_g_object_unref0 (i);
					}
					_g_object_unref0 (_i_it);
				}
			} else {
				guint64 _tmp14_;
				_tmp14_ = exogenesis_install_partition_get_ByteSize (p);
				size = size - _tmp14_;
			}
			_g_object_unref0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	result = size;
	return result;
}


gint exogenesis_install_hard_disk_IndexOf (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* ip) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (ip != NULL, 0);
	_tmp0_ = gee_abstract_list_index_of ((GeeAbstractList*) self->priv->_partitions, ip);
	result = _tmp0_;
	return result;
}


ExogenesisInstallPartition* exogenesis_install_hard_disk_GetPartition (ExogenesisInstallHardDisk* self, gint index) {
	ExogenesisInstallPartition* result = NULL;
	gpointer _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_partitions, index);
	result = (ExogenesisInstallPartition*) _tmp0_;
	return result;
}


void exogenesis_install_hard_disk_AddPartition (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* partition) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (partition != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_partitions, partition);
}


static GeeIterator* exogenesis_install_hard_disk_real_iterator (GeeIterable* base) {
	ExogenesisInstallHardDisk * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisInstallHardDisk*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_partitions);
	result = _tmp0_;
	return result;
}


void exogenesis_install_hard_disk_SortPartitions (ExogenesisInstallHardDisk* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->priv->_partitions, NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _p_list;
		gint _tmp1_;
		gint _p_size;
		gint _p_index;
		_tmp0_ = _g_object_ref0 (self->priv->_partitions);
		_p_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _p_list);
		_p_size = _tmp1_;
		_p_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisInstallPartition* p;
			_p_index = _p_index + 1;
			if (!(_p_index < _p_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _p_list, _p_index);
			p = (ExogenesisInstallPartition*) _tmp2_;
			exogenesis_install_partition_SortPartitions (p);
			_g_object_unref0 (p);
		}
		_g_object_unref0 (_p_list);
	}
}


const gchar* exogenesis_install_hard_disk_get_DeviceName (ExogenesisInstallHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_DeviceName;
	return result;
}


void exogenesis_install_hard_disk_set_DeviceName (ExogenesisInstallHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_DeviceName);
	self->priv->_DeviceName = _tmp0_;
	g_object_notify ((GObject *) self, "DeviceName");
}


const gchar* exogenesis_install_hard_disk_get_Model (ExogenesisInstallHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Model;
	return result;
}


void exogenesis_install_hard_disk_set_Model (ExogenesisInstallHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Model);
	self->priv->_Model = _tmp0_;
	g_object_notify ((GObject *) self, "Model");
}


const gchar* exogenesis_install_hard_disk_get_SerialNumber (ExogenesisInstallHardDisk* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_SerialNumber;
	return result;
}


void exogenesis_install_hard_disk_set_SerialNumber (ExogenesisInstallHardDisk* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_SerialNumber);
	self->priv->_SerialNumber = _tmp0_;
	g_object_notify ((GObject *) self, "SerialNumber");
}


gboolean exogenesis_install_hard_disk_get_IsGrubTarget (ExogenesisInstallHardDisk* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_IsGrubTarget;
	return result;
}


void exogenesis_install_hard_disk_set_IsGrubTarget (ExogenesisInstallHardDisk* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_IsGrubTarget = value;
	g_object_notify ((GObject *) self, "IsGrubTarget");
}


guint64 exogenesis_install_hard_disk_get_DriveSize (ExogenesisInstallHardDisk* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_DriveSize;
	return result;
}


void exogenesis_install_hard_disk_set_DriveSize (ExogenesisInstallHardDisk* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_DriveSize = value;
	g_object_notify ((GObject *) self, "DriveSize");
}


gint exogenesis_install_hard_disk_get_PartitionCount (ExogenesisInstallHardDisk* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->_partitions);
	result = _tmp0_;
	return result;
}


static GType exogenesis_install_hard_disk_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisInstallHardDisk* self;
	self = (ExogenesisInstallHardDisk*) base;
	result = EXOGENESIS_TYPE_INSTALL_PARTITION;
	return result;
}


static void exogenesis_install_hard_disk_class_init (ExogenesisInstallHardDiskClass * klass) {
	exogenesis_install_hard_disk_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisInstallHardDiskPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_install_hard_disk_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_install_hard_disk_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_install_hard_disk_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_DEVICE_NAME, g_param_spec_string ("DeviceName", "DeviceName", "DeviceName", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_MODEL, g_param_spec_string ("Model", "Model", "Model", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_SERIAL_NUMBER, g_param_spec_string ("SerialNumber", "SerialNumber", "SerialNumber", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_IS_GRUB_TARGET, g_param_spec_boolean ("IsGrubTarget", "IsGrubTarget", "IsGrubTarget", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_DRIVE_SIZE, g_param_spec_uint64 ("DriveSize", "DriveSize", "DriveSize", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_PARTITION_COUNT, g_param_spec_int ("PartitionCount", "PartitionCount", "PartitionCount", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_HARD_DISK_ELEMENT_TYPE, "element-type");
}


static void exogenesis_install_hard_disk_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_install_hard_disk_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_install_hard_disk_real_iterator;
	iface->get_element_type = exogenesis_install_hard_disk_real_get_element_type;
}


static void exogenesis_install_hard_disk_instance_init (ExogenesisInstallHardDisk * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = EXOGENESIS_INSTALL_HARD_DISK_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_INSTALL_PARTITION, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_partitions = _tmp0_;
}


static void exogenesis_install_hard_disk_finalize (GObject* obj) {
	ExogenesisInstallHardDisk * self;
	self = EXOGENESIS_INSTALL_HARD_DISK (obj);
	_g_free0 (self->priv->_DeviceName);
	_g_free0 (self->priv->_Model);
	_g_free0 (self->priv->_SerialNumber);
	_g_object_unref0 (self->priv->_partitions);
	G_OBJECT_CLASS (exogenesis_install_hard_disk_parent_class)->finalize (obj);
}


GType exogenesis_install_hard_disk_get_type (void) {
	static volatile gsize exogenesis_install_hard_disk_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_install_hard_disk_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallHardDiskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_install_hard_disk_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstallHardDisk), 0, (GInstanceInitFunc) exogenesis_install_hard_disk_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_install_hard_disk_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_install_hard_disk_type_id;
		exogenesis_install_hard_disk_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisInstallHardDisk", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_install_hard_disk_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_install_hard_disk_type_id__volatile, exogenesis_install_hard_disk_type_id);
	}
	return exogenesis_install_hard_disk_type_id__volatile;
}


static void _vala_exogenesis_install_hard_disk_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisInstallHardDisk * self;
	self = EXOGENESIS_INSTALL_HARD_DISK (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_HARD_DISK_DEVICE_NAME:
		g_value_set_string (value, exogenesis_install_hard_disk_get_DeviceName (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_MODEL:
		g_value_set_string (value, exogenesis_install_hard_disk_get_Model (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_SERIAL_NUMBER:
		g_value_set_string (value, exogenesis_install_hard_disk_get_SerialNumber (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_IS_GRUB_TARGET:
		g_value_set_boolean (value, exogenesis_install_hard_disk_get_IsGrubTarget (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_DRIVE_SIZE:
		g_value_set_uint64 (value, exogenesis_install_hard_disk_get_DriveSize (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_PARTITION_COUNT:
		g_value_set_int (value, exogenesis_install_hard_disk_get_PartitionCount (self));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_install_hard_disk_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisInstallHardDisk * self;
	self = EXOGENESIS_INSTALL_HARD_DISK (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_HARD_DISK_DEVICE_NAME:
		exogenesis_install_hard_disk_set_DeviceName (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_MODEL:
		exogenesis_install_hard_disk_set_Model (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_SERIAL_NUMBER:
		exogenesis_install_hard_disk_set_SerialNumber (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_IS_GRUB_TARGET:
		exogenesis_install_hard_disk_set_IsGrubTarget (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_INSTALL_HARD_DISK_DRIVE_SIZE:
		exogenesis_install_hard_disk_set_DriveSize (self, g_value_get_uint64 (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisInstallPartition* exogenesis_install_partition_construct (GType object_type) {
	ExogenesisInstallPartition * self = NULL;
	self = (ExogenesisInstallPartition*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisInstallPartition* exogenesis_install_partition_new (void) {
	return exogenesis_install_partition_construct (EXOGENESIS_TYPE_INSTALL_PARTITION);
}


void exogenesis_install_partition_AddInstallPartition (ExogenesisInstallPartition* self, ExogenesisInstallPartition* ip) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (ip != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_lstPartitions, ip);
}


static gint exogenesis_install_partition_real_compare_to (GeeComparable* base, ExogenesisInstallPartition* comp) {
	ExogenesisInstallPartition * self;
	gint result = 0;
	self = (ExogenesisInstallPartition*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (self->priv->_Start < comp->priv->_Start) {
		result = -1;
		return result;
	}
	if (self->priv->_Start > comp->priv->_Start) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


ExogenesisInstallPartition* exogenesis_install_partition_GetPartition (ExogenesisInstallPartition* self, gint idx) {
	ExogenesisInstallPartition* result = NULL;
	gpointer _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_lstPartitions, idx);
	result = (ExogenesisInstallPartition*) _tmp0_;
	return result;
}


gint exogenesis_install_partition_ExtPartitionCount (ExogenesisInstallPartition* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->_lstPartitions);
	result = _tmp0_;
	return result;
}


static GeeIterator* exogenesis_install_partition_real_iterator (GeeIterable* base) {
	ExogenesisInstallPartition * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisInstallPartition*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_lstPartitions);
	result = _tmp0_;
	return result;
}


void exogenesis_install_partition_SortPartitions (ExogenesisInstallPartition* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->priv->_lstPartitions, NULL);
}


guint64 exogenesis_install_partition_get_ByteSize (ExogenesisInstallPartition* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_ByteSize;
	return result;
}


void exogenesis_install_partition_set_ByteSize (ExogenesisInstallPartition* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_ByteSize = value;
	g_object_notify ((GObject *) self, "ByteSize");
}


const gchar* exogenesis_install_partition_get_DisplaySize (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_DisplaySize;
	return result;
}


void exogenesis_install_partition_set_DisplaySize (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_DisplaySize);
	self->priv->_DisplaySize = _tmp0_;
	g_object_notify ((GObject *) self, "DisplaySize");
}


gboolean exogenesis_install_partition_get_Format (ExogenesisInstallPartition* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_Format;
	return result;
}


void exogenesis_install_partition_set_Format (ExogenesisInstallPartition* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_Format = value;
	g_object_notify ((GObject *) self, "Format");
}


gboolean exogenesis_install_partition_get_Use (ExogenesisInstallPartition* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_Use;
	return result;
}


void exogenesis_install_partition_set_Use (ExogenesisInstallPartition* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_Use = value;
	g_object_notify ((GObject *) self, "Use");
}


gboolean exogenesis_install_partition_get_NewPartition (ExogenesisInstallPartition* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_NewPartition;
	return result;
}


void exogenesis_install_partition_set_NewPartition (ExogenesisInstallPartition* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_NewPartition = value;
	g_object_notify ((GObject *) self, "NewPartition");
}


const gchar* exogenesis_install_partition_get_MountPoint (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_MountPoint;
	return result;
}


void exogenesis_install_partition_set_MountPoint (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_MountPoint);
	self->priv->_MountPoint = _tmp0_;
	g_object_notify ((GObject *) self, "MountPoint");
}


const gchar* exogenesis_install_partition_get_Type (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Type;
	return result;
}


void exogenesis_install_partition_set_Type (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Type);
	self->priv->_Type = _tmp0_;
	g_object_notify ((GObject *) self, "Type");
}


const gchar* exogenesis_install_partition_get_TypeID (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_TypeID;
	return result;
}


void exogenesis_install_partition_set_TypeID (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_TypeID);
	self->priv->_TypeID = _tmp0_;
	g_object_notify ((GObject *) self, "TypeID");
}


const gchar* exogenesis_install_partition_get_Label (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Label;
	return result;
}


void exogenesis_install_partition_set_Label (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Label);
	self->priv->_Label = _tmp0_;
	g_object_notify ((GObject *) self, "Label");
}


guint64 exogenesis_install_partition_get_Start (ExogenesisInstallPartition* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_Start;
	return result;
}


void exogenesis_install_partition_set_Start (ExogenesisInstallPartition* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Start = value;
	g_object_notify ((GObject *) self, "Start");
}


guint64 exogenesis_install_partition_get_End (ExogenesisInstallPartition* self) {
	guint64 result;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->_End;
	return result;
}


void exogenesis_install_partition_set_End (ExogenesisInstallPartition* self, guint64 value) {
	g_return_if_fail (self != NULL);
	self->priv->_End = value;
	g_object_notify ((GObject *) self, "End");
}


const gchar* exogenesis_install_partition_get_Device (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Device;
	return result;
}


void exogenesis_install_partition_set_Device (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Device);
	self->priv->_Device = _tmp0_;
	g_object_notify ((GObject *) self, "Device");
}


const gchar* exogenesis_install_partition_get_ID (ExogenesisInstallPartition* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_ID;
	return result;
}


void exogenesis_install_partition_set_ID (ExogenesisInstallPartition* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_ID);
	self->priv->_ID = _tmp0_;
	g_object_notify ((GObject *) self, "ID");
}


static GType exogenesis_install_partition_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisInstallPartition* self;
	self = (ExogenesisInstallPartition*) base;
	result = EXOGENESIS_TYPE_INSTALL_PARTITION;
	return result;
}


static void exogenesis_install_partition_class_init (ExogenesisInstallPartitionClass * klass) {
	exogenesis_install_partition_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisInstallPartitionPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_install_partition_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_install_partition_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_install_partition_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_BYTE_SIZE, g_param_spec_uint64 ("ByteSize", "ByteSize", "ByteSize", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_DISPLAY_SIZE, g_param_spec_string ("DisplaySize", "DisplaySize", "DisplaySize", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_FORMAT, g_param_spec_boolean ("Format", "Format", "Format", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_USE, g_param_spec_boolean ("Use", "Use", "Use", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_NEW_PARTITION, g_param_spec_boolean ("NewPartition", "NewPartition", "NewPartition", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_MOUNT_POINT, g_param_spec_string ("MountPoint", "MountPoint", "MountPoint", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_TYPE, g_param_spec_string ("Type", "Type", "Type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_TYPE_ID, g_param_spec_string ("TypeID", "TypeID", "TypeID", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_LABEL, g_param_spec_string ("Label", "Label", "Label", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_START, g_param_spec_uint64 ("Start", "Start", "Start", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_END, g_param_spec_uint64 ("End", "End", "End", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_DEVICE, g_param_spec_string ("Device", "Device", "Device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_ID, g_param_spec_string ("ID", "ID", "ID", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_PARTITION_ELEMENT_TYPE, "element-type");
}


static void exogenesis_install_partition_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_install_partition_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_install_partition_real_compare_to;
}


static void exogenesis_install_partition_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_install_partition_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_install_partition_real_iterator;
	iface->get_element_type = exogenesis_install_partition_real_get_element_type;
}


static void exogenesis_install_partition_instance_init (ExogenesisInstallPartition * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = EXOGENESIS_INSTALL_PARTITION_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_INSTALL_PARTITION, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_lstPartitions = _tmp0_;
}


static void exogenesis_install_partition_finalize (GObject* obj) {
	ExogenesisInstallPartition * self;
	self = EXOGENESIS_INSTALL_PARTITION (obj);
	_g_free0 (self->priv->_DisplaySize);
	_g_free0 (self->priv->_MountPoint);
	_g_free0 (self->priv->_Type);
	_g_free0 (self->priv->_TypeID);
	_g_free0 (self->priv->_Label);
	_g_free0 (self->priv->_Device);
	_g_free0 (self->priv->_ID);
	_g_object_unref0 (self->priv->_lstPartitions);
	G_OBJECT_CLASS (exogenesis_install_partition_parent_class)->finalize (obj);
}


GType exogenesis_install_partition_get_type (void) {
	static volatile gsize exogenesis_install_partition_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_install_partition_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallPartitionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_install_partition_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstallPartition), 0, (GInstanceInitFunc) exogenesis_install_partition_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_install_partition_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_install_partition_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_install_partition_type_id;
		exogenesis_install_partition_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisInstallPartition", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_install_partition_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_type_add_interface_static (exogenesis_install_partition_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_install_partition_type_id__volatile, exogenesis_install_partition_type_id);
	}
	return exogenesis_install_partition_type_id__volatile;
}


static void _vala_exogenesis_install_partition_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisInstallPartition * self;
	self = EXOGENESIS_INSTALL_PARTITION (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_PARTITION_BYTE_SIZE:
		g_value_set_uint64 (value, exogenesis_install_partition_get_ByteSize (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_DISPLAY_SIZE:
		g_value_set_string (value, exogenesis_install_partition_get_DisplaySize (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_FORMAT:
		g_value_set_boolean (value, exogenesis_install_partition_get_Format (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_USE:
		g_value_set_boolean (value, exogenesis_install_partition_get_Use (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_NEW_PARTITION:
		g_value_set_boolean (value, exogenesis_install_partition_get_NewPartition (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_MOUNT_POINT:
		g_value_set_string (value, exogenesis_install_partition_get_MountPoint (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_TYPE:
		g_value_set_string (value, exogenesis_install_partition_get_Type (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_TYPE_ID:
		g_value_set_string (value, exogenesis_install_partition_get_TypeID (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_LABEL:
		g_value_set_string (value, exogenesis_install_partition_get_Label (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_START:
		g_value_set_uint64 (value, exogenesis_install_partition_get_Start (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_END:
		g_value_set_uint64 (value, exogenesis_install_partition_get_End (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_DEVICE:
		g_value_set_string (value, exogenesis_install_partition_get_Device (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_ID:
		g_value_set_string (value, exogenesis_install_partition_get_ID (self));
		break;
		case EXOGENESIS_INSTALL_PARTITION_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_install_partition_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisInstallPartition * self;
	self = EXOGENESIS_INSTALL_PARTITION (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_PARTITION_BYTE_SIZE:
		exogenesis_install_partition_set_ByteSize (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_DISPLAY_SIZE:
		exogenesis_install_partition_set_DisplaySize (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_FORMAT:
		exogenesis_install_partition_set_Format (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_USE:
		exogenesis_install_partition_set_Use (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_NEW_PARTITION:
		exogenesis_install_partition_set_NewPartition (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_MOUNT_POINT:
		exogenesis_install_partition_set_MountPoint (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_TYPE:
		exogenesis_install_partition_set_Type (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_TYPE_ID:
		exogenesis_install_partition_set_TypeID (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_LABEL:
		exogenesis_install_partition_set_Label (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_START:
		exogenesis_install_partition_set_Start (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_END:
		exogenesis_install_partition_set_End (self, g_value_get_uint64 (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_DEVICE:
		exogenesis_install_partition_set_Device (self, g_value_get_string (value));
		break;
		case EXOGENESIS_INSTALL_PARTITION_ID:
		exogenesis_install_partition_set_ID (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisInstallUsers* exogenesis_install_users_construct (GType object_type) {
	ExogenesisInstallUsers * self = NULL;
	self = (ExogenesisInstallUsers*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisInstallUsers* exogenesis_install_users_new (void) {
	return exogenesis_install_users_construct (EXOGENESIS_TYPE_INSTALL_USERS);
}


void exogenesis_install_users_AddUser (ExogenesisInstallUsers* self, ExogenesisUserDetail* user) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (user != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->_Users, user);
}


void exogenesis_install_users_Sort (ExogenesisInstallUsers* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->_Users, NULL);
}


static GeeIterator* exogenesis_install_users_real_iterator (GeeIterable* base) {
	ExogenesisInstallUsers * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisInstallUsers*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->_Users);
	result = _tmp0_;
	return result;
}


gint exogenesis_install_users_get_Count (ExogenesisInstallUsers* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->_Users);
	result = _tmp0_;
	return result;
}


static GType exogenesis_install_users_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisInstallUsers* self;
	self = (ExogenesisInstallUsers*) base;
	result = EXOGENESIS_TYPE_USER_DETAIL;
	return result;
}


static void exogenesis_install_users_class_init (ExogenesisInstallUsersClass * klass) {
	exogenesis_install_users_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_install_users_get_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_install_users_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_USERS_COUNT, g_param_spec_int ("Count", "Count", "Count", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_USERS_ELEMENT_TYPE, "element-type");
}


static void exogenesis_install_users_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_install_users_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_install_users_real_iterator;
	iface->get_element_type = exogenesis_install_users_real_get_element_type;
}


static void exogenesis_install_users_instance_init (ExogenesisInstallUsers * self) {
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_USER_DETAIL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->_Users = _tmp0_;
}


static void exogenesis_install_users_finalize (GObject* obj) {
	ExogenesisInstallUsers * self;
	self = EXOGENESIS_INSTALL_USERS (obj);
	_g_object_unref0 (self->_Users);
	G_OBJECT_CLASS (exogenesis_install_users_parent_class)->finalize (obj);
}


GType exogenesis_install_users_get_type (void) {
	static volatile gsize exogenesis_install_users_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_install_users_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallUsersClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_install_users_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstallUsers), 0, (GInstanceInitFunc) exogenesis_install_users_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_install_users_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_install_users_type_id;
		exogenesis_install_users_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisInstallUsers", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_install_users_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_install_users_type_id__volatile, exogenesis_install_users_type_id);
	}
	return exogenesis_install_users_type_id__volatile;
}


static void _vala_exogenesis_install_users_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisInstallUsers * self;
	self = EXOGENESIS_INSTALL_USERS (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_USERS_COUNT:
		g_value_set_int (value, exogenesis_install_users_get_Count (self));
		break;
		case EXOGENESIS_INSTALL_USERS_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gint exogenesis_user_detail_real_compare_to (GeeComparable* base, ExogenesisUserDetail* comp) {
	ExogenesisUserDetail * self;
	gint result = 0;
	self = (ExogenesisUserDetail*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (self->priv->_UserId < comp->priv->_UserId) {
		result = -1;
		return result;
	}
	if (self->priv->_UserId > comp->priv->_UserId) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


ExogenesisUserDetail* exogenesis_user_detail_construct (GType object_type) {
	ExogenesisUserDetail * self = NULL;
	self = (ExogenesisUserDetail*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisUserDetail* exogenesis_user_detail_new (void) {
	return exogenesis_user_detail_construct (EXOGENESIS_TYPE_USER_DETAIL);
}


gint exogenesis_user_detail_get_UserId (ExogenesisUserDetail* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_UserId;
	return result;
}


void exogenesis_user_detail_set_UserId (ExogenesisUserDetail* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_UserId = value;
	g_object_notify ((GObject *) self, "UserId");
}


gint exogenesis_user_detail_get_GroupId (ExogenesisUserDetail* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_GroupId;
	return result;
}


void exogenesis_user_detail_set_GroupId (ExogenesisUserDetail* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_GroupId = value;
	g_object_notify ((GObject *) self, "GroupId");
}


const gchar* exogenesis_user_detail_get_Username (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Username;
	return result;
}


void exogenesis_user_detail_set_Username (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Username);
	self->priv->_Username = _tmp0_;
	g_object_notify ((GObject *) self, "Username");
}


const gchar* exogenesis_user_detail_get_Fullname (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Fullname;
	return result;
}


void exogenesis_user_detail_set_Fullname (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Fullname);
	self->priv->_Fullname = _tmp0_;
	g_object_notify ((GObject *) self, "Fullname");
}


const gchar* exogenesis_user_detail_get_OfficeLocation (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_OfficeLocation;
	return result;
}


void exogenesis_user_detail_set_OfficeLocation (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_OfficeLocation);
	self->priv->_OfficeLocation = _tmp0_;
	g_object_notify ((GObject *) self, "OfficeLocation");
}


const gchar* exogenesis_user_detail_get_WorkPhone (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_WorkPhone;
	return result;
}


void exogenesis_user_detail_set_WorkPhone (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_WorkPhone);
	self->priv->_WorkPhone = _tmp0_;
	g_object_notify ((GObject *) self, "WorkPhone");
}


const gchar* exogenesis_user_detail_get_HomePhone (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_HomePhone;
	return result;
}


void exogenesis_user_detail_set_HomePhone (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_HomePhone);
	self->priv->_HomePhone = _tmp0_;
	g_object_notify ((GObject *) self, "HomePhone");
}


const gchar* exogenesis_user_detail_get_HomeFolder (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_HomeFolder;
	return result;
}


void exogenesis_user_detail_set_HomeFolder (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_HomeFolder);
	self->priv->_HomeFolder = _tmp0_;
	g_object_notify ((GObject *) self, "HomeFolder");
}


const gchar* exogenesis_user_detail_get_Shell (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Shell;
	return result;
}


void exogenesis_user_detail_set_Shell (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Shell);
	self->priv->_Shell = _tmp0_;
	g_object_notify ((GObject *) self, "Shell");
}


gchar exogenesis_user_detail_get_Type (ExogenesisUserDetail* self) {
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	result = self->priv->_Type;
	return result;
}


void exogenesis_user_detail_set_Type (ExogenesisUserDetail* self, gchar value) {
	g_return_if_fail (self != NULL);
	self->priv->_Type = value;
	g_object_notify ((GObject *) self, "Type");
}


const gchar* exogenesis_user_detail_get_Password (ExogenesisUserDetail* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Password;
	return result;
}


void exogenesis_user_detail_set_Password (ExogenesisUserDetail* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Password);
	self->priv->_Password = _tmp0_;
	g_object_notify ((GObject *) self, "Password");
}


gboolean exogenesis_user_detail_get_EncryptHome (ExogenesisUserDetail* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_EncryptHome;
	return result;
}


void exogenesis_user_detail_set_EncryptHome (ExogenesisUserDetail* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_EncryptHome = value;
	g_object_notify ((GObject *) self, "EncryptHome");
}


gboolean exogenesis_user_detail_get_AutoLogon (ExogenesisUserDetail* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_AutoLogon;
	return result;
}


void exogenesis_user_detail_set_AutoLogon (ExogenesisUserDetail* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_AutoLogon = value;
	g_object_notify ((GObject *) self, "AutoLogon");
}


gboolean exogenesis_user_detail_get_RequirePassword (ExogenesisUserDetail* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_RequirePassword;
	return result;
}


void exogenesis_user_detail_set_RequirePassword (ExogenesisUserDetail* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_RequirePassword = value;
	g_object_notify ((GObject *) self, "RequirePassword");
}


gboolean exogenesis_user_detail_get_MainAccount (ExogenesisUserDetail* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_MainAccount;
	return result;
}


void exogenesis_user_detail_set_MainAccount (ExogenesisUserDetail* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_MainAccount = value;
	g_object_notify ((GObject *) self, "MainAccount");
}


static void exogenesis_user_detail_class_init (ExogenesisUserDetailClass * klass) {
	exogenesis_user_detail_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisUserDetailPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_user_detail_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_user_detail_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_user_detail_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_USER_ID, g_param_spec_int ("UserId", "UserId", "UserId", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_GROUP_ID, g_param_spec_int ("GroupId", "GroupId", "GroupId", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_USERNAME, g_param_spec_string ("Username", "Username", "Username", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_FULLNAME, g_param_spec_string ("Fullname", "Fullname", "Fullname", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_OFFICE_LOCATION, g_param_spec_string ("OfficeLocation", "OfficeLocation", "OfficeLocation", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_WORK_PHONE, g_param_spec_string ("WorkPhone", "WorkPhone", "WorkPhone", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_HOME_PHONE, g_param_spec_string ("HomePhone", "HomePhone", "HomePhone", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_HOME_FOLDER, g_param_spec_string ("HomeFolder", "HomeFolder", "HomeFolder", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_SHELL, g_param_spec_string ("Shell", "Shell", "Shell", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_TYPE, g_param_spec_char ("Type", "Type", "Type", G_MININT8, G_MAXINT8, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_PASSWORD, g_param_spec_string ("Password", "Password", "Password", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_ENCRYPT_HOME, g_param_spec_boolean ("EncryptHome", "EncryptHome", "EncryptHome", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_AUTO_LOGON, g_param_spec_boolean ("AutoLogon", "AutoLogon", "AutoLogon", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_REQUIRE_PASSWORD, g_param_spec_boolean ("RequirePassword", "RequirePassword", "RequirePassword", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_USER_DETAIL_MAIN_ACCOUNT, g_param_spec_boolean ("MainAccount", "MainAccount", "MainAccount", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void exogenesis_user_detail_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_user_detail_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_user_detail_real_compare_to;
}


static void exogenesis_user_detail_instance_init (ExogenesisUserDetail * self) {
	self->priv = EXOGENESIS_USER_DETAIL_GET_PRIVATE (self);
}


static void exogenesis_user_detail_finalize (GObject* obj) {
	ExogenesisUserDetail * self;
	self = EXOGENESIS_USER_DETAIL (obj);
	_g_free0 (self->priv->_Username);
	_g_free0 (self->priv->_Fullname);
	_g_free0 (self->priv->_OfficeLocation);
	_g_free0 (self->priv->_WorkPhone);
	_g_free0 (self->priv->_HomePhone);
	_g_free0 (self->priv->_HomeFolder);
	_g_free0 (self->priv->_Shell);
	_g_free0 (self->priv->_Password);
	G_OBJECT_CLASS (exogenesis_user_detail_parent_class)->finalize (obj);
}


GType exogenesis_user_detail_get_type (void) {
	static volatile gsize exogenesis_user_detail_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_user_detail_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisUserDetailClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_user_detail_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisUserDetail), 0, (GInstanceInitFunc) exogenesis_user_detail_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_user_detail_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_user_detail_type_id;
		exogenesis_user_detail_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisUserDetail", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_user_detail_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&exogenesis_user_detail_type_id__volatile, exogenesis_user_detail_type_id);
	}
	return exogenesis_user_detail_type_id__volatile;
}


static void _vala_exogenesis_user_detail_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisUserDetail * self;
	self = EXOGENESIS_USER_DETAIL (object);
	switch (property_id) {
		case EXOGENESIS_USER_DETAIL_USER_ID:
		g_value_set_int (value, exogenesis_user_detail_get_UserId (self));
		break;
		case EXOGENESIS_USER_DETAIL_GROUP_ID:
		g_value_set_int (value, exogenesis_user_detail_get_GroupId (self));
		break;
		case EXOGENESIS_USER_DETAIL_USERNAME:
		g_value_set_string (value, exogenesis_user_detail_get_Username (self));
		break;
		case EXOGENESIS_USER_DETAIL_FULLNAME:
		g_value_set_string (value, exogenesis_user_detail_get_Fullname (self));
		break;
		case EXOGENESIS_USER_DETAIL_OFFICE_LOCATION:
		g_value_set_string (value, exogenesis_user_detail_get_OfficeLocation (self));
		break;
		case EXOGENESIS_USER_DETAIL_WORK_PHONE:
		g_value_set_string (value, exogenesis_user_detail_get_WorkPhone (self));
		break;
		case EXOGENESIS_USER_DETAIL_HOME_PHONE:
		g_value_set_string (value, exogenesis_user_detail_get_HomePhone (self));
		break;
		case EXOGENESIS_USER_DETAIL_HOME_FOLDER:
		g_value_set_string (value, exogenesis_user_detail_get_HomeFolder (self));
		break;
		case EXOGENESIS_USER_DETAIL_SHELL:
		g_value_set_string (value, exogenesis_user_detail_get_Shell (self));
		break;
		case EXOGENESIS_USER_DETAIL_TYPE:
		g_value_set_char (value, exogenesis_user_detail_get_Type (self));
		break;
		case EXOGENESIS_USER_DETAIL_PASSWORD:
		g_value_set_string (value, exogenesis_user_detail_get_Password (self));
		break;
		case EXOGENESIS_USER_DETAIL_ENCRYPT_HOME:
		g_value_set_boolean (value, exogenesis_user_detail_get_EncryptHome (self));
		break;
		case EXOGENESIS_USER_DETAIL_AUTO_LOGON:
		g_value_set_boolean (value, exogenesis_user_detail_get_AutoLogon (self));
		break;
		case EXOGENESIS_USER_DETAIL_REQUIRE_PASSWORD:
		g_value_set_boolean (value, exogenesis_user_detail_get_RequirePassword (self));
		break;
		case EXOGENESIS_USER_DETAIL_MAIN_ACCOUNT:
		g_value_set_boolean (value, exogenesis_user_detail_get_MainAccount (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_user_detail_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisUserDetail * self;
	self = EXOGENESIS_USER_DETAIL (object);
	switch (property_id) {
		case EXOGENESIS_USER_DETAIL_USER_ID:
		exogenesis_user_detail_set_UserId (self, g_value_get_int (value));
		break;
		case EXOGENESIS_USER_DETAIL_GROUP_ID:
		exogenesis_user_detail_set_GroupId (self, g_value_get_int (value));
		break;
		case EXOGENESIS_USER_DETAIL_USERNAME:
		exogenesis_user_detail_set_Username (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_FULLNAME:
		exogenesis_user_detail_set_Fullname (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_OFFICE_LOCATION:
		exogenesis_user_detail_set_OfficeLocation (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_WORK_PHONE:
		exogenesis_user_detail_set_WorkPhone (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_HOME_PHONE:
		exogenesis_user_detail_set_HomePhone (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_HOME_FOLDER:
		exogenesis_user_detail_set_HomeFolder (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_SHELL:
		exogenesis_user_detail_set_Shell (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_TYPE:
		exogenesis_user_detail_set_Type (self, g_value_get_char (value));
		break;
		case EXOGENESIS_USER_DETAIL_PASSWORD:
		exogenesis_user_detail_set_Password (self, g_value_get_string (value));
		break;
		case EXOGENESIS_USER_DETAIL_ENCRYPT_HOME:
		exogenesis_user_detail_set_EncryptHome (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_USER_DETAIL_AUTO_LOGON:
		exogenesis_user_detail_set_AutoLogon (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_USER_DETAIL_REQUIRE_PASSWORD:
		exogenesis_user_detail_set_RequirePassword (self, g_value_get_boolean (value));
		break;
		case EXOGENESIS_USER_DETAIL_MAIN_ACCOUNT:
		exogenesis_user_detail_set_MainAccount (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisInstallGroups* exogenesis_install_groups_construct (GType object_type) {
	ExogenesisInstallGroups * self = NULL;
	self = (ExogenesisInstallGroups*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisInstallGroups* exogenesis_install_groups_new (void) {
	return exogenesis_install_groups_construct (EXOGENESIS_TYPE_INSTALL_GROUPS);
}


void exogenesis_install_groups_AddGroup (ExogenesisInstallGroups* self, ExogenesisGroup* group) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (group != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->_Groups, group);
}


void exogenesis_install_groups_Sort (ExogenesisInstallGroups* self) {
	g_return_if_fail (self != NULL);
	gee_list_sort ((GeeList*) self->_Groups, NULL);
}


static GeeIterator* exogenesis_install_groups_real_iterator (GeeIterable* base) {
	ExogenesisInstallGroups * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisInstallGroups*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->_Groups);
	result = _tmp0_;
	return result;
}


static GType exogenesis_install_groups_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisInstallGroups* self;
	self = (ExogenesisInstallGroups*) base;
	result = EXOGENESIS_TYPE_GROUP;
	return result;
}


static void exogenesis_install_groups_class_init (ExogenesisInstallGroupsClass * klass) {
	exogenesis_install_groups_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_install_groups_get_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_install_groups_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_INSTALL_GROUPS_ELEMENT_TYPE, "element-type");
}


static void exogenesis_install_groups_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_install_groups_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_install_groups_real_iterator;
	iface->get_element_type = exogenesis_install_groups_real_get_element_type;
}


static void exogenesis_install_groups_instance_init (ExogenesisInstallGroups * self) {
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_GROUP, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->_Groups = _tmp0_;
}


static void exogenesis_install_groups_finalize (GObject* obj) {
	ExogenesisInstallGroups * self;
	self = EXOGENESIS_INSTALL_GROUPS (obj);
	_g_object_unref0 (self->_Groups);
	G_OBJECT_CLASS (exogenesis_install_groups_parent_class)->finalize (obj);
}


GType exogenesis_install_groups_get_type (void) {
	static volatile gsize exogenesis_install_groups_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_install_groups_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisInstallGroupsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_install_groups_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisInstallGroups), 0, (GInstanceInitFunc) exogenesis_install_groups_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_install_groups_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_install_groups_type_id;
		exogenesis_install_groups_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisInstallGroups", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_install_groups_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_install_groups_type_id__volatile, exogenesis_install_groups_type_id);
	}
	return exogenesis_install_groups_type_id__volatile;
}


static void _vala_exogenesis_install_groups_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisInstallGroups * self;
	self = EXOGENESIS_INSTALL_GROUPS (object);
	switch (property_id) {
		case EXOGENESIS_INSTALL_GROUPS_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


void exogenesis_group_AddUser (ExogenesisGroup* self, ExogenesisUserDetail* user) {
	ExogenesisUserDetail* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (user != NULL);
	_tmp0_ = _g_object_ref0 (user);
	self->priv->_Users = g_list_append (self->priv->_Users, _tmp0_);
}


static gint exogenesis_group_real_compare_to (GeeComparable* base, ExogenesisGroup* comp) {
	ExogenesisGroup * self;
	gint result = 0;
	self = (ExogenesisGroup*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (g_strcmp0 (self->priv->_Name, comp->priv->_Name) < 0) {
		result = -1;
		return result;
	}
	if (g_strcmp0 (self->priv->_Name, comp->priv->_Name) > 0) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


ExogenesisGroup* exogenesis_group_construct (GType object_type) {
	ExogenesisGroup * self = NULL;
	self = (ExogenesisGroup*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisGroup* exogenesis_group_new (void) {
	return exogenesis_group_construct (EXOGENESIS_TYPE_GROUP);
}


gint exogenesis_group_get_Id (ExogenesisGroup* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_Id;
	return result;
}


void exogenesis_group_set_Id (ExogenesisGroup* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_Id = value;
	g_object_notify ((GObject *) self, "Id");
}


const gchar* exogenesis_group_get_Name (ExogenesisGroup* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Name;
	return result;
}


void exogenesis_group_set_Name (ExogenesisGroup* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Name);
	self->priv->_Name = _tmp0_;
	g_object_notify ((GObject *) self, "Name");
}


gchar exogenesis_group_get_Type (ExogenesisGroup* self) {
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	result = self->priv->_Type;
	return result;
}


void exogenesis_group_set_Type (ExogenesisGroup* self, gchar value) {
	g_return_if_fail (self != NULL);
	self->priv->_Type = value;
	g_object_notify ((GObject *) self, "Type");
}


static void exogenesis_group_class_init (ExogenesisGroupClass * klass) {
	exogenesis_group_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisGroupPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_group_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_group_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_group_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_GROUP_ID, g_param_spec_int ("Id", "Id", "Id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_GROUP_NAME, g_param_spec_string ("Name", "Name", "Name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_GROUP_TYPE, g_param_spec_char ("Type", "Type", "Type", G_MININT8, G_MAXINT8, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void exogenesis_group_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_group_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_group_real_compare_to;
}


static void exogenesis_group_instance_init (ExogenesisGroup * self) {
	self->priv = EXOGENESIS_GROUP_GET_PRIVATE (self);
	self->priv->_Users = NULL;
}


static void exogenesis_group_finalize (GObject* obj) {
	ExogenesisGroup * self;
	self = EXOGENESIS_GROUP (obj);
	_g_free0 (self->priv->_Name);
	__g_list_free__g_object_unref0_0 (self->priv->_Users);
	G_OBJECT_CLASS (exogenesis_group_parent_class)->finalize (obj);
}


GType exogenesis_group_get_type (void) {
	static volatile gsize exogenesis_group_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_group_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisGroupClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_group_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisGroup), 0, (GInstanceInitFunc) exogenesis_group_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_group_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_group_type_id;
		exogenesis_group_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisGroup", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_group_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&exogenesis_group_type_id__volatile, exogenesis_group_type_id);
	}
	return exogenesis_group_type_id__volatile;
}


static void _vala_exogenesis_group_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisGroup * self;
	self = EXOGENESIS_GROUP (object);
	switch (property_id) {
		case EXOGENESIS_GROUP_ID:
		g_value_set_int (value, exogenesis_group_get_Id (self));
		break;
		case EXOGENESIS_GROUP_NAME:
		g_value_set_string (value, exogenesis_group_get_Name (self));
		break;
		case EXOGENESIS_GROUP_TYPE:
		g_value_set_char (value, exogenesis_group_get_Type (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_group_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisGroup * self;
	self = EXOGENESIS_GROUP (object);
	switch (property_id) {
		case EXOGENESIS_GROUP_ID:
		exogenesis_group_set_Id (self, g_value_get_int (value));
		break;
		case EXOGENESIS_GROUP_NAME:
		exogenesis_group_set_Name (self, g_value_get_string (value));
		break;
		case EXOGENESIS_GROUP_TYPE:
		exogenesis_group_set_Type (self, g_value_get_char (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



