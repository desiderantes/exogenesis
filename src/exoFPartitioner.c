/* exoFPartitioner.c generated by valac 0.12.1, the Vala compiler
 * generated from exoFPartitioner.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <math.h>
#include <float.h>
#include <gee.h>


#define EXOGENESIS_TYPE_FPARTITIONER (exogenesis_fpartitioner_get_type ())
#define EXOGENESIS_FPARTITIONER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FPARTITIONER, ExogenesisFPartitioner))
#define EXOGENESIS_FPARTITIONER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FPARTITIONER, ExogenesisFPartitionerClass))
#define EXOGENESIS_IS_FPARTITIONER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FPARTITIONER))
#define EXOGENESIS_IS_FPARTITIONER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FPARTITIONER))
#define EXOGENESIS_FPARTITIONER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FPARTITIONER, ExogenesisFPartitionerClass))

typedef struct _ExogenesisFPartitioner ExogenesisFPartitioner;
typedef struct _ExogenesisFPartitionerClass ExogenesisFPartitionerClass;
typedef struct _ExogenesisFPartitionerPrivate ExogenesisFPartitionerPrivate;

#define TYPE_SEGMENTED_BAR (segmented_bar_get_type ())
#define SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SEGMENTED_BAR, SegmentedBar))
#define SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SEGMENTED_BAR, SegmentedBarClass))
#define IS_SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SEGMENTED_BAR))
#define IS_SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SEGMENTED_BAR))
#define SEGMENTED_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SEGMENTED_BAR, SegmentedBarClass))

typedef struct _SegmentedBar SegmentedBar;
typedef struct _SegmentedBarClass SegmentedBarClass;

#define EXOGENESIS_FPARTITIONER_TYPE_PARTITION_COLS (exogenesis_fpartitioner_partition_cols_get_type ())

#define EXOGENESIS_FPARTITIONER_TYPE_TREE_COLS (exogenesis_fpartitioner_tree_cols_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_HARD_DISK (exogenesis_hard_disk_get_type ())
#define EXOGENESIS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDisk))
#define EXOGENESIS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))
#define EXOGENESIS_IS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_IS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))

typedef struct _ExogenesisHardDisk ExogenesisHardDisk;
typedef struct _ExogenesisHardDiskClass ExogenesisHardDiskClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))

#define EXOGENESIS_TYPE_CELL_RENDERER_BUTTON (exogenesis_cell_renderer_button_get_type ())
#define EXOGENESIS_CELL_RENDERER_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButton))
#define EXOGENESIS_CELL_RENDERER_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButtonClass))
#define EXOGENESIS_IS_CELL_RENDERER_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON))
#define EXOGENESIS_IS_CELL_RENDERER_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON))
#define EXOGENESIS_CELL_RENDERER_BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButtonClass))

typedef struct _ExogenesisCellRendererButton ExogenesisCellRendererButton;
typedef struct _ExogenesisCellRendererButtonClass ExogenesisCellRendererButtonClass;

#define EXOGENESIS_TYPE_INSTALL_DATA (exogenesis_install_data_get_type ())
#define EXOGENESIS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallData))
#define EXOGENESIS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))
#define EXOGENESIS_IS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_IS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_INSTALL_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))

typedef struct _ExogenesisInstallData ExogenesisInstallData;
typedef struct _ExogenesisInstallDataClass ExogenesisInstallDataClass;

#define EXOGENESIS_TYPE_INSTALL_HARD_DISK (exogenesis_install_hard_disk_get_type ())
#define EXOGENESIS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDisk))
#define EXOGENESIS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))
#define EXOGENESIS_IS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_IS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_INSTALL_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))

typedef struct _ExogenesisInstallHardDisk ExogenesisInstallHardDisk;
typedef struct _ExogenesisInstallHardDiskClass ExogenesisInstallHardDiskClass;

#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;

#define EXOGENESIS_TYPE_INSTALL_PARTITION (exogenesis_install_partition_get_type ())
#define EXOGENESIS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartition))
#define EXOGENESIS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))
#define EXOGENESIS_IS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_IS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_INSTALL_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))

typedef struct _ExogenesisInstallPartition ExogenesisInstallPartition;
typedef struct _ExogenesisInstallPartitionClass ExogenesisInstallPartitionClass;

#define EXOGENESIS_TYPE_PARTITION_INFO (exogenesis_partition_info_get_type ())
#define EXOGENESIS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfo))
#define EXOGENESIS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))
#define EXOGENESIS_IS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_IS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_PARTITION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))

typedef struct _ExogenesisPartitionInfo ExogenesisPartitionInfo;
typedef struct _ExogenesisPartitionInfoClass ExogenesisPartitionInfoClass;
typedef struct _ExogenesisHDManagerPrivate ExogenesisHDManagerPrivate;

#define EXOGENESIS_TYPE_FILESYSTEM_TYPE (exogenesis_filesystem_type_get_type ())
#define EXOGENESIS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemType))
#define EXOGENESIS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))
#define EXOGENESIS_IS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_IS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_FILESYSTEM_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))

typedef struct _ExogenesisFilesystemType ExogenesisFilesystemType;
typedef struct _ExogenesisFilesystemTypeClass ExogenesisFilesystemTypeClass;

struct _ExogenesisFPartitioner {
	GtkLayout parent_instance;
	ExogenesisFPartitionerPrivate * priv;
};

struct _ExogenesisFPartitionerClass {
	GtkLayoutClass parent_class;
};

struct _ExogenesisFPartitionerPrivate {
	GtkFixed* fxdPartitioner;
	GtkComboBox* cboHD;
	GtkTreeView* tvwPartitions;
	GtkVBox* vboxHD;
	GtkButton* btnCreatePart;
	GtkRadioButton* rdoBefore;
	GtkRadioButton* rdoAfter;
	GtkButton* btnApply;
	GtkButton* btnCancel;
	SegmentedBar* segbarHD;
	GtkTreeStore* _lstPartitions;
	GtkListStore* _lstDisks;
};

typedef enum  {
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint = 0,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_FSTypeID,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_Device,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_PartitionID,
	EXOGENESIS_FPARTITIONER_PARTITION_COLS_NewPartition
} ExogenesisFPartitionerPartitionCols;

typedef enum  {
	EXOGENESIS_FPARTITIONER_TREE_COLS_MountPoint = 0,
	EXOGENESIS_FPARTITIONER_TREE_COLS_DisplaySize,
	EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType,
	EXOGENESIS_FPARTITIONER_TREE_COLS_FormatFlag,
	EXOGENESIS_FPARTITIONER_TREE_COLS_UseFlag,
	EXOGENESIS_FPARTITIONER_TREE_COLS_Label,
	EXOGENESIS_FPARTITIONER_TREE_COLS_Remove
} ExogenesisFPartitionerTreeCols;

struct _ExogenesisHDManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisHDManagerPrivate * priv;
	gboolean ThreadStop;
	gboolean PartitionerRunning;
	GeeArrayList* HardDisks;
};

struct _ExogenesisHDManagerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisHDManager *self);
};


static gpointer exogenesis_fpartitioner_parent_class = NULL;
extern ExogenesisInstallData* exogenesis_gInstallData;
extern ExogenesisHDManager* exogenesis_gHDManager;

GType exogenesis_fpartitioner_get_type (void) G_GNUC_CONST;
GType segmented_bar_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_FPARTITIONER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_FPARTITIONER, ExogenesisFPartitionerPrivate))
enum  {
	EXOGENESIS_FPARTITIONER_DUMMY_PROPERTY
};
static GType exogenesis_fpartitioner_partition_cols_get_type (void) G_GNUC_UNUSED;
static GType exogenesis_fpartitioner_tree_cols_get_type (void) G_GNUC_UNUSED;
GType exogenesis_hard_disk_get_type (void) G_GNUC_CONST;
ExogenesisFPartitioner* exogenesis_fpartitioner_new (ExogenesisHardDisk* selectedHD);
ExogenesisFPartitioner* exogenesis_fpartitioner_construct (GType object_type, ExogenesisHardDisk* selectedHD);
static void exogenesis_fpartitioner_Build (ExogenesisFPartitioner* self);
static void exogenesis_fpartitioner_GetDiskInfo (ExogenesisFPartitioner* self);
static void exogenesis_fpartitioner_SetSelectedHD (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd);
#define EXOGENESIS_UIPath "/home/steve/1-work/anjuta/exogenesis/src/exogenesis.ui"
void exogenesis_fpartitioner_OnBtnCreatePartition_Click (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnBtnCreatePartition_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
void exogenesis_fpartitioner_OnBtnApply_Click (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnBtnApply_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
void exogenesis_fpartitioner_OnBtnCancel_Click (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnBtnCancel_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
void exogenesis_fpartitioner_OnCboHD_Changed (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnCboHD_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
void exogenesis_fpartitioner_OnRdoBefore_Click (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnRdoBefore_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
void exogenesis_fpartitioner_OnRdoAfter_Click (ExogenesisFPartitioner* self);
static void _exogenesis_fpartitioner_OnRdoAfter_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
gboolean exogenesis_fpartitioner_TvwPartitions_RowClick (ExogenesisFPartitioner* self, GdkEventButton* evt);
static gboolean _exogenesis_fpartitioner_TvwPartitions_RowClick_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
SegmentedBar* segmented_bar_new (void);
SegmentedBar* segmented_bar_construct (GType object_type);
void segmented_bar_set_BarHeight (SegmentedBar* self, gint value);
gint segmented_bar_get_BarHeight (SegmentedBar* self);
void segmented_bar_set_HorizontalPadding (SegmentedBar* self, gint value);
void segmented_bar_set_ShowReflection (SegmentedBar* self, gboolean value);
static void exogenesis_fpartitioner_SetTreeColumns (ExogenesisFPartitioner* self);
static void exogenesis_fpartitioner_SetColumnWidths (ExogenesisFPartitioner* self);
static void _lambda2_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFPartitioner* self);
static void __lambda2__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
static void _lambda3_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFPartitioner* self);
static void __lambda3__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
ExogenesisCellRendererButton* exogenesis_cell_renderer_button_new (void);
ExogenesisCellRendererButton* exogenesis_cell_renderer_button_construct (GType object_type);
GType exogenesis_cell_renderer_button_get_type (void) G_GNUC_CONST;
void exogenesis_fpartitioner_OnCellDelClicked (ExogenesisFPartitioner* self, const gchar* path);
static void _exogenesis_fpartitioner_OnCellDelClicked_exogenesis_cell_renderer_button_clicked (ExogenesisCellRendererButton* _sender, const gchar* path, gpointer self);
static void exogenesis_fpartitioner_ModelFromNewSelection (ExogenesisFPartitioner* self);
GType exogenesis_install_data_get_type (void) G_GNUC_CONST;
gint exogenesis_install_data_get_HardDiskCount (ExogenesisInstallData* self);
GType exogenesis_install_hard_disk_get_type (void) G_GNUC_CONST;
gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
ExogenesisHardDisk* exogenesis_hd_manager_GetHDBySerial (ExogenesisHDManager* self, const gchar* serialNumber);
const gchar* exogenesis_install_hard_disk_get_SerialNumber (ExogenesisInstallHardDisk* self);
const gchar* exogenesis_hard_disk_get_Model (ExogenesisHardDisk* self);
GType exogenesis_install_partition_get_type (void) G_GNUC_CONST;
static void exogenesis_fpartitioner_PopulateListItem (ExogenesisFPartitioner* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition);
const gchar* exogenesis_install_partition_get_MountPoint (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Type (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Label (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_Format (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_Use (ExogenesisInstallPartition* self);
guint64 exogenesis_install_partition_get_ByteSize (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_TypeID (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Device (ExogenesisInstallPartition* self);
gboolean exogenesis_install_partition_get_NewPartition (ExogenesisInstallPartition* self);
static void exogenesis_fpartitioner_ModelFromCurrentLayout (ExogenesisFPartitioner* self);
static ExogenesisHardDisk* exogenesis_fpartitioner_GetSelectedHD (ExogenesisFPartitioner* self);
GType exogenesis_partition_info_get_type (void) G_GNUC_CONST;
const gchar* exogenesis_partition_info_get_OSType (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_Device (ExogenesisPartitionInfo* self);
const gchar* exogenesis_hard_disk_get_Device (ExogenesisHardDisk* self);
const gchar* exogenesis_partition_info_get_FSTabMountPoint (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_Label (ExogenesisPartitionInfo* self);
guint64 exogenesis_partition_info_get_Capacity (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_OSTypeID (ExogenesisPartitionInfo* self);
static void exogenesis_fpartitioner_UpdateSegbar (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd, ExogenesisPartitionInfo* pi, gint PartCount);
const gchar* exogenesis_partition_info_get_PartitionType (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_CapacityDescription (ExogenesisPartitionInfo* self);
static void exogenesis_fpartitioner_AddToDisk (ExogenesisFPartitioner* self, SegmentedBar* bar, guint64 HDSize, guint64 PartitionSize, const gchar* title, gint count);
guint64 exogenesis_hard_disk_get_Capacity (ExogenesisHardDisk* self);
gchar* exogenesis_general_functions_FormatHDSize (guint64 size);
void segmented_bar_set_SegmentLabelSpacing (SegmentedBar* self, gint value);
void segmented_bar_AddSegmentRgb (SegmentedBar* self, const gchar* title, gint percent, guint rgbColor);
guint exogenesis_general_functions_BarColour (gint idx);
gboolean exogenesis_hard_disk_get_IsOptical (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_CapacityDescription (ExogenesisHardDisk* self);
gboolean exogenesis_fpartitioner_IsMountPointUsed (ExogenesisFPartitioner* self, const gchar* MountPoint);
GType exogenesis_filesystem_type_get_type (void) G_GNUC_CONST;
void exogenesis_fpartitioner_AddToTree (ExogenesisFPartitioner* self, ExogenesisFilesystemType* fstype, const gchar* mountpoint, guint64 size, const gchar* label, const gchar* partitionid);
static gboolean exogenesis_fpartitioner_HardDiskExists (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd, GtkTreeIter* iter);
static void exogenesis_fpartitioner_GetSelectedPartition (ExogenesisFPartitioner* self, GtkTreeIter* result);
const gchar* exogenesis_filesystem_type_get_Name (ExogenesisFilesystemType* self);
const gchar* exogenesis_filesystem_type_get_ID (ExogenesisFilesystemType* self);
static void exogenesis_fpartitioner_HDDisplayAfter (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd);
const gchar* exogenesis_hard_disk_get_SerialNumber (ExogenesisHardDisk* self);
static guint64 exogenesis_fpartitioner_AvailablePartSize (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd);
void segmented_bar_RemoveAllSegments (SegmentedBar* self);
static void exogenesis_fpartitioner_PopulateFromExisting (ExogenesisFPartitioner* self, GtkTreeIter* iter, gint idx, ExogenesisHardDisk* hd);
static void exogenesis_fpartitioner_AddInstallPartitions (ExogenesisFPartitioner* self);
void exogenesis_install_data_ClearInstallDisks (ExogenesisInstallData* self);
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_new (void);
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_construct (GType object_type);
void exogenesis_install_hard_disk_set_DeviceName (ExogenesisInstallHardDisk* self, const gchar* value);
void exogenesis_install_hard_disk_set_SerialNumber (ExogenesisInstallHardDisk* self, const gchar* value);
static gboolean exogenesis_fpartitioner_IsAllocated (ExogenesisFPartitioner* self, GtkTreeIter* i);
static ExogenesisInstallPartition* exogenesis_fpartitioner_PopulateInstallPartition (ExogenesisFPartitioner* self, GtkTreeIter* iter, guint64 start);
void exogenesis_install_partition_AddInstallPartition (ExogenesisInstallPartition* self, ExogenesisInstallPartition* ip);
void exogenesis_install_hard_disk_AddPartition (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* partition);
void exogenesis_install_data_AddInstallDisk (ExogenesisInstallData* self, ExogenesisInstallHardDisk* hd);
ExogenesisInstallPartition* exogenesis_install_partition_new (void);
ExogenesisInstallPartition* exogenesis_install_partition_construct (GType object_type);
void exogenesis_install_partition_set_ByteSize (ExogenesisInstallPartition* self, guint64 value);
void exogenesis_install_partition_set_DisplaySize (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Label (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_MountPoint (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Format (ExogenesisInstallPartition* self, gboolean value);
void exogenesis_install_partition_set_Use (ExogenesisInstallPartition* self, gboolean value);
void exogenesis_install_partition_set_NewPartition (ExogenesisInstallPartition* self, gboolean value);
void exogenesis_install_partition_set_Type (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_TypeID (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Device (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Start (ExogenesisInstallPartition* self, guint64 value);
guint64 exogenesis_install_partition_get_Start (ExogenesisInstallPartition* self);
void exogenesis_install_partition_set_End (ExogenesisInstallPartition* self, guint64 value);
static void exogenesis_fpartitioner_DebugTree (ExogenesisFPartitioner* self);
void exogenesis_general_functions_LogIt (const gchar* Message);
static void exogenesis_fpartitioner_RecalcUnallocated (ExogenesisFPartitioner* self, GtkTreeIter* iter);
static void exogenesis_fpartitioner_finalize (GObject* obj);


static GType exogenesis_fpartitioner_partition_cols_get_type (void) {
	static volatile gsize exogenesis_fpartitioner_partition_cols_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fpartitioner_partition_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint", "mountpoint"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize", "displaysize"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType", "formattype"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label", "label"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk", "harddisk"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag", "formatflag"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag", "useflag"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon", "removeicon"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize", "bytesize"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_FSTypeID, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_FSTypeID", "fstypeid"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_Device, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_Device", "device"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_PartitionID, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_PartitionID", "partitionid"}, {EXOGENESIS_FPARTITIONER_PARTITION_COLS_NewPartition, "EXOGENESIS_FPARTITIONER_PARTITION_COLS_NewPartition", "newpartition"}, {0, NULL, NULL}};
		GType exogenesis_fpartitioner_partition_cols_type_id;
		exogenesis_fpartitioner_partition_cols_type_id = g_enum_register_static ("ExogenesisFPartitionerPartitionCols", values);
		g_once_init_leave (&exogenesis_fpartitioner_partition_cols_type_id__volatile, exogenesis_fpartitioner_partition_cols_type_id);
	}
	return exogenesis_fpartitioner_partition_cols_type_id__volatile;
}


static GType exogenesis_fpartitioner_tree_cols_get_type (void) {
	static volatile gsize exogenesis_fpartitioner_tree_cols_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fpartitioner_tree_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{EXOGENESIS_FPARTITIONER_TREE_COLS_MountPoint, "EXOGENESIS_FPARTITIONER_TREE_COLS_MountPoint", "mountpoint"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_DisplaySize, "EXOGENESIS_FPARTITIONER_TREE_COLS_DisplaySize", "displaysize"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType, "EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType", "formattype"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_FormatFlag, "EXOGENESIS_FPARTITIONER_TREE_COLS_FormatFlag", "formatflag"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_UseFlag, "EXOGENESIS_FPARTITIONER_TREE_COLS_UseFlag", "useflag"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_Label, "EXOGENESIS_FPARTITIONER_TREE_COLS_Label", "label"}, {EXOGENESIS_FPARTITIONER_TREE_COLS_Remove, "EXOGENESIS_FPARTITIONER_TREE_COLS_Remove", "remove"}, {0, NULL, NULL}};
		GType exogenesis_fpartitioner_tree_cols_type_id;
		exogenesis_fpartitioner_tree_cols_type_id = g_enum_register_static ("ExogenesisFPartitionerTreeCols", values);
		g_once_init_leave (&exogenesis_fpartitioner_tree_cols_type_id__volatile, exogenesis_fpartitioner_tree_cols_type_id);
	}
	return exogenesis_fpartitioner_tree_cols_type_id__volatile;
}


ExogenesisFPartitioner* exogenesis_fpartitioner_construct (GType object_type, ExogenesisHardDisk* selectedHD) {
	ExogenesisFPartitioner * self = NULL;
	g_return_val_if_fail (selectedHD != NULL, NULL);
	self = (ExogenesisFPartitioner*) g_object_new (object_type, NULL);
	exogenesis_fpartitioner_Build (self);
	exogenesis_fpartitioner_GetDiskInfo (self);
	exogenesis_fpartitioner_SetSelectedHD (self, selectedHD);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->fxdPartitioner);
	return self;
}


ExogenesisFPartitioner* exogenesis_fpartitioner_new (ExogenesisHardDisk* selectedHD) {
	return exogenesis_fpartitioner_construct (EXOGENESIS_TYPE_FPARTITIONER, selectedHD);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _exogenesis_fpartitioner_OnBtnCreatePartition_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fpartitioner_OnBtnCreatePartition_Click (self);
}


static void _exogenesis_fpartitioner_OnBtnApply_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fpartitioner_OnBtnApply_Click (self);
}


static void _exogenesis_fpartitioner_OnBtnCancel_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fpartitioner_OnBtnCancel_Click (self);
}


static void _exogenesis_fpartitioner_OnCboHD_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	exogenesis_fpartitioner_OnCboHD_Changed (self);
}


static void _exogenesis_fpartitioner_OnRdoBefore_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fpartitioner_OnRdoBefore_Click (self);
}


static void _exogenesis_fpartitioner_OnRdoAfter_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fpartitioner_OnRdoAfter_Click (self);
}


static gboolean _exogenesis_fpartitioner_TvwPartitions_RowClick_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = exogenesis_fpartitioner_TvwPartitions_RowClick (self, event);
	return result;
}


static void exogenesis_fpartitioner_Build (ExogenesisFPartitioner* self) {
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* builder;
	GObject* _tmp1_ = NULL;
	GtkFixed* _tmp2_;
	GObject* _tmp3_ = NULL;
	GtkVBox* _tmp4_;
	GObject* _tmp5_ = NULL;
	GtkComboBox* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkTreeView* _tmp8_;
	GObject* _tmp9_ = NULL;
	GtkButton* _tmp10_;
	GObject* _tmp11_ = NULL;
	GtkButton* _tmp12_;
	GObject* _tmp13_ = NULL;
	GtkButton* _tmp14_;
	GObject* _tmp15_ = NULL;
	GtkRadioButton* _tmp16_;
	GObject* _tmp17_ = NULL;
	GtkRadioButton* _tmp18_;
	SegmentedBar* _tmp19_ = NULL;
	gint _tmp20_;
	GtkCellRendererText* _tmp21_ = NULL;
	GtkCellRendererText* cellHD;
	gint _tmp22_;
	gint _tmp23_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	gtk_builder_add_from_file (builder, EXOGENESIS_UIPath, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		goto __catch9_g_error;
	}
	_tmp1_ = gtk_builder_get_object (builder, "fxdPartitioner");
	_tmp2_ = _g_object_ref0 (GTK_FIXED (_tmp1_));
	_g_object_unref0 (self->priv->fxdPartitioner);
	self->priv->fxdPartitioner = _tmp2_;
	_tmp3_ = gtk_builder_get_object (builder, "vboxHDP");
	_tmp4_ = _g_object_ref0 (GTK_VBOX (_tmp3_));
	_g_object_unref0 (self->priv->vboxHD);
	self->priv->vboxHD = _tmp4_;
	_tmp5_ = gtk_builder_get_object (builder, "cboHDPDisks");
	_tmp6_ = _g_object_ref0 (GTK_COMBO_BOX (_tmp5_));
	_g_object_unref0 (self->priv->cboHD);
	self->priv->cboHD = _tmp6_;
	_tmp7_ = gtk_builder_get_object (builder, "tvwHDPPartition");
	_tmp8_ = _g_object_ref0 (GTK_TREE_VIEW (_tmp7_));
	_g_object_unref0 (self->priv->tvwPartitions);
	self->priv->tvwPartitions = _tmp8_;
	_tmp9_ = gtk_builder_get_object (builder, "btnHDPCreate");
	_tmp10_ = _g_object_ref0 (GTK_BUTTON (_tmp9_));
	_g_object_unref0 (self->priv->btnCreatePart);
	self->priv->btnCreatePart = _tmp10_;
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->btnCreatePart, FALSE);
	_tmp11_ = gtk_builder_get_object (builder, "btnHDPApply");
	_tmp12_ = _g_object_ref0 (GTK_BUTTON (_tmp11_));
	_g_object_unref0 (self->priv->btnApply);
	self->priv->btnApply = _tmp12_;
	_tmp13_ = gtk_builder_get_object (builder, "btnHDPCancel");
	_tmp14_ = _g_object_ref0 (GTK_BUTTON (_tmp13_));
	_g_object_unref0 (self->priv->btnCancel);
	self->priv->btnCancel = _tmp14_;
	_tmp15_ = gtk_builder_get_object (builder, "rdoHDPBefore");
	_tmp16_ = _g_object_ref0 (GTK_RADIO_BUTTON (_tmp15_));
	_g_object_unref0 (self->priv->rdoBefore);
	self->priv->rdoBefore = _tmp16_;
	_tmp17_ = gtk_builder_get_object (builder, "rdoHDPAfter");
	_tmp18_ = _g_object_ref0 (GTK_RADIO_BUTTON (_tmp17_));
	_g_object_unref0 (self->priv->rdoAfter);
	self->priv->rdoAfter = _tmp18_;
	g_signal_connect_object (self->priv->btnCreatePart, "clicked", (GCallback) _exogenesis_fpartitioner_OnBtnCreatePartition_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->btnApply, "clicked", (GCallback) _exogenesis_fpartitioner_OnBtnApply_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->btnCancel, "clicked", (GCallback) _exogenesis_fpartitioner_OnBtnCancel_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->cboHD, "changed", (GCallback) _exogenesis_fpartitioner_OnCboHD_Changed_gtk_combo_box_changed, self, 0);
	g_signal_connect_object ((GtkButton*) self->priv->rdoBefore, "clicked", (GCallback) _exogenesis_fpartitioner_OnRdoBefore_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object ((GtkButton*) self->priv->rdoAfter, "clicked", (GCallback) _exogenesis_fpartitioner_OnRdoAfter_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object ((GtkWidget*) self->priv->tvwPartitions, "button-release-event", (GCallback) _exogenesis_fpartitioner_TvwPartitions_RowClick_gtk_widget_button_release_event, self, 0);
	_tmp19_ = segmented_bar_new ();
	_g_object_unref0 (self->priv->segbarHD);
	self->priv->segbarHD = g_object_ref_sink (_tmp19_);
	segmented_bar_set_BarHeight (self->priv->segbarHD, 20);
	_tmp20_ = segmented_bar_get_BarHeight (self->priv->segbarHD);
	segmented_bar_set_HorizontalPadding (self->priv->segbarHD, _tmp20_ / 2);
	segmented_bar_set_ShowReflection (self->priv->segbarHD, TRUE);
	gtk_box_pack_start ((GtkBox*) self->priv->vboxHD, (GtkWidget*) self->priv->segbarHD, FALSE, FALSE, (guint) 0);
	gtk_widget_show_all ((GtkWidget*) self->priv->vboxHD);
	gtk_combo_box_set_model (self->priv->cboHD, (GtkTreeModel*) self->priv->_lstDisks);
	_tmp21_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	cellHD = g_object_ref_sink (_tmp21_);
	gtk_cell_layout_pack_start ((GtkCellLayout*) self->priv->cboHD, (GtkCellRenderer*) cellHD, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) self->priv->cboHD, (GtkCellRenderer*) cellHD, "text", 0);
	g_object_get ((GtkWidget*) self->priv->fxdPartitioner, "width-request", &_tmp22_, NULL);
	g_object_set ((GtkWidget*) self, "width-request", _tmp22_, NULL);
	g_object_get ((GtkWidget*) self->priv->fxdPartitioner, "height-request", &_tmp23_, NULL);
	g_object_set ((GtkWidget*) self, "height-request", _tmp23_, NULL);
	exogenesis_fpartitioner_SetTreeColumns (self);
	exogenesis_fpartitioner_SetColumnWidths (self);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (cellHD);
	_g_object_unref0 (builder);
	goto __finally9;
	__catch9_g_error:
	{
		GError * err;
		gchar* _tmp24_;
		gchar* _tmp25_;
		GtkMessageDialog* _tmp26_ = NULL;
		GtkMessageDialog* _tmp27_;
		GtkMessageDialog* msg;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp24_ = g_strconcat ("Failed to load UI\n", err->message, NULL);
		_tmp25_ = _tmp24_;
		_tmp26_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CANCEL, _tmp25_);
		_tmp27_ = g_object_ref_sink (_tmp26_);
		_g_free0 (_tmp25_);
		msg = _tmp27_;
		gtk_dialog_run ((GtkDialog*) msg);
		gtk_main_quit ();
		_g_object_unref0 (msg);
		_g_error_free0 (err);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _lambda2_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFPartitioner* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_tree_store_set (self->priv->_lstPartitions, &iter, EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, !_tmp2_, -1);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda2__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda2_ (_sender, path, self);
}


static void _lambda3_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFPartitioner* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_tree_store_set (self->priv->_lstPartitions, &iter, EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, !_tmp2_, -1);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda3__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda3_ (_sender, path, self);
}


static void _exogenesis_fpartitioner_OnCellDelClicked_exogenesis_cell_renderer_button_clicked (ExogenesisCellRendererButton* _sender, const gchar* path, gpointer self) {
	exogenesis_fpartitioner_OnCellDelClicked (self, path);
}


static void exogenesis_fpartitioner_SetTreeColumns (ExogenesisFPartitioner* self) {
	GtkCellRendererToggle* _tmp0_ = NULL;
	GtkCellRendererToggle* togCellF;
	GtkCellRendererToggle* _tmp1_ = NULL;
	GtkCellRendererToggle* togCellU;
	ExogenesisCellRendererButton* _tmp2_ = NULL;
	ExogenesisCellRendererButton* cellButtonDel;
	GtkCellRendererText* _tmp3_ = NULL;
	GtkCellRendererText* _tmp4_;
	GtkCellRendererText* _tmp5_ = NULL;
	GtkCellRendererText* _tmp6_;
	GtkCellRendererText* _tmp7_ = NULL;
	GtkCellRendererText* _tmp8_;
	GtkCellRendererText* _tmp9_ = NULL;
	GtkCellRendererText* _tmp10_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
	togCellF = g_object_ref_sink (_tmp0_);
	g_signal_connect_object (togCellF, "toggled", (GCallback) __lambda2__gtk_cell_renderer_toggle_toggled, self, 0);
	_tmp1_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
	togCellU = g_object_ref_sink (_tmp1_);
	g_signal_connect_object (togCellU, "toggled", (GCallback) __lambda3__gtk_cell_renderer_toggle_toggled, self, 0);
	_tmp2_ = exogenesis_cell_renderer_button_new ();
	cellButtonDel = g_object_ref_sink (_tmp2_);
	g_signal_connect_object (cellButtonDel, "clicked", (GCallback) _exogenesis_fpartitioner_OnCellDelClicked_exogenesis_cell_renderer_button_clicked, self, 0);
	_tmp3_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp4_ = g_object_ref_sink (_tmp3_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Mount Point", (GtkCellRenderer*) _tmp4_, "text", EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, NULL, NULL);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp6_ = g_object_ref_sink (_tmp5_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Size", (GtkCellRenderer*) _tmp6_, "text", EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, NULL, NULL);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp8_ = g_object_ref_sink (_tmp7_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Type", (GtkCellRenderer*) _tmp8_, "text", EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, NULL, NULL);
	_g_object_unref0 (_tmp8_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Format", (GtkCellRenderer*) togCellF, "active", EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, NULL, NULL);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Use", (GtkCellRenderer*) togCellU, "active", EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, NULL, NULL);
	_tmp9_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp10_ = g_object_ref_sink (_tmp9_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Label", (GtkCellRenderer*) _tmp10_, "text", EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label, NULL, NULL);
	_g_object_unref0 (_tmp10_);
	gtk_tree_view_insert_column_with_attributes (self->priv->tvwPartitions, -1, "Delete", (GtkCellRenderer*) cellButtonDel, "stockicon", EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon, NULL, NULL);
	gtk_tree_view_set_model (self->priv->tvwPartitions, (GtkTreeModel*) self->priv->_lstPartitions);
	_g_object_unref0 (cellButtonDel);
	_g_object_unref0 (togCellU);
	_g_object_unref0 (togCellF);
}


static void exogenesis_fpartitioner_SetColumnWidths (ExogenesisFPartitioner* self) {
	GtkContainer* _tmp0_ = NULL;
	gint _tmp1_;
	gdouble _tmp2_;
	gint w;
	GtkTreeViewColumn* _tmp3_ = NULL;
	GtkTreeViewColumn* _tmp4_ = NULL;
	GtkTreeViewColumn* _tmp5_ = NULL;
	GtkTreeViewColumn* _tmp6_ = NULL;
	GtkTreeViewColumn* _tmp7_ = NULL;
	GtkTreeViewColumn* _tmp8_ = NULL;
	GtkTreeViewColumn* _tmp9_ = NULL;
	GtkTreeViewColumn* _tmp10_ = NULL;
	GtkTreeViewColumn* _tmp11_ = NULL;
	GtkTreeViewColumn* _tmp12_ = NULL;
	GtkTreeViewColumn* _tmp13_ = NULL;
	GtkTreeViewColumn* _tmp14_ = NULL;
	GtkTreeViewColumn* _tmp15_ = NULL;
	GtkTreeViewColumn* _tmp16_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self->priv->tvwPartitions);
	g_object_get ((GtkWidget*) _tmp0_, "width-request", &_tmp1_, NULL);
	_tmp2_ = round ((gdouble) (_tmp1_ / 100));
	w = (gint) _tmp2_;
	_tmp3_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_MountPoint);
	gtk_tree_view_column_set_sizing (_tmp3_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp4_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_MountPoint);
	gtk_tree_view_column_set_fixed_width (_tmp4_, w * 25);
	_tmp5_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_DisplaySize);
	gtk_tree_view_column_set_sizing (_tmp5_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp6_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_DisplaySize);
	gtk_tree_view_column_set_fixed_width (_tmp6_, w * 10);
	_tmp7_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType);
	gtk_tree_view_column_set_sizing (_tmp7_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp8_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType);
	gtk_tree_view_column_set_fixed_width (_tmp8_, w * 20);
	_tmp9_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_FormatFlag);
	gtk_tree_view_column_set_sizing (_tmp9_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp10_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_FormatFlag);
	gtk_tree_view_column_set_fixed_width (_tmp10_, w * 10);
	_tmp11_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_UseFlag);
	gtk_tree_view_column_set_sizing (_tmp11_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp12_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_UseFlag);
	gtk_tree_view_column_set_fixed_width (_tmp12_, w * 10);
	_tmp13_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_Label);
	gtk_tree_view_column_set_sizing (_tmp13_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp14_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_Label);
	gtk_tree_view_column_set_fixed_width (_tmp14_, w * 25);
	_tmp15_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_Remove);
	gtk_tree_view_column_set_sizing (_tmp15_, GTK_TREE_VIEW_COLUMN_FIXED);
	_tmp16_ = gtk_tree_view_get_column (self->priv->tvwPartitions, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_Remove);
	gtk_tree_view_column_set_fixed_width (_tmp16_, w * 10);
}


static void exogenesis_fpartitioner_ModelFromNewSelection (ExogenesisFPartitioner* self) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear (self->priv->_lstPartitions);
	_tmp0_ = exogenesis_install_data_get_HardDiskCount (exogenesis_gInstallData);
	if (_tmp0_ > 0) {
		{
			GeeIterator* _tmp1_ = NULL;
			GeeIterator* _iHD_it;
			_tmp1_ = gee_iterable_iterator ((GeeIterable*) exogenesis_gInstallData);
			_iHD_it = _tmp1_;
			while (TRUE) {
				gboolean _tmp2_;
				gpointer _tmp3_ = NULL;
				ExogenesisInstallHardDisk* iHD;
				GtkTreeIter iterDisk = {0};
				const gchar* _tmp4_ = NULL;
				ExogenesisHardDisk* _tmp5_ = NULL;
				ExogenesisHardDisk* hd;
				GtkTreeIter _tmp6_ = {0};
				const gchar* _tmp7_ = NULL;
				_tmp2_ = gee_iterator_next (_iHD_it);
				if (!_tmp2_) {
					break;
				}
				_tmp3_ = gee_iterator_get (_iHD_it);
				iHD = (ExogenesisInstallHardDisk*) _tmp3_;
				_tmp4_ = exogenesis_install_hard_disk_get_SerialNumber (iHD);
				_tmp5_ = exogenesis_hd_manager_GetHDBySerial (exogenesis_gHDManager, _tmp4_);
				hd = _tmp5_;
				gtk_tree_store_append (self->priv->_lstPartitions, &_tmp6_, NULL);
				iterDisk = _tmp6_;
				_tmp7_ = exogenesis_hard_disk_get_Model (hd);
				gtk_tree_store_set (self->priv->_lstPartitions, &iterDisk, EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, _tmp7_, EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, hd, -1, -1);
				{
					GeeIterator* _tmp8_ = NULL;
					GeeIterator* _ip_it;
					_tmp8_ = gee_iterable_iterator ((GeeIterable*) iHD);
					_ip_it = _tmp8_;
					while (TRUE) {
						gboolean _tmp9_;
						gpointer _tmp10_ = NULL;
						ExogenesisInstallPartition* ip;
						GtkTreeIter iterPart = {0};
						GtkTreeIter _tmp11_ = {0};
						const gchar* _tmp12_ = NULL;
						const gchar* _tmp13_ = NULL;
						const gchar* _tmp14_ = NULL;
						gboolean _tmp15_;
						gboolean _tmp16_;
						guint64 _tmp17_;
						const gchar* _tmp18_ = NULL;
						const gchar* _tmp19_ = NULL;
						gboolean _tmp20_;
						_tmp9_ = gee_iterator_next (_ip_it);
						if (!_tmp9_) {
							break;
						}
						_tmp10_ = gee_iterator_get (_ip_it);
						ip = (ExogenesisInstallPartition*) _tmp10_;
						gtk_tree_store_append (self->priv->_lstPartitions, &_tmp11_, &iterDisk);
						iterPart = _tmp11_;
						_tmp12_ = exogenesis_install_partition_get_MountPoint (ip);
						_tmp13_ = exogenesis_install_partition_get_Type (ip);
						_tmp14_ = exogenesis_install_partition_get_Label (ip);
						_tmp15_ = exogenesis_install_partition_get_Format (ip);
						_tmp16_ = exogenesis_install_partition_get_Use (ip);
						_tmp17_ = exogenesis_install_partition_get_ByteSize (ip);
						_tmp18_ = exogenesis_install_partition_get_TypeID (ip);
						_tmp19_ = exogenesis_install_partition_get_Device (ip);
						_tmp20_ = exogenesis_install_partition_get_NewPartition (ip);
						exogenesis_fpartitioner_PopulateListItem (self, &iterPart, _tmp12_, _tmp13_, hd, _tmp14_, _tmp15_, _tmp16_, "", _tmp17_, _tmp18_, _tmp19_, "", _tmp20_);
						{
							GeeIterator* _tmp21_ = NULL;
							GeeIterator* _p_it;
							_tmp21_ = gee_iterable_iterator ((GeeIterable*) ip);
							_p_it = _tmp21_;
							while (TRUE) {
								gboolean _tmp22_;
								gpointer _tmp23_ = NULL;
								ExogenesisInstallPartition* p;
								GtkTreeIter it = {0};
								GtkTreeIter _tmp24_ = {0};
								const gchar* _tmp25_ = NULL;
								const gchar* _tmp26_ = NULL;
								const gchar* _tmp27_ = NULL;
								gboolean _tmp28_;
								gboolean _tmp29_;
								guint64 _tmp30_;
								const gchar* _tmp31_ = NULL;
								const gchar* _tmp32_ = NULL;
								gboolean _tmp33_;
								_tmp22_ = gee_iterator_next (_p_it);
								if (!_tmp22_) {
									break;
								}
								_tmp23_ = gee_iterator_get (_p_it);
								p = (ExogenesisInstallPartition*) _tmp23_;
								gtk_tree_store_append (self->priv->_lstPartitions, &_tmp24_, &iterPart);
								it = _tmp24_;
								_tmp25_ = exogenesis_install_partition_get_MountPoint (p);
								_tmp26_ = exogenesis_install_partition_get_Type (p);
								_tmp27_ = exogenesis_install_partition_get_Label (p);
								_tmp28_ = exogenesis_install_partition_get_Format (p);
								_tmp29_ = exogenesis_install_partition_get_Use (p);
								_tmp30_ = exogenesis_install_partition_get_ByteSize (p);
								_tmp31_ = exogenesis_install_partition_get_TypeID (p);
								_tmp32_ = exogenesis_install_partition_get_Device (p);
								_tmp33_ = exogenesis_install_partition_get_NewPartition (p);
								exogenesis_fpartitioner_PopulateListItem (self, &it, _tmp25_, _tmp26_, hd, _tmp27_, _tmp28_, _tmp29_, "", _tmp30_, _tmp31_, _tmp32_, "", _tmp33_);
								_g_object_unref0 (p);
							}
							_g_object_unref0 (_p_it);
						}
						_g_object_unref0 (ip);
					}
					_g_object_unref0 (_ip_it);
				}
				_g_object_unref0 (hd);
				_g_object_unref0 (iHD);
			}
			_g_object_unref0 (_iHD_it);
		}
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


static void exogenesis_fpartitioner_ModelFromCurrentLayout (ExogenesisFPartitioner* self) {
	gint PartCount;
	gchar* label = NULL;
	ExogenesisHardDisk* _tmp0_ = NULL;
	ExogenesisHardDisk* hd;
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear (self->priv->_lstPartitions);
	PartCount = 0;
	_tmp0_ = exogenesis_fpartitioner_GetSelectedHD (self);
	hd = _tmp0_;
	if (hd != NULL) {
		GtkTreeIter iterDisk = {0};
		GtkTreeIter _tmp1_ = {0};
		const gchar* _tmp2_ = NULL;
		gtk_tree_store_append (self->priv->_lstPartitions, &_tmp1_, NULL);
		iterDisk = _tmp1_;
		_tmp2_ = exogenesis_hard_disk_get_Model (hd);
		gtk_tree_store_set (self->priv->_lstPartitions, &iterDisk, EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, _tmp2_, EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, hd, -1, -1);
		gtk_tree_store_set (self->priv->_lstPartitions, &iterDisk, EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon, GTK_STOCK_DELETE, -1, -1);
		{
			GeeIterator* _tmp3_ = NULL;
			GeeIterator* _pi_it;
			_tmp3_ = gee_iterable_iterator ((GeeIterable*) hd);
			_pi_it = _tmp3_;
			while (TRUE) {
				gboolean _tmp4_;
				gpointer _tmp5_ = NULL;
				ExogenesisPartitionInfo* pi;
				GtkTreeIter iterPart = {0};
				gboolean _tmp6_ = FALSE;
				const gchar* _tmp7_ = NULL;
				_tmp4_ = gee_iterator_next (_pi_it);
				if (!_tmp4_) {
					break;
				}
				_tmp5_ = gee_iterator_get (_pi_it);
				pi = (ExogenesisPartitionInfo*) _tmp5_;
				_tmp7_ = exogenesis_partition_info_get_OSType (pi);
				if (g_strcmp0 (_tmp7_, "") != 0) {
					const gchar* _tmp8_ = NULL;
					const gchar* _tmp9_ = NULL;
					_tmp8_ = exogenesis_partition_info_get_Device (pi);
					_tmp9_ = exogenesis_hard_disk_get_Device (hd);
					_tmp6_ = g_strcmp0 (_tmp8_, _tmp9_) != 0;
				} else {
					_tmp6_ = FALSE;
				}
				if (_tmp6_) {
					GtkTreeIter _tmp10_ = {0};
					const gchar* _tmp11_ = NULL;
					const gchar* _tmp12_ = NULL;
					const gchar* _tmp13_ = NULL;
					guint64 _tmp14_;
					const gchar* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					gtk_tree_store_append (self->priv->_lstPartitions, &_tmp10_, &iterDisk);
					iterPart = _tmp10_;
					_tmp11_ = exogenesis_partition_info_get_FSTabMountPoint (pi);
					_tmp12_ = exogenesis_partition_info_get_OSType (pi);
					_tmp13_ = exogenesis_partition_info_get_Label (pi);
					_tmp14_ = exogenesis_partition_info_get_Capacity (pi);
					_tmp15_ = exogenesis_partition_info_get_OSTypeID (pi);
					_tmp16_ = exogenesis_partition_info_get_Device (pi);
					exogenesis_fpartitioner_PopulateListItem (self, &iterPart, _tmp11_, _tmp12_, hd, _tmp13_, FALSE, FALSE, "", _tmp14_, _tmp15_, _tmp16_, "", FALSE);
					exogenesis_fpartitioner_UpdateSegbar (self, hd, pi, PartCount);
					PartCount++;
				} else {
					const gchar* _tmp17_ = NULL;
					gchar* _tmp18_ = NULL;
					gchar* _tmp19_;
					gboolean _tmp20_;
					gboolean _tmp21_;
					_tmp17_ = exogenesis_partition_info_get_PartitionType (pi);
					_tmp18_ = g_utf8_strdown (_tmp17_, (gssize) (-1));
					_tmp19_ = _tmp18_;
					_tmp20_ = string_contains (_tmp19_, "extended");
					_tmp21_ = _tmp20_;
					_g_free0 (_tmp19_);
					if (_tmp21_) {
						GtkTreeIter _tmp22_ = {0};
						const gchar* _tmp23_ = NULL;
						guint64 _tmp24_;
						const gchar* _tmp25_ = NULL;
						const gchar* _tmp26_ = NULL;
						gtk_tree_store_append (self->priv->_lstPartitions, &_tmp22_, &iterDisk);
						iterPart = _tmp22_;
						_tmp23_ = exogenesis_partition_info_get_Label (pi);
						_tmp24_ = exogenesis_partition_info_get_Capacity (pi);
						_tmp25_ = exogenesis_partition_info_get_OSTypeID (pi);
						_tmp26_ = exogenesis_partition_info_get_Device (pi);
						exogenesis_fpartitioner_PopulateListItem (self, &iterPart, "", "Extended", hd, _tmp23_, FALSE, FALSE, "", _tmp24_, _tmp25_, _tmp26_, "", FALSE);
						{
							GeeIterator* _tmp27_ = NULL;
							GeeIterator* _p_it;
							_tmp27_ = gee_iterable_iterator ((GeeIterable*) pi);
							_p_it = _tmp27_;
							while (TRUE) {
								gboolean _tmp28_;
								gpointer _tmp29_ = NULL;
								ExogenesisPartitionInfo* p;
								GtkTreeIter ti = {0};
								GtkTreeIter _tmp30_ = {0};
								const gchar* _tmp31_ = NULL;
								const gchar* _tmp32_ = NULL;
								const gchar* _tmp33_ = NULL;
								guint64 _tmp34_;
								const gchar* _tmp35_ = NULL;
								const gchar* _tmp36_ = NULL;
								_tmp28_ = gee_iterator_next (_p_it);
								if (!_tmp28_) {
									break;
								}
								_tmp29_ = gee_iterator_get (_p_it);
								p = (ExogenesisPartitionInfo*) _tmp29_;
								gtk_tree_store_append (self->priv->_lstPartitions, &_tmp30_, &iterPart);
								ti = _tmp30_;
								_tmp31_ = exogenesis_partition_info_get_FSTabMountPoint (p);
								_tmp32_ = exogenesis_partition_info_get_OSType (p);
								_tmp33_ = exogenesis_partition_info_get_Label (p);
								_tmp34_ = exogenesis_partition_info_get_Capacity (p);
								_tmp35_ = exogenesis_partition_info_get_OSTypeID (p);
								_tmp36_ = exogenesis_partition_info_get_Device (p);
								exogenesis_fpartitioner_PopulateListItem (self, &ti, _tmp31_, _tmp32_, hd, _tmp33_, FALSE, FALSE, "", _tmp34_, _tmp35_, _tmp36_, "", FALSE);
								exogenesis_fpartitioner_UpdateSegbar (self, hd, p, PartCount);
								PartCount++;
								_g_object_unref0 (p);
							}
							_g_object_unref0 (_p_it);
						}
					}
				}
				_g_object_unref0 (pi);
			}
			_g_object_unref0 (_pi_it);
		}
	}
	_g_object_unref0 (hd);
	_g_free0 (label);
}


static void exogenesis_fpartitioner_UpdateSegbar (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd, ExogenesisPartitionInfo* pi, gint PartCount) {
	gchar* label = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	guint64 _tmp3_;
	guint64 _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (pi != NULL);
	_tmp0_ = exogenesis_partition_info_get_OSType (pi);
	_tmp1_ = exogenesis_partition_info_get_CapacityDescription (pi);
	_tmp2_ = g_strdup_printf ("%s\n%s", _tmp0_, _tmp1_);
	_g_free0 (label);
	label = _tmp2_;
	_tmp3_ = exogenesis_hard_disk_get_Capacity (hd);
	_tmp4_ = exogenesis_partition_info_get_Capacity (pi);
	exogenesis_fpartitioner_AddToDisk (self, self->priv->segbarHD, _tmp3_, _tmp4_, label, PartCount);
	_g_free0 (label);
}


static void exogenesis_fpartitioner_PopulateListItem (ExogenesisFPartitioner* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mountpoint != NULL);
	g_return_if_fail (ostype != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (icon != NULL);
	g_return_if_fail (ostypeid != NULL);
	g_return_if_fail (device != NULL);
	g_return_if_fail (partitionid != NULL);
	_tmp0_ = exogenesis_general_functions_FormatHDSize (size);
	_tmp1_ = _tmp0_;
	gtk_tree_store_set (self->priv->_lstPartitions, iter, EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, mountpoint, EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, _tmp1_, EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, ostype, EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, hd, EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label, label, EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, format, EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, use, EXOGENESIS_FPARTITIONER_PARTITION_COLS_RemoveIcon, GTK_STOCK_DELETE, EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, size, EXOGENESIS_FPARTITIONER_PARTITION_COLS_FSTypeID, ostypeid, EXOGENESIS_FPARTITIONER_PARTITION_COLS_Device, device, EXOGENESIS_FPARTITIONER_PARTITION_COLS_PartitionID, partitionid, EXOGENESIS_FPARTITIONER_PARTITION_COLS_NewPartition, newpartition, -1, -1);
	_g_free0 (_tmp1_);
}


static void exogenesis_fpartitioner_AddToDisk (ExogenesisFPartitioner* self, SegmentedBar* bar, guint64 HDSize, guint64 PartitionSize, const gchar* title, gint count) {
	gdouble hdtotal;
	gdouble ptnsize;
	gdouble _tmp0_;
	gint percent;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (bar != NULL);
	g_return_if_fail (title != NULL);
	hdtotal = ((gdouble) (HDSize / 1024)) / 1024;
	ptnsize = ((gdouble) (PartitionSize / 1024)) / 1024;
	_tmp0_ = round ((ptnsize / hdtotal) * 100);
	percent = (gint) _tmp0_;
	segmented_bar_set_SegmentLabelSpacing (self->priv->segbarHD, 20);
	_tmp1_ = exogenesis_general_functions_BarColour (count);
	segmented_bar_AddSegmentRgb (self->priv->segbarHD, title, percent, _tmp1_);
}


static void exogenesis_fpartitioner_GetDiskInfo (ExogenesisFPartitioner* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->_lstDisks);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _d_list;
		gint _tmp1_;
		gint _d_size;
		gint _d_index;
		_tmp0_ = _g_object_ref0 (exogenesis_gHDManager->HardDisks);
		_d_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _d_list);
		_d_size = _tmp1_;
		_d_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* d;
			gboolean _tmp3_;
			_d_index = _d_index + 1;
			if (!(_d_index < _d_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _d_list, _d_index);
			d = (ExogenesisHardDisk*) _tmp2_;
			_tmp3_ = exogenesis_hard_disk_get_IsOptical (d);
			if (!_tmp3_) {
				GtkTreeIter _tmp4_ = {0};
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* displaytxt;
				gtk_list_store_append (self->priv->_lstDisks, &_tmp4_);
				iter = _tmp4_;
				_tmp5_ = exogenesis_hard_disk_get_Model (d);
				_tmp6_ = exogenesis_hard_disk_get_CapacityDescription (d);
				_tmp7_ = g_strdup_printf ("%s - %s", _tmp5_, _tmp6_);
				displaytxt = _tmp7_;
				gtk_list_store_set (self->priv->_lstDisks, &iter, 0, displaytxt, 1, d, -1, -1);
				_g_free0 (displaytxt);
			}
			_g_object_unref0 (d);
		}
		_g_object_unref0 (_d_list);
	}
	gtk_combo_box_set_active (self->priv->cboHD, 0);
}


static void exogenesis_fpartitioner_SetSelectedHD (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd) {
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstDisks, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp4_ = {0};
			if (!_tmp1_) {
				GtkTreeModel* _tmp2_ = NULL;
				gboolean _tmp3_;
				_tmp2_ = gtk_combo_box_get_model (self->priv->cboHD);
				_tmp3_ = gtk_tree_model_iter_next (_tmp2_, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstDisks, &iter, 1, &_tmp4_);
			G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
			val = _tmp4_;
			if (g_value_get_object (&val) == hd) {
				gtk_combo_box_set_active_iter (self->priv->cboHD, &iter);
				break;
			}
		}
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static ExogenesisHardDisk* exogenesis_fpartitioner_GetSelectedHD (ExogenesisFPartitioner* self) {
	ExogenesisHardDisk* result = NULL;
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	ExogenesisHardDisk* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_combo_box_get_active_iter (self->priv->cboHD, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstDisks, &iter, 1, &_tmp1_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp1_;
	_tmp2_ = _g_object_ref0 (g_value_get_object (&val));
	result = _tmp2_;
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return result;
}


gboolean exogenesis_fpartitioner_IsMountPointUsed (ExogenesisFPartitioner* self, const gchar* MountPoint) {
	gboolean result = FALSE;
	GtkTreeIter iter = {0};
	GValue hdVal = {0};
	GValue mp = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (MountPoint != NULL, FALSE);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			GtkTreeIter partIter = {0};
			gboolean _tmp4_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp3_;
			_tmp4_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
			if (_tmp4_) {
				gint _tmp5_;
				gint i;
				_tmp5_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				i = _tmp5_;
				{
					gint x;
					x = 0;
					{
						gboolean _tmp6_;
						_tmp6_ = TRUE;
						while (TRUE) {
							GtkTreeIter _tmp7_ = {0};
							GValue _tmp8_ = {0};
							gboolean _tmp9_ = FALSE;
							const gchar* _tmp10_ = NULL;
							gchar* _tmp11_ = NULL;
							gchar* _tmp12_;
							gboolean _tmp13_;
							if (!_tmp6_) {
								x++;
							}
							_tmp6_ = FALSE;
							if (!(x < i)) {
								break;
							}
							gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp7_, &iter, x);
							partIter = _tmp7_;
							gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, &_tmp8_);
							G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
							mp = _tmp8_;
							_tmp10_ = g_value_get_string (&mp);
							_tmp11_ = g_utf8_strdown (_tmp10_, (gssize) (-1));
							_tmp12_ = _tmp11_;
							_tmp13_ = g_strcmp0 (_tmp12_, MountPoint) == 0;
							_g_free0 (_tmp12_);
							if (_tmp13_) {
								_tmp9_ = g_strcmp0 (MountPoint, "none") != 0;
							} else {
								_tmp9_ = FALSE;
							}
							if (_tmp9_) {
								result = TRUE;
								G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
								G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
								return result;
							}
						}
					}
				}
			}
		}
	}
	result = FALSE;
	G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
	return result;
}


void exogenesis_fpartitioner_AddToTree (ExogenesisFPartitioner* self, ExogenesisFilesystemType* fstype, const gchar* mountpoint, guint64 size, const gchar* label, const gchar* partitionid) {
	GtkTreeIter iterDisk = {0};
	GtkTreeIter iterPart = {0};
	ExogenesisHardDisk* SelectedHD = NULL;
	GValue val = {0};
	ExogenesisHardDisk* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	GtkTreeIter _tmp5_ = {0};
	GtkTreeIter _tmp6_ = {0};
	GValue _tmp7_ = {0};
	guint64 _tmp8_;
	const gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gboolean _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fstype != NULL);
	g_return_if_fail (mountpoint != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (partitionid != NULL);
	_tmp0_ = exogenesis_fpartitioner_GetSelectedHD (self);
	_g_object_unref0 (SelectedHD);
	SelectedHD = _tmp0_;
	_tmp2_ = exogenesis_fpartitioner_HardDiskExists (self, SelectedHD, &_tmp1_);
	iterDisk = _tmp1_;
	if (!_tmp2_) {
		GtkTreeIter _tmp3_ = {0};
		const gchar* _tmp4_ = NULL;
		gtk_tree_store_append (self->priv->_lstPartitions, &_tmp3_, NULL);
		iterDisk = _tmp3_;
		_tmp4_ = exogenesis_hard_disk_get_Model (SelectedHD);
		gtk_tree_store_set (self->priv->_lstPartitions, &iterDisk, EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, _tmp4_, EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, SelectedHD, -1, -1);
	}
	exogenesis_fpartitioner_GetSelectedPartition (self, &_tmp5_);
	_tmp6_ = _tmp5_;
	iterPart = _tmp6_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iterPart, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp7_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp7_;
	_tmp8_ = g_value_get_uint64 (&val);
	if (size < _tmp8_) {
		guint64 _tmp9_;
		guint64 nSize;
		gchar* _tmp10_ = NULL;
		gchar* nDisplaySize;
		GtkTreeIter _tmp11_ = {0};
		_tmp9_ = g_value_get_uint64 (&val);
		nSize = _tmp9_ - size;
		_tmp10_ = exogenesis_general_functions_FormatHDSize (nSize);
		nDisplaySize = _tmp10_;
		gtk_tree_store_set (self->priv->_lstPartitions, &iterPart, EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, nDisplaySize, EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, nSize, -1);
		gtk_tree_store_insert_before (self->priv->_lstPartitions, &_tmp11_, NULL, &iterPart);
		iterPart = _tmp11_;
		_g_free0 (nDisplaySize);
	}
	_tmp12_ = exogenesis_filesystem_type_get_Name (fstype);
	_tmp13_ = exogenesis_filesystem_type_get_ID (fstype);
	_tmp14_ = exogenesis_hard_disk_get_Device (SelectedHD);
	exogenesis_fpartitioner_PopulateListItem (self, &iterPart, mountpoint, _tmp12_, SelectedHD, label, FALSE, TRUE, "", size, _tmp13_, _tmp14_, partitionid, TRUE);
	_tmp15_ = exogenesis_filesystem_type_get_ID (fstype);
	if (g_strcmp0 (_tmp15_, "0x05") == 0) {
		GtkTreeIter iterExt = {0};
		GtkTreeIter _tmp16_ = {0};
		const gchar* _tmp17_ = NULL;
		gtk_tree_store_append (self->priv->_lstPartitions, &_tmp16_, &iterPart);
		iterExt = _tmp16_;
		_tmp17_ = exogenesis_hard_disk_get_Device (SelectedHD);
		exogenesis_fpartitioner_PopulateListItem (self, &iterExt, "", "Unallocated", SelectedHD, "", FALSE, FALSE, "", size, "Unallocated", _tmp17_, "", TRUE);
	}
	gtk_tree_view_expand_all (self->priv->tvwPartitions);
	_tmp18_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoAfter);
	if (_tmp18_ == TRUE) {
		exogenesis_fpartitioner_HDDisplayAfter (self, SelectedHD);
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	_g_object_unref0 (SelectedHD);
}


static gboolean exogenesis_fpartitioner_HardDiskExists (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd, GtkTreeIter* iter) {
	GtkTreeIter _iter = {0};
	gboolean result = FALSE;
	GValue valHD = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (hd != NULL, FALSE);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	_iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &_iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &_iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
			valHD = _tmp3_;
			_tmp5_ = G_VALUE_HOLDS (&valHD, EXOGENESIS_TYPE_HARD_DISK);
			if (_tmp5_) {
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp6_ = exogenesis_hard_disk_get_SerialNumber (g_value_get_object (&valHD));
				_tmp7_ = exogenesis_hard_disk_get_SerialNumber (hd);
				_tmp4_ = g_strcmp0 (_tmp6_, _tmp7_) == 0;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				result = TRUE;
				G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
				if (iter) {
					*iter = _iter;
				}
				return result;
			}
		}
	}
	result = FALSE;
	G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
	if (iter) {
		*iter = _iter;
	}
	return result;
}


static guint64 exogenesis_fpartitioner_AvailablePartSize (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd) {
	guint64 result = 0ULL;
	GtkTreeIter iter = {0};
	guint64 Allocated;
	GValue size = {0};
	GValue hdVal = {0};
	GtkTreeIter _tmp0_ = {0};
	guint64 _tmp14_;
	guint64 available;
	guint64 _tmp15_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (hd != NULL, 0ULL);
	Allocated = (guint64) 0;
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp3_;
			_tmp5_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
			if (_tmp5_) {
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp6_ = exogenesis_hard_disk_get_SerialNumber (g_value_get_object (&hdVal));
				_tmp7_ = exogenesis_hard_disk_get_SerialNumber (hd);
				_tmp4_ = g_strcmp0 (_tmp6_, _tmp7_) == 0;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				GtkTreeIter partIter = {0};
				gboolean _tmp8_;
				_tmp8_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (_tmp8_) {
					gint _tmp9_;
					gint i;
					_tmp9_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
					i = _tmp9_;
					{
						gint x;
						x = 0;
						{
							gboolean _tmp10_;
							_tmp10_ = TRUE;
							while (TRUE) {
								GtkTreeIter _tmp11_ = {0};
								GValue _tmp12_ = {0};
								guint64 _tmp13_;
								if (!_tmp10_) {
									x++;
								}
								_tmp10_ = FALSE;
								if (!(x < i)) {
									break;
								}
								gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp11_, &iter, x);
								partIter = _tmp11_;
								gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp12_);
								G_IS_VALUE (&size) ? (g_value_unset (&size), NULL) : NULL;
								size = _tmp12_;
								_tmp13_ = g_value_get_uint64 (&size);
								Allocated = Allocated + _tmp13_;
							}
						}
					}
				}
			}
		}
	}
	_tmp14_ = exogenesis_hard_disk_get_Capacity (hd);
	available = _tmp14_ - Allocated;
	if (available >= 0) {
		_tmp15_ = available;
	} else {
		_tmp15_ = (guint64) 0;
	}
	result = _tmp15_;
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
	G_IS_VALUE (&size) ? (g_value_unset (&size), NULL) : NULL;
	return result;
}


static void exogenesis_fpartitioner_HDDisplayAfter (ExogenesisFPartitioner* self, ExogenesisHardDisk* hd) {
	GtkTreeIter iter = {0};
	guint64 _tmp0_;
	guint64 available;
	GValue hdVal = {0};
	GtkTreeIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	_tmp0_ = exogenesis_fpartitioner_AvailablePartSize (self, hd);
	available = _tmp0_;
	segmented_bar_RemoveAllSegments (self->priv->segbarHD);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp1_);
	iter = _tmp1_;
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			GValue _tmp4_ = {0};
			gboolean _tmp5_ = FALSE;
			gboolean _tmp6_;
			if (!_tmp2_) {
				gboolean _tmp3_;
				_tmp3_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp4_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp4_;
			_tmp6_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
			if (_tmp6_) {
				const gchar* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				_tmp7_ = exogenesis_hard_disk_get_SerialNumber (g_value_get_object (&hdVal));
				_tmp8_ = exogenesis_hard_disk_get_SerialNumber (hd);
				_tmp5_ = g_strcmp0 (_tmp7_, _tmp8_) == 0;
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				GtkTreeIter partIter = {0};
				gboolean _tmp9_;
				_tmp9_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (_tmp9_) {
					gint _tmp10_;
					gint i;
					_tmp10_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
					i = _tmp10_;
					{
						gint x;
						x = 0;
						{
							gboolean _tmp11_;
							_tmp11_ = TRUE;
							while (TRUE) {
								GtkTreeIter _tmp12_ = {0};
								gboolean _tmp13_;
								if (!_tmp11_) {
									x++;
								}
								_tmp11_ = FALSE;
								if (!(x < i)) {
									break;
								}
								gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp12_, &iter, x);
								partIter = _tmp12_;
								_tmp13_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
								if (_tmp13_) {
									{
										gint y;
										y = 0;
										{
											gboolean _tmp14_;
											_tmp14_ = TRUE;
											while (TRUE) {
												gint _tmp15_;
												GtkTreeIter it = {0};
												GtkTreeIter _tmp16_ = {0};
												if (!_tmp14_) {
													y++;
												}
												_tmp14_ = FALSE;
												_tmp15_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
												if (!(y < _tmp15_)) {
													break;
												}
												gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp16_, &partIter, y);
												it = _tmp16_;
												exogenesis_fpartitioner_PopulateFromExisting (self, &it, x + y, hd);
											}
										}
									}
								} else {
									exogenesis_fpartitioner_PopulateFromExisting (self, &partIter, x, hd);
								}
							}
						}
					}
				}
			}
		}
	}
	if (available > 1) {
		guint64 _tmp17_;
		_tmp17_ = exogenesis_hard_disk_get_Capacity (hd);
		exogenesis_fpartitioner_AddToDisk (self, self->priv->segbarHD, _tmp17_, available, "UNALLOCATED", 7);
	}
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
}


static void exogenesis_fpartitioner_PopulateFromExisting (ExogenesisFPartitioner* self, GtkTreeIter* iter, gint idx, ExogenesisHardDisk* hd) {
	GValue pSize = {0};
	GValue pType = {0};
	GValue pMount = {0};
	GValue pLabel = {0};
	GValue _tmp0_ = {0};
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	gchar* mount = NULL;
	gchar* fstype = NULL;
	gchar* label = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp19_;
	guint64 _tmp20_;
	guint64 _tmp21_;
	gchar* _tmp22_ = NULL;
	gchar* _tmp23_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, &_tmp0_);
	G_IS_VALUE (&pMount) ? (g_value_unset (&pMount), NULL) : NULL;
	pMount = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp1_);
	G_IS_VALUE (&pSize) ? (g_value_unset (&pSize), NULL) : NULL;
	pSize = _tmp1_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, &_tmp2_);
	G_IS_VALUE (&pType) ? (g_value_unset (&pType), NULL) : NULL;
	pType = _tmp2_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label, &_tmp3_);
	G_IS_VALUE (&pLabel) ? (g_value_unset (&pLabel), NULL) : NULL;
	pLabel = _tmp3_;
	_tmp5_ = g_value_get_string (&pType);
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_ = NULL;
		_tmp6_ = g_value_get_string (&pType);
		_tmp4_ = _tmp6_;
	} else {
		_tmp4_ = "";
	}
	_tmp7_ = g_strdup (_tmp4_);
	_g_free0 (fstype);
	fstype = _tmp7_;
	_tmp9_ = g_value_get_string (&pMount);
	if (_tmp9_ != NULL) {
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		_tmp10_ = g_value_get_string (&pMount);
		_tmp11_ = g_strconcat ("\n", _tmp10_, NULL);
		_g_free0 (_tmp8_);
		_tmp8_ = _tmp11_;
	} else {
		gchar* _tmp12_;
		_tmp12_ = g_strdup ("");
		_g_free0 (_tmp8_);
		_tmp8_ = _tmp12_;
	}
	_tmp13_ = g_strdup (_tmp8_);
	_g_free0 (mount);
	mount = _tmp13_;
	_tmp15_ = g_value_get_string (&pLabel);
	if (_tmp15_ != NULL) {
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_tmp16_ = g_value_get_string (&pLabel);
		_tmp17_ = g_strconcat ("\n", _tmp16_, NULL);
		_g_free0 (_tmp14_);
		_tmp14_ = _tmp17_;
	} else {
		gchar* _tmp18_;
		_tmp18_ = g_strdup ("");
		_g_free0 (_tmp14_);
		_tmp14_ = _tmp18_;
	}
	_tmp19_ = g_strdup (_tmp14_);
	_g_free0 (label);
	label = _tmp19_;
	_tmp20_ = exogenesis_hard_disk_get_Capacity (hd);
	_tmp21_ = g_value_get_uint64 (&pSize);
	_tmp22_ = g_strdup_printf ("%s%s%s", fstype, mount, label);
	_tmp23_ = _tmp22_;
	exogenesis_fpartitioner_AddToDisk (self, self->priv->segbarHD, _tmp20_, _tmp21_, _tmp23_, idx);
	_g_free0 (_tmp23_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp8_);
	_g_free0 (label);
	_g_free0 (fstype);
	_g_free0 (mount);
	G_IS_VALUE (&pLabel) ? (g_value_unset (&pLabel), NULL) : NULL;
	G_IS_VALUE (&pMount) ? (g_value_unset (&pMount), NULL) : NULL;
	G_IS_VALUE (&pType) ? (g_value_unset (&pType), NULL) : NULL;
	G_IS_VALUE (&pSize) ? (g_value_unset (&pSize), NULL) : NULL;
}


static void exogenesis_fpartitioner_AddInstallPartitions (ExogenesisFPartitioner* self) {
	GtkTreeIter iter = {0};
	GValue hdVal = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	exogenesis_install_data_ClearInstallDisks (exogenesis_gInstallData);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			gint _tmp3_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			_tmp3_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &iter);
			if (_tmp3_ == 0) {
				GValue _tmp4_ = {0};
				gboolean _tmp5_;
				gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp4_);
				G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
				hdVal = _tmp4_;
				_tmp5_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
				if (_tmp5_) {
					ExogenesisHardDisk* _tmp6_;
					ExogenesisHardDisk* hd;
					ExogenesisInstallHardDisk* _tmp7_ = NULL;
					ExogenesisInstallHardDisk* iHD;
					const gchar* _tmp8_ = NULL;
					const gchar* _tmp9_ = NULL;
					guint64 start;
					GtkTreeIter partIter = {0};
					gboolean _tmp10_;
					_tmp6_ = _g_object_ref0 (g_value_get_object (&hdVal));
					hd = _tmp6_;
					_tmp7_ = exogenesis_install_hard_disk_new ();
					iHD = _tmp7_;
					_tmp8_ = exogenesis_hard_disk_get_Device (hd);
					exogenesis_install_hard_disk_set_DeviceName (iHD, _tmp8_);
					_tmp9_ = exogenesis_hard_disk_get_SerialNumber (hd);
					exogenesis_install_hard_disk_set_SerialNumber (iHD, _tmp9_);
					start = (guint64) 1048576;
					_tmp10_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
					if (_tmp10_) {
						GValue vSize = {0};
						gint _tmp11_;
						gint i;
						_tmp11_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
						i = _tmp11_;
						{
							gint x;
							x = 0;
							{
								gboolean _tmp12_;
								_tmp12_ = TRUE;
								while (TRUE) {
									GtkTreeIter _tmp13_ = {0};
									gboolean _tmp14_ = FALSE;
									gboolean _tmp15_;
									if (!_tmp12_) {
										x++;
									}
									_tmp12_ = FALSE;
									if (!(x < i)) {
										break;
									}
									gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp13_, &iter, x);
									partIter = _tmp13_;
									_tmp15_ = exogenesis_fpartitioner_IsAllocated (self, &partIter);
									if (_tmp15_) {
										gint _tmp16_;
										_tmp16_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &partIter);
										_tmp14_ = _tmp16_ == 1;
									} else {
										_tmp14_ = FALSE;
									}
									if (_tmp14_) {
										GValue vUse = {0};
										ExogenesisInstallPartition* p;
										GValue _tmp17_ = {0};
										GValue _tmp18_ = {0};
										gboolean _tmp19_;
										gboolean _tmp21_;
										guint64 _tmp33_;
										p = NULL;
										gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp17_);
										G_IS_VALUE (&vSize) ? (g_value_unset (&vSize), NULL) : NULL;
										vSize = _tmp17_;
										gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, &_tmp18_);
										G_IS_VALUE (&vUse) ? (g_value_unset (&vUse), NULL) : NULL;
										vUse = _tmp18_;
										_tmp19_ = g_value_get_boolean (&vUse);
										if (_tmp19_) {
											ExogenesisInstallPartition* _tmp20_ = NULL;
											_tmp20_ = exogenesis_fpartitioner_PopulateInstallPartition (self, &partIter, start);
											_g_object_unref0 (p);
											p = _tmp20_;
										}
										_tmp21_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
										if (_tmp21_) {
											guint64 estart;
											GValue veSize = {0};
											GValue veUse = {0};
											estart = start;
											{
												gint y;
												y = 0;
												{
													gboolean _tmp22_;
													_tmp22_ = TRUE;
													while (TRUE) {
														gint _tmp23_;
														GtkTreeIter it = {0};
														GtkTreeIter _tmp24_ = {0};
														gboolean _tmp25_;
														if (!_tmp22_) {
															y++;
														}
														_tmp22_ = FALSE;
														_tmp23_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
														if (!(y < _tmp23_)) {
															break;
														}
														gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp24_, &partIter, y);
														it = _tmp24_;
														_tmp25_ = exogenesis_fpartitioner_IsAllocated (self, &it);
														if (_tmp25_) {
															GValue _tmp26_ = {0};
															GValue _tmp27_ = {0};
															gboolean _tmp28_ = FALSE;
															gboolean _tmp29_;
															guint64 _tmp32_;
															gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &it, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp26_);
															G_IS_VALUE (&veSize) ? (g_value_unset (&veSize), NULL) : NULL;
															veSize = _tmp26_;
															gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &it, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_UseFlag, &_tmp27_);
															G_IS_VALUE (&veUse) ? (g_value_unset (&veUse), NULL) : NULL;
															veUse = _tmp27_;
															_tmp29_ = g_value_get_boolean (&veUse);
															if (_tmp29_) {
																_tmp28_ = p != NULL;
															} else {
																_tmp28_ = FALSE;
															}
															if (_tmp28_) {
																ExogenesisInstallPartition* _tmp30_ = NULL;
																ExogenesisInstallPartition* _tmp31_;
																_tmp30_ = exogenesis_fpartitioner_PopulateInstallPartition (self, &it, estart);
																_tmp31_ = _tmp30_;
																exogenesis_install_partition_AddInstallPartition (p, _tmp31_);
																_g_object_unref0 (_tmp31_);
															}
															_tmp32_ = g_value_get_uint64 (&veSize);
															estart = estart + _tmp32_;
														}
													}
												}
											}
											G_IS_VALUE (&veUse) ? (g_value_unset (&veUse), NULL) : NULL;
											G_IS_VALUE (&veSize) ? (g_value_unset (&veSize), NULL) : NULL;
										}
										_tmp33_ = g_value_get_uint64 (&vSize);
										start = start + _tmp33_;
										exogenesis_install_hard_disk_AddPartition (iHD, p);
										_g_object_unref0 (p);
										p = NULL;
										_g_object_unref0 (p);
										G_IS_VALUE (&vUse) ? (g_value_unset (&vUse), NULL) : NULL;
									}
								}
							}
						}
						G_IS_VALUE (&vSize) ? (g_value_unset (&vSize), NULL) : NULL;
					}
					exogenesis_install_data_AddInstallDisk (exogenesis_gInstallData, iHD);
					_g_object_unref0 (iHD);
					iHD = NULL;
					_g_object_unref0 (iHD);
					_g_object_unref0 (hd);
				}
			}
		}
	}
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
}


static gboolean exogenesis_fpartitioner_IsAllocated (ExogenesisFPartitioner* self, GtkTreeIter* i) {
	gboolean result = FALSE;
	GValue val = {0};
	GValue _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, i, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, &_tmp0_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp0_;
	_tmp3_ = g_value_get_string (&val);
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = g_value_get_string (&val);
		_tmp2_ = g_strcmp0 (_tmp4_, "") == 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		_tmp5_ = g_value_get_string (&val);
		_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) (-1));
		_tmp7_ = _tmp6_;
		_tmp1_ = g_strcmp0 (_tmp7_, "unallocated") == 0;
		_g_free0 (_tmp7_);
	}
	if (_tmp1_) {
		result = FALSE;
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		return result;
	} else {
		result = TRUE;
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		return result;
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static ExogenesisInstallPartition* exogenesis_fpartitioner_PopulateInstallPartition (ExogenesisFPartitioner* self, GtkTreeIter* iter, guint64 start) {
	ExogenesisInstallPartition* result = NULL;
	GValue pVal = {0};
	ExogenesisInstallPartition* _tmp0_ = NULL;
	ExogenesisInstallPartition* ip;
	GValue _tmp1_ = {0};
	guint64 _tmp2_;
	GValue _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	GValue _tmp5_ = {0};
	const gchar* _tmp6_ = NULL;
	GValue _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	GValue _tmp9_ = {0};
	gboolean _tmp10_;
	GValue _tmp11_ = {0};
	gboolean _tmp12_;
	GValue _tmp13_ = {0};
	gboolean _tmp14_;
	GValue _tmp15_ = {0};
	const gchar* _tmp16_ = NULL;
	GValue _tmp17_ = {0};
	const gchar* _tmp18_ = NULL;
	GValue _tmp19_ = {0};
	const gchar* _tmp20_ = NULL;
	gboolean _tmp21_;
	guint64 _tmp23_;
	guint64 _tmp24_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = exogenesis_install_partition_new ();
	ip = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp1_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp1_;
	_tmp2_ = g_value_get_uint64 (&pVal);
	exogenesis_install_partition_set_ByteSize (ip, _tmp2_ - 1048576);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, &_tmp3_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp3_;
	_tmp4_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_DisplaySize (ip, _tmp4_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_Label, &_tmp5_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp5_;
	_tmp6_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_Label (ip, _tmp6_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_MountPoint, &_tmp7_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp7_;
	_tmp8_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_MountPoint (ip, _tmp8_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, &_tmp9_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp9_;
	_tmp10_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_Format (ip, _tmp10_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatFlag, &_tmp11_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp11_;
	_tmp12_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_Use (ip, _tmp12_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_NewPartition, &_tmp13_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp13_;
	_tmp14_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_NewPartition (ip, _tmp14_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, &_tmp15_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp15_;
	_tmp16_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_Type (ip, _tmp16_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FSTypeID, &_tmp17_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp17_;
	_tmp18_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_TypeID (ip, _tmp18_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_Device, &_tmp19_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp19_;
	_tmp21_ = G_VALUE_HOLDS (&pVal, G_TYPE_STRING);
	if (_tmp21_) {
		const gchar* _tmp22_ = NULL;
		_tmp22_ = g_value_get_string (&pVal);
		_tmp20_ = _tmp22_;
	} else {
		_tmp20_ = "";
	}
	exogenesis_install_partition_set_Device (ip, _tmp20_);
	exogenesis_install_partition_set_Start (ip, start);
	_tmp23_ = exogenesis_install_partition_get_Start (ip);
	_tmp24_ = exogenesis_install_partition_get_ByteSize (ip);
	exogenesis_install_partition_set_End (ip, _tmp23_ + _tmp24_);
	result = ip;
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	return result;
}


static void exogenesis_fpartitioner_DebugTree (ExogenesisFPartitioner* self) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			exogenesis_general_functions_LogIt ("ITER\n");
		}
	}
}


static void exogenesis_fpartitioner_GetSelectedPartition (ExogenesisFPartitioner* self, GtkTreeIter* result) {
	GtkTreeIter iter = {0};
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeSelection* _tmp1_;
	GtkTreeSelection* ts;
	GtkTreeIter _tmp2_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_view_get_selection (self->priv->tvwPartitions);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	ts = _tmp1_;
	gtk_tree_selection_get_selected (ts, NULL, &_tmp2_);
	iter = _tmp2_;
	*result = iter;
	_g_object_unref0 (ts);
	return;
}


void exogenesis_fpartitioner_OnCellDelClicked (ExogenesisFPartitioner* self, const gchar* path) {
	GtkTreeIter iter = {0};
	GValue val = {0};
	ExogenesisHardDisk* hd = NULL;
	guint64 available = 0ULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tp;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tp = _tmp0_;
	_tmp1_ = gtk_tree_path_get_depth (tp);
	if (_tmp1_ > 1) {
		GtkTreeIter _tmp2_ = {0};
		GValue _tmp3_ = {0};
		guint64 _tmp4_;
		GValue _tmp5_ = {0};
		ExogenesisHardDisk* _tmp6_;
		gboolean _tmp7_;
		const gchar* _tmp11_ = NULL;
		gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp2_, tp);
		iter = _tmp2_;
		gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp3_);
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		val = _tmp3_;
		_tmp4_ = g_value_get_uint64 (&val);
		available = _tmp4_;
		gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_HardDisk, &_tmp5_);
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		val = _tmp5_;
		_tmp6_ = _g_object_ref0 (g_value_get_object (&val));
		_g_object_unref0 (hd);
		hd = _tmp6_;
		_tmp7_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
		if (_tmp7_) {
			GtkTreeIter childIter = {0};
			gint i = 0;
			gint _tmp8_;
			_tmp8_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
			i = _tmp8_ - 1;
			{
				gint x;
				x = i;
				{
					gboolean _tmp9_;
					_tmp9_ = TRUE;
					while (TRUE) {
						GtkTreeIter _tmp10_ = {0};
						if (!_tmp9_) {
							x--;
						}
						_tmp9_ = FALSE;
						if (!(x > (-1))) {
							break;
						}
						gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp10_, &iter, x);
						childIter = _tmp10_;
						gtk_tree_store_remove (self->priv->_lstPartitions, &childIter);
					}
				}
			}
		}
		_tmp11_ = exogenesis_hard_disk_get_Device (hd);
		exogenesis_fpartitioner_PopulateListItem (self, &iter, "", "Unallocated", hd, "", FALSE, FALSE, "", available, "Unallocated", _tmp11_, "", TRUE);
		exogenesis_fpartitioner_RecalcUnallocated (self, &iter);
	}
	_gtk_tree_path_free0 (tp);
	_g_object_unref0 (hd);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static void exogenesis_fpartitioner_RecalcUnallocated (ExogenesisFPartitioner* self, GtkTreeIter* iter) {
	GtkTreeIter partIter = {0};
	GtkTreeIter diskIter = {0};
	GtkTreeIter parentIter = {0};
	GValue val = {0};
	gint _tmp0_;
	gint level;
	gint i = 0;
	gboolean bPreviousUnalloc;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, iter);
	level = _tmp0_;
	bPreviousUnalloc = FALSE;
	gtk_tree_model_iter_parent ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp1_, iter);
	parentIter = _tmp1_;
	_tmp2_ = gtk_tree_store_iter_is_valid (self->priv->_lstPartitions, &parentIter);
	if (_tmp2_) {
		gint _tmp3_;
		_tmp3_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &parentIter);
		i = _tmp3_ - 1;
		{
			gint x;
			x = i;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					GtkTreeIter _tmp5_ = {0};
					GValue _tmp6_ = {0};
					gboolean _tmp7_ = FALSE;
					const gchar* _tmp8_ = NULL;
					gchar* _tmp9_ = NULL;
					gchar* _tmp10_;
					gboolean _tmp11_;
					if (!_tmp4_) {
						x--;
					}
					_tmp4_ = FALSE;
					if (!(x > (-1))) {
						break;
					}
					gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp5_, &parentIter, x);
					partIter = _tmp5_;
					gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_TREE_COLS_FormatType, &_tmp6_);
					G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
					val = _tmp6_;
					_tmp8_ = g_value_get_string (&val);
					_tmp9_ = g_utf8_strdown (_tmp8_, (gssize) (-1));
					_tmp10_ = _tmp9_;
					_tmp11_ = g_strcmp0 (_tmp10_, "unallocated") == 0;
					_g_free0 (_tmp10_);
					if (_tmp11_) {
						gint _tmp12_;
						_tmp12_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &partIter);
						_tmp7_ = _tmp12_ == level;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						GValue _tmp13_ = {0};
						guint64 _tmp14_;
						guint64 partsize;
						gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp13_);
						G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
						val = _tmp13_;
						_tmp14_ = g_value_get_uint64 (&val);
						partsize = _tmp14_;
						if (bPreviousUnalloc) {
							guint64 available;
							guint64 total = 0ULL;
							GtkTreeIter nextIter = {0};
							GtkTreeIter _tmp15_ = {0};
							GValue _tmp16_ = {0};
							guint64 _tmp17_;
							GValue _tmp18_ = {0};
							gchar* _tmp19_ = NULL;
							GValue _tmp20_ = {0};
							available = (guint64) 0;
							gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp15_, &parentIter, x + 1);
							nextIter = _tmp15_;
							gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &nextIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp16_);
							G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
							val = _tmp16_;
							_tmp17_ = g_value_get_uint64 (&val);
							available = available + _tmp17_;
							total = available + partsize;
							g_value_init (&_tmp18_, G_TYPE_UINT64);
							g_value_set_uint64 (&_tmp18_, total);
							gtk_tree_store_set_value (self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp18_);
							G_IS_VALUE (&_tmp18_) ? (g_value_unset (&_tmp18_), NULL) : NULL;
							_tmp19_ = exogenesis_general_functions_FormatHDSize (total);
							g_value_init (&_tmp20_, G_TYPE_STRING);
							g_value_take_string (&_tmp20_, _tmp19_);
							gtk_tree_store_set_value (self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_DisplaySize, &_tmp20_);
							G_IS_VALUE (&_tmp20_) ? (g_value_unset (&_tmp20_), NULL) : NULL;
							gtk_tree_store_remove (self->priv->_lstPartitions, &nextIter);
						}
						bPreviousUnalloc = TRUE;
					} else {
						bPreviousUnalloc = FALSE;
					}
				}
			}
		}
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


gboolean exogenesis_fpartitioner_TvwPartitions_RowClick (ExogenesisFPartitioner* self, GdkEventButton* evt) {
	gboolean result = FALSE;
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeSelection* _tmp0_ = NULL;
	GtkTreeSelection* _tmp1_;
	GtkTreeSelection* ts;
	GtkTreeIter _tmp2_ = {0};
	gboolean enabled;
	GValue _tmp3_ = {0};
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gboolean _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gtk_tree_view_get_selection (self->priv->tvwPartitions);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	ts = _tmp1_;
	gtk_tree_selection_get_selected (ts, NULL, &_tmp2_);
	iter = _tmp2_;
	enabled = FALSE;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_FormatType, &_tmp3_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp3_;
	_tmp5_ = g_value_get_string (&val);
	_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) (-1));
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strcmp0 (_tmp7_, "unallocated") == 0;
	_g_free0 (_tmp7_);
	if (_tmp8_) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		_tmp9_ = g_value_get_string (&val);
		_tmp10_ = g_utf8_strdown (_tmp9_, (gssize) (-1));
		_tmp11_ = _tmp10_;
		_tmp4_ = g_strcmp0 (_tmp11_, "extended partition") == 0;
		_g_free0 (_tmp11_);
	}
	if (_tmp4_) {
		enabled = TRUE;
	}
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->btnCreatePart, enabled);
	result = FALSE;
	_g_object_unref0 (ts);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return result;
}


void exogenesis_fpartitioner_OnBtnApply_Click (ExogenesisFPartitioner* self) {
	GtkContainer* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	exogenesis_fpartitioner_AddInstallPartitions (self);
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


void exogenesis_fpartitioner_OnRdoBefore_Click (ExogenesisFPartitioner* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoBefore);
	if (_tmp0_ == TRUE) {
		exogenesis_fpartitioner_OnCboHD_Changed (self);
	}
}


void exogenesis_fpartitioner_OnRdoAfter_Click (ExogenesisFPartitioner* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoAfter);
	if (_tmp0_ == TRUE) {
		gint _tmp1_;
		ExogenesisHardDisk* _tmp2_ = NULL;
		ExogenesisHardDisk* _tmp3_;
		_tmp1_ = exogenesis_install_data_get_HardDiskCount (exogenesis_gInstallData);
		if (_tmp1_ == 0) {
			exogenesis_fpartitioner_AddInstallPartitions (self);
		}
		exogenesis_fpartitioner_ModelFromNewSelection (self);
		_tmp2_ = exogenesis_fpartitioner_GetSelectedHD (self);
		_tmp3_ = _tmp2_;
		exogenesis_fpartitioner_HDDisplayAfter (self, _tmp3_);
		_g_object_unref0 (_tmp3_);
		gtk_tree_view_expand_all (self->priv->tvwPartitions);
	}
}


void exogenesis_fpartitioner_OnBtnCreatePartition_Click (ExogenesisFPartitioner* self) {
	GtkTreeIter _tmp0_ = {0};
	GtkTreeIter _tmp1_ = {0};
	GtkTreeIter iter;
	GValue val = {0};
	GValue _tmp2_ = {0};
	g_return_if_fail (self != NULL);
	exogenesis_fpartitioner_GetSelectedPartition (self, &_tmp0_);
	_tmp1_ = _tmp0_;
	iter = _tmp1_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FPARTITIONER_PARTITION_COLS_ByteSize, &_tmp2_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp2_;
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


void exogenesis_fpartitioner_OnBtnCancel_Click (ExogenesisFPartitioner* self) {
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* msg;
	gint _tmp1_;
	GtkResponseType res;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, "Do your really wish to cancel and return to the previous screen?");
	msg = g_object_ref_sink (_tmp0_);
	_tmp1_ = gtk_dialog_run ((GtkDialog*) msg);
	res = (GtkResponseType) _tmp1_;
	if (res == GTK_RESPONSE_YES) {
		GtkContainer* _tmp2_ = NULL;
		gtk_widget_destroy ((GtkWidget*) msg);
		_tmp2_ = gtk_widget_get_parent ((GtkWidget*) self);
		gtk_widget_destroy ((GtkWidget*) _tmp2_);
	}
	_g_object_unref0 (msg);
}


void exogenesis_fpartitioner_OnCboHD_Changed (ExogenesisFPartitioner* self) {
	ExogenesisHardDisk* di = NULL;
	ExogenesisHardDisk* _tmp0_ = NULL;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	segmented_bar_RemoveAllSegments (self->priv->segbarHD);
	_tmp0_ = exogenesis_fpartitioner_GetSelectedHD (self);
	_g_object_unref0 (di);
	di = _tmp0_;
	_tmp1_ = TRUE;
	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->rdoBefore, _tmp1_);
	if (_tmp1_) {
		exogenesis_fpartitioner_ModelFromCurrentLayout (self);
	} else {
		gint _tmp2_;
		_tmp2_ = exogenesis_install_data_get_HardDiskCount (exogenesis_gInstallData);
		if (_tmp2_ > 0) {
			exogenesis_fpartitioner_ModelFromNewSelection (self);
		} else {
			exogenesis_fpartitioner_ModelFromCurrentLayout (self);
		}
	}
	gtk_tree_view_expand_all (self->priv->tvwPartitions);
	_g_object_unref0 (di);
}


static void exogenesis_fpartitioner_class_init (ExogenesisFPartitionerClass * klass) {
	exogenesis_fpartitioner_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisFPartitionerPrivate));
	G_OBJECT_CLASS (klass)->finalize = exogenesis_fpartitioner_finalize;
}


static void exogenesis_fpartitioner_instance_init (ExogenesisFPartitioner * self) {
	GtkTreeStore* _tmp0_ = NULL;
	GtkListStore* _tmp1_ = NULL;
	self->priv = EXOGENESIS_FPARTITIONER_GET_PRIVATE (self);
	_tmp0_ = gtk_tree_store_new (13, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, EXOGENESIS_TYPE_HARD_DISK, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_UINT64, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN);
	self->priv->_lstPartitions = _tmp0_;
	_tmp1_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_HARD_DISK);
	self->priv->_lstDisks = _tmp1_;
}


static void exogenesis_fpartitioner_finalize (GObject* obj) {
	ExogenesisFPartitioner * self;
	self = EXOGENESIS_FPARTITIONER (obj);
	_g_object_unref0 (self->priv->fxdPartitioner);
	_g_object_unref0 (self->priv->cboHD);
	_g_object_unref0 (self->priv->tvwPartitions);
	_g_object_unref0 (self->priv->vboxHD);
	_g_object_unref0 (self->priv->btnCreatePart);
	_g_object_unref0 (self->priv->rdoBefore);
	_g_object_unref0 (self->priv->rdoAfter);
	_g_object_unref0 (self->priv->btnApply);
	_g_object_unref0 (self->priv->btnCancel);
	_g_object_unref0 (self->priv->segbarHD);
	_g_object_unref0 (self->priv->_lstPartitions);
	_g_object_unref0 (self->priv->_lstDisks);
	G_OBJECT_CLASS (exogenesis_fpartitioner_parent_class)->finalize (obj);
}


GType exogenesis_fpartitioner_get_type (void) {
	static volatile gsize exogenesis_fpartitioner_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fpartitioner_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisFPartitionerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_fpartitioner_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisFPartitioner), 0, (GInstanceInitFunc) exogenesis_fpartitioner_instance_init, NULL };
		GType exogenesis_fpartitioner_type_id;
		exogenesis_fpartitioner_type_id = g_type_register_static (GTK_TYPE_LAYOUT, "ExogenesisFPartitioner", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_fpartitioner_type_id__volatile, exogenesis_fpartitioner_type_id);
	}
	return exogenesis_fpartitioner_type_id__volatile;
}



