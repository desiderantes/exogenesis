/* exoFHDconfigAdvanced.c generated by valac 0.12.1, the Vala compiler
 * generated from exoFHDconfigAdvanced.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* exogenesis
 *
 * Copyright (C) Steve Wood 2012 <steve.wood@inixsys.com>
 *
exogenesis is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * exogenesis is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <stdio.h>
#include <float.h>
#include <math.h>


#define EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED (exogenesis_fhd_config_advanced_get_type ())
#define EXOGENESIS_FHD_CONFIG_ADVANCED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvanced))
#define EXOGENESIS_FHD_CONFIG_ADVANCED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvancedClass))
#define EXOGENESIS_IS_FHD_CONFIG_ADVANCED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED))
#define EXOGENESIS_IS_FHD_CONFIG_ADVANCED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED))
#define EXOGENESIS_FHD_CONFIG_ADVANCED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvancedClass))

typedef struct _ExogenesisFHDConfigAdvanced ExogenesisFHDConfigAdvanced;
typedef struct _ExogenesisFHDConfigAdvancedClass ExogenesisFHDConfigAdvancedClass;
typedef struct _ExogenesisFHDConfigAdvancedPrivate ExogenesisFHDConfigAdvancedPrivate;

#define TYPE_SEGMENTED_BAR (segmented_bar_get_type ())
#define SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SEGMENTED_BAR, SegmentedBar))
#define SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SEGMENTED_BAR, SegmentedBarClass))
#define IS_SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SEGMENTED_BAR))
#define IS_SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SEGMENTED_BAR))
#define SEGMENTED_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SEGMENTED_BAR, SegmentedBarClass))

typedef struct _SegmentedBar SegmentedBar;
typedef struct _SegmentedBarClass SegmentedBarClass;

#define EXOGENESIS_FHD_CONFIG_ADVANCED_TYPE_PARTITION_COLS (exogenesis_fhd_config_advanced_partition_cols_get_type ())

#define EXOGENESIS_FHD_CONFIG_ADVANCED_TYPE_TREE_COLS (exogenesis_fhd_config_advanced_tree_cols_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_HARD_DISK (exogenesis_hard_disk_get_type ())
#define EXOGENESIS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDisk))
#define EXOGENESIS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))
#define EXOGENESIS_IS_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_IS_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HARD_DISK))
#define EXOGENESIS_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HARD_DISK, ExogenesisHardDiskClass))

typedef struct _ExogenesisHardDisk ExogenesisHardDisk;
typedef struct _ExogenesisHardDiskClass ExogenesisHardDiskClass;

#define EXOGENESIS_TYPE_PARTITION_INFO (exogenesis_partition_info_get_type ())
#define EXOGENESIS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfo))
#define EXOGENESIS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))
#define EXOGENESIS_IS_PARTITION_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_IS_PARTITION_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PARTITION_INFO))
#define EXOGENESIS_PARTITION_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PARTITION_INFO, ExogenesisPartitionInfoClass))

typedef struct _ExogenesisPartitionInfo ExogenesisPartitionInfo;
typedef struct _ExogenesisPartitionInfoClass ExogenesisPartitionInfoClass;

#define EXOGENESIS_TYPE_INSTALL_HARD_DISK (exogenesis_install_hard_disk_get_type ())
#define EXOGENESIS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDisk))
#define EXOGENESIS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))
#define EXOGENESIS_IS_INSTALL_HARD_DISK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_IS_INSTALL_HARD_DISK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_HARD_DISK))
#define EXOGENESIS_INSTALL_HARD_DISK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_HARD_DISK, ExogenesisInstallHardDiskClass))

typedef struct _ExogenesisInstallHardDisk ExogenesisInstallHardDisk;
typedef struct _ExogenesisInstallHardDiskClass ExogenesisInstallHardDiskClass;

#define EXOGENESIS_TYPE_INSTALL_PARTITION (exogenesis_install_partition_get_type ())
#define EXOGENESIS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartition))
#define EXOGENESIS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))
#define EXOGENESIS_IS_INSTALL_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_IS_INSTALL_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_PARTITION))
#define EXOGENESIS_INSTALL_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_PARTITION, ExogenesisInstallPartitionClass))

typedef struct _ExogenesisInstallPartition ExogenesisInstallPartition;
typedef struct _ExogenesisInstallPartitionClass ExogenesisInstallPartitionClass;

#define EXOGENESIS_TYPE_FILESYSTEM_TYPE (exogenesis_filesystem_type_get_type ())
#define EXOGENESIS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemType))
#define EXOGENESIS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))
#define EXOGENESIS_IS_FILESYSTEM_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_IS_FILESYSTEM_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FILESYSTEM_TYPE))
#define EXOGENESIS_FILESYSTEM_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FILESYSTEM_TYPE, ExogenesisFilesystemTypeClass))

typedef struct _ExogenesisFilesystemType ExogenesisFilesystemType;
typedef struct _ExogenesisFilesystemTypeClass ExogenesisFilesystemTypeClass;

#define EXOGENESIS_TYPE_MOUNT_POINT (exogenesis_mount_point_get_type ())
#define EXOGENESIS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPoint))
#define EXOGENESIS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))
#define EXOGENESIS_IS_MOUNT_POINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_IS_MOUNT_POINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINT))
#define EXOGENESIS_MOUNT_POINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINT, ExogenesisMountPointClass))

typedef struct _ExogenesisMountPoint ExogenesisMountPoint;
typedef struct _ExogenesisMountPointClass ExogenesisMountPointClass;

#define EXOGENESIS_TYPE_HD_MANAGER (exogenesis_hd_manager_get_type ())
#define EXOGENESIS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManager))
#define EXOGENESIS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))
#define EXOGENESIS_IS_HD_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_IS_HD_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_HD_MANAGER))
#define EXOGENESIS_HD_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_HD_MANAGER, ExogenesisHDManagerClass))

typedef struct _ExogenesisHDManager ExogenesisHDManager;
typedef struct _ExogenesisHDManagerClass ExogenesisHDManagerClass;
typedef struct _ExogenesisHDManagerPrivate ExogenesisHDManagerPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define EXOGENESIS_TYPE_PREVIOUS_OS (exogenesis_previous_os_get_type ())
#define EXOGENESIS_PREVIOUS_OS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOS))
#define EXOGENESIS_PREVIOUS_OS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOSClass))
#define EXOGENESIS_IS_PREVIOUS_OS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_PREVIOUS_OS))
#define EXOGENESIS_IS_PREVIOUS_OS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_PREVIOUS_OS))
#define EXOGENESIS_PREVIOUS_OS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_PREVIOUS_OS, ExogenesisPreviousOSClass))

typedef struct _ExogenesisPreviousOS ExogenesisPreviousOS;
typedef struct _ExogenesisPreviousOSClass ExogenesisPreviousOSClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define EXOGENESIS_TYPE_MOUNT_POINTS (exogenesis_mount_points_get_type ())
#define EXOGENESIS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPoints))
#define EXOGENESIS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))
#define EXOGENESIS_IS_MOUNT_POINTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_IS_MOUNT_POINTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MOUNT_POINTS))
#define EXOGENESIS_MOUNT_POINTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MOUNT_POINTS, ExogenesisMountPointsClass))

typedef struct _ExogenesisMountPoints ExogenesisMountPoints;
typedef struct _ExogenesisMountPointsClass ExogenesisMountPointsClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))

#define EXOGENESIS_TYPE_CELL_RENDERER_BUTTON (exogenesis_cell_renderer_button_get_type ())
#define EXOGENESIS_CELL_RENDERER_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButton))
#define EXOGENESIS_CELL_RENDERER_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButtonClass))
#define EXOGENESIS_IS_CELL_RENDERER_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON))
#define EXOGENESIS_IS_CELL_RENDERER_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON))
#define EXOGENESIS_CELL_RENDERER_BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_CELL_RENDERER_BUTTON, ExogenesisCellRendererButtonClass))

typedef struct _ExogenesisCellRendererButton ExogenesisCellRendererButton;
typedef struct _ExogenesisCellRendererButtonClass ExogenesisCellRendererButtonClass;

#define EXOGENESIS_TYPE_INSTALL_DATA (exogenesis_install_data_get_type ())
#define EXOGENESIS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallData))
#define EXOGENESIS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))
#define EXOGENESIS_IS_INSTALL_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_IS_INSTALL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_INSTALL_DATA))
#define EXOGENESIS_INSTALL_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_INSTALL_DATA, ExogenesisInstallDataClass))

typedef struct _ExogenesisInstallData ExogenesisInstallData;
typedef struct _ExogenesisInstallDataClass ExogenesisInstallDataClass;

#define EXOGENESIS_TYPE_FCREATE_PARTITION (exogenesis_fcreate_partition_get_type ())
#define EXOGENESIS_FCREATE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartition))
#define EXOGENESIS_FCREATE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartitionClass))
#define EXOGENESIS_IS_FCREATE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION))
#define EXOGENESIS_IS_FCREATE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FCREATE_PARTITION))
#define EXOGENESIS_FCREATE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FCREATE_PARTITION, ExogenesisFCreatePartitionClass))

typedef struct _ExogenesisFCreatePartition ExogenesisFCreatePartition;
typedef struct _ExogenesisFCreatePartitionClass ExogenesisFCreatePartitionClass;

struct _ExogenesisFHDConfigAdvanced {
	GtkBox parent_instance;
	ExogenesisFHDConfigAdvancedPrivate * priv;
};

struct _ExogenesisFHDConfigAdvancedClass {
	GtkBoxClass parent_class;
};

struct _ExogenesisFHDConfigAdvancedPrivate {
	GtkBox* boxHDAdvanced;
	GtkBox* boxHDAHead;
	GtkLabel* lblHDAdvancedTitle;
	GtkImage* imgHD2;
	GtkSeparator* sepHD2;
	GtkBox* boxHD2Main;
	GtkButton* btnHDAPrevious;
	GtkImage* imgBtnHDAPrevious;
	GtkBox* boxHDADetails;
	GtkBox* boxHDAHardDisk;
	GtkLabel* lblHDADrives;
	GtkComboBox* cboHDADrives;
	GtkButton* btnHDAAddPartition;
	GtkBox* boxBtnAddPartition;
	GtkImage* imgBtnHDAAddPartition;
	GtkLabel* lblBtnHDAAddPartition;
	GtkBox* boxHDWidget;
	GtkScrolledWindow* sclHDALayout;
	GtkTreeView* trvHDALayout;
	GtkTreeSelection* selHDALayout;
	GtkGrid* grdHDAButtons;
	GtkButton* btnHDAApply;
	GtkButton* btnHDARevert;
	GtkLabel* lblPrevious;
	GtkRadioButton* rdoHDBefore;
	GtkRadioButton* rdoHDAfter;
	SegmentedBar* segbarHD;
	GtkListStore* _lstDisks;
	GtkTreeStore* _lstPartitions;
	GtkTreeStore* _lstNewPartitions;
	GtkListStore* _lstPartTypes;
	GtkListStore* _lstMountPoints;
};

typedef enum  {
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint = 0,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_PartitionID,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition,
	EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Partition
} ExogenesisFHDConfigAdvancedPartitionCols;

typedef enum  {
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_HardDisk = 0,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_MountPoint = 1,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatType = 2,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_DisplaySize = 3,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatFlag = 4,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_UseFlag = 5,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Label = 6,
	EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Remove = 7
} ExogenesisFHDConfigAdvancedTreeCols;

struct _ExogenesisHDManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisHDManagerPrivate * priv;
	gboolean ThreadStop;
	gboolean PartitionerRunning;
	GeeArrayList* HardDisks;
};

struct _ExogenesisHDManagerClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisHDManager *self);
};


static gpointer exogenesis_fhd_config_advanced_parent_class = NULL;
extern ExogenesisHDManager* exogenesis_gHDManager;
extern gchar* exogenesis_AppPath;
extern ExogenesisPreviousOS* exogenesis_gPreviousOS;
extern ExogenesisInstallData* exogenesis_gInstallData;

GType exogenesis_fhd_config_advanced_get_type (void) G_GNUC_CONST;
GType segmented_bar_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_FHD_CONFIG_ADVANCED_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED, ExogenesisFHDConfigAdvancedPrivate))
enum  {
	EXOGENESIS_FHD_CONFIG_ADVANCED_DUMMY_PROPERTY
};
static GType exogenesis_fhd_config_advanced_partition_cols_get_type (void) G_GNUC_UNUSED;
static GType exogenesis_fhd_config_advanced_tree_cols_get_type (void) G_GNUC_UNUSED;
GType exogenesis_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_partition_info_get_type (void) G_GNUC_CONST;
GType exogenesis_install_hard_disk_get_type (void) G_GNUC_CONST;
GType exogenesis_install_partition_get_type (void) G_GNUC_CONST;
GType exogenesis_filesystem_type_get_type (void) G_GNUC_CONST;
GType exogenesis_mount_point_get_type (void) G_GNUC_CONST;
ExogenesisFHDConfigAdvanced* exogenesis_fhd_config_advanced_new (void);
ExogenesisFHDConfigAdvanced* exogenesis_fhd_config_advanced_construct (GType object_type);
static void exogenesis_fhd_config_advanced_GetMountPoints (ExogenesisFHDConfigAdvanced* self);
static void exogenesis_fhd_config_advanced_GetDiskInfo (ExogenesisFHDConfigAdvanced* self);
static void exogenesis_fhd_config_advanced_CopyOldSchemaToNew (ExogenesisFHDConfigAdvanced* self);
static void exogenesis_fhd_config_advanced_Build (ExogenesisFHDConfigAdvanced* self);
gpointer exogenesis_hd_manager_ref (gpointer instance);
void exogenesis_hd_manager_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_hd_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_hd_manager (GValue* value, gpointer v_object);
void exogenesis_value_take_hd_manager (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_hd_manager (const GValue* value);
GType exogenesis_hd_manager_get_type (void) G_GNUC_CONST;
gint exogenesis_hd_manager_get_HardDiskCount (ExogenesisHDManager* self);
static void exogenesis_fhd_config_advanced_SetSelectedHD (ExogenesisFHDConfigAdvanced* self, ExogenesisHardDisk* hd);
static void exogenesis_fhd_config_advanced_OnDriveMounted (ExogenesisFHDConfigAdvanced* self, const gchar* mountpoint);
static void _exogenesis_fhd_config_advanced_OnDriveMounted_exogenesis_hd_manager_drive_mounted (ExogenesisHDManager* _sender, const gchar* mountpoint, gpointer self);
void exogenesis_fhd_config_advanced_OnDeviceConnected (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_drive_un_mounted (ExogenesisHDManager* _sender, gpointer self);
static void _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_devices_refreshed (ExogenesisHDManager* _sender, gpointer self);
void exogenesis_fhd_config_advanced_OnCboHD_Changed (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnCboHD_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
void exogenesis_fhd_config_advanced_OnRdoAfter_Click (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnRdoAfter_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
void exogenesis_fhd_config_advanced_OnRdoBefore_Click (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnRdoBefore_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void exogenesis_fhd_config_advanced_OnRealized (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnRealized_gtk_widget_realize (GtkWidget* _sender, gpointer self);
void exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click (ExogenesisFHDConfigAdvanced* self);
static void _exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click_gtk_button_clicked (GtkButton* _sender, gpointer self);
SegmentedBar* segmented_bar_new (void);
SegmentedBar* segmented_bar_construct (GType object_type);
void segmented_bar_set_BarHeight (SegmentedBar* self, gint value);
gint segmented_bar_get_BarHeight (SegmentedBar* self);
void segmented_bar_set_HorizontalPadding (SegmentedBar* self, gint value);
void segmented_bar_set_ShowReflection (SegmentedBar* self, gboolean value);
static void exogenesis_fhd_config_advanced_SetTreeColumns (ExogenesisFHDConfigAdvanced* self);
gpointer exogenesis_previous_os_ref (gpointer instance);
void exogenesis_previous_os_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_previous_os (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_previous_os (GValue* value, gpointer v_object);
void exogenesis_value_take_previous_os (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_previous_os (const GValue* value);
GType exogenesis_previous_os_get_type (void) G_GNUC_CONST;
void exogenesis_previous_os_GetFSTabMountPoints (ExogenesisPreviousOS* self);
GType exogenesis_mount_points_get_type (void) G_GNUC_CONST;
ExogenesisMountPoints* exogenesis_hd_manager_GetMountPoints (ExogenesisHDManager* self);
const gchar* exogenesis_mount_point_get_Key (ExogenesisMountPoint* self);
const gchar* exogenesis_mount_point_get_Path (ExogenesisMountPoint* self);
static void _lambda0_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFHDConfigAdvanced* self);
static void __lambda0__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
static void _lambda1_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFHDConfigAdvanced* self);
static void __lambda1__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
ExogenesisCellRendererButton* exogenesis_cell_renderer_button_new (void);
ExogenesisCellRendererButton* exogenesis_cell_renderer_button_construct (GType object_type);
GType exogenesis_cell_renderer_button_get_type (void) G_GNUC_CONST;
void exogenesis_fhd_config_advanced_OnCellDelClicked (ExogenesisFHDConfigAdvanced* self, const gchar* path);
static void _exogenesis_fhd_config_advanced_OnCellDelClicked_exogenesis_cell_renderer_button_clicked (ExogenesisCellRendererButton* _sender, const gchar* path, gpointer self);
GType exogenesis_install_data_get_type (void) G_GNUC_CONST;
void exogenesis_install_data_ClearInstallDisks (ExogenesisInstallData* self);
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_new (void);
ExogenesisInstallHardDisk* exogenesis_install_hard_disk_construct (GType object_type);
const gchar* exogenesis_hard_disk_get_SerialNumber (ExogenesisHardDisk* self);
void exogenesis_install_hard_disk_set_SerialNumber (ExogenesisInstallHardDisk* self, const gchar* value);
const gchar* exogenesis_hard_disk_get_Device (ExogenesisHardDisk* self);
void exogenesis_install_hard_disk_set_DeviceName (ExogenesisInstallHardDisk* self, const gchar* value);
guint64 exogenesis_hard_disk_get_Capacity (ExogenesisHardDisk* self);
void exogenesis_install_hard_disk_set_DriveSize (ExogenesisInstallHardDisk* self, guint64 value);
const gchar* exogenesis_hard_disk_get_Model (ExogenesisHardDisk* self);
void exogenesis_install_hard_disk_set_Model (ExogenesisInstallHardDisk* self, const gchar* value);
guint64 exogenesis_hard_disk_get_StartSector (ExogenesisHardDisk* self);
void exogenesis_install_hard_disk_set_StartSector (ExogenesisInstallHardDisk* self, guint64 value);
const gchar* exogenesis_partition_info_get_PartitionType (ExogenesisPartitionInfo* self);
ExogenesisInstallPartition* exogenesis_install_partition_new (void);
ExogenesisInstallPartition* exogenesis_install_partition_construct (GType object_type);
guint64 exogenesis_partition_info_get_Capacity (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_ByteSize (ExogenesisInstallPartition* self, guint64 value);
const gchar* exogenesis_partition_info_get_Device (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_Device (ExogenesisInstallPartition* self, const gchar* value);
const gchar* exogenesis_partition_info_get_CapacityDescription (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_DisplaySize (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_Type (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_MountPoint (ExogenesisInstallPartition* self, const gchar* value);
guint64 exogenesis_partition_info_get_StartSector (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_Start (ExogenesisInstallPartition* self, guint64 value);
guint64 exogenesis_partition_info_get_EndSector (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_End (ExogenesisInstallPartition* self, guint64 value);
const gchar* exogenesis_partition_info_get_OSTypeID (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_TypeID (ExogenesisInstallPartition* self, const gchar* value);
void exogenesis_install_partition_set_NewPartition (ExogenesisInstallPartition* self, gboolean value);
void exogenesis_install_partition_set_Format (ExogenesisInstallPartition* self, gboolean value);
void exogenesis_install_partition_AddInstallPartition (ExogenesisInstallPartition* self, ExogenesisInstallPartition* ip);
static ExogenesisInstallPartition* exogenesis_fhd_config_advanced_CopyPartition (ExogenesisFHDConfigAdvanced* self, ExogenesisPartitionInfo* pi);
void exogenesis_install_hard_disk_AddPartition (ExogenesisInstallHardDisk* self, ExogenesisInstallPartition* partition);
void exogenesis_install_data_AddInstallDisk (ExogenesisInstallData* self, ExogenesisInstallHardDisk* hd);
void exogenesis_install_partition_set_Use (ExogenesisInstallPartition* self, gboolean value);
const gchar* exogenesis_partition_info_get_FSTabMountPoint (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_OSType (ExogenesisPartitionInfo* self);
const gchar* exogenesis_partition_info_get_Label (ExogenesisPartitionInfo* self);
void exogenesis_install_partition_set_Label (ExogenesisInstallPartition* self, const gchar* value);
static void exogenesis_fhd_config_advanced_ModelFromNewLayout (ExogenesisFHDConfigAdvanced* self);
static ExogenesisHardDisk* exogenesis_fhd_config_advanced_GetSelectedHD (ExogenesisFHDConfigAdvanced* self);
gint exogenesis_install_data_get_HardDiskCount (ExogenesisInstallData* self);
const gchar* exogenesis_install_hard_disk_get_Model (ExogenesisInstallHardDisk* self);
const gchar* exogenesis_install_partition_get_Type (ExogenesisInstallPartition* self);
static void exogenesis_fhd_config_advanced_PopulateListItemNew (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisInstallHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition, ExogenesisInstallPartition* p);
const gchar* exogenesis_install_partition_get_MountPoint (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Label (ExogenesisInstallPartition* self);
guint64 exogenesis_install_partition_get_ByteSize (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_TypeID (ExogenesisInstallPartition* self);
const gchar* exogenesis_install_partition_get_Device (ExogenesisInstallPartition* self);
static void exogenesis_fhd_config_advanced_UpdateSegbarNew (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd, ExogenesisInstallPartition* pi, gint PartCount);
const gchar* exogenesis_install_hard_disk_get_SerialNumber (ExogenesisInstallHardDisk* self);
gchar* exogenesis_general_functions_FormatHDSize (guint64 size);
static void exogenesis_fhd_config_advanced_ModelFromCurrentLayout (ExogenesisFHDConfigAdvanced* self);
static void exogenesis_fhd_config_advanced_PopulateListItemCurrent (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition, ExogenesisPartitionInfo* p);
static void exogenesis_fhd_config_advanced_UpdateSegbarCurrent (ExogenesisFHDConfigAdvanced* self, ExogenesisHardDisk* hd, ExogenesisPartitionInfo* pi, gint PartCount);
const gchar* exogenesis_hard_disk_get_PreviousOS (ExogenesisHardDisk* self);
static void exogenesis_fhd_config_advanced_AddToDiskDisplayBar (ExogenesisFHDConfigAdvanced* self, SegmentedBar* bar, guint64 HDSize, guint64 PartitionSize, const gchar* title, gint count);
const gchar* exogenesis_install_partition_get_DisplaySize (ExogenesisInstallPartition* self);
guint64 exogenesis_install_hard_disk_get_DriveSize (ExogenesisInstallHardDisk* self);
void segmented_bar_set_SegmentLabelSpacing (SegmentedBar* self, gint value);
void segmented_bar_AddSegmentRgb (SegmentedBar* self, const gchar* title, gint percent, guint rgbColor);
guint exogenesis_general_functions_BarColour (gint idx);
gboolean exogenesis_hard_disk_get_IsOptical (ExogenesisHardDisk* self);
const gchar* exogenesis_hard_disk_get_CapacityDescription (ExogenesisHardDisk* self);
gboolean exogenesis_fhd_config_advanced_IsMountPointUsed (ExogenesisFHDConfigAdvanced* self, const gchar* MountPoint);
static gboolean exogenesis_fhd_config_advanced_HardDiskExists (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd, GtkTreeIter* iter);
static guint64 exogenesis_fhd_config_advanced_AvailablePartSize (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd);
static void exogenesis_fhd_config_advanced_HDDisplayAfter (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd);
void segmented_bar_RemoveAllSegments (SegmentedBar* self);
static void exogenesis_fhd_config_advanced_AddInstallPartitions (ExogenesisFHDConfigAdvanced* self);
static gboolean exogenesis_fhd_config_advanced_IsAllocated (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* i);
static ExogenesisInstallPartition* exogenesis_fhd_config_advanced_PopulateInstallPartition (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, guint64 start);
guint64 exogenesis_install_partition_get_Start (ExogenesisInstallPartition* self);
static void exogenesis_fhd_config_advanced_DebugTree (ExogenesisFHDConfigAdvanced* self);
void exogenesis_general_functions_LogIt (const gchar* Message);
const gchar* exogenesis_install_hard_disk_get_DeviceName (ExogenesisInstallHardDisk* self);
static void exogenesis_fhd_config_advanced_RecalcUnallocated (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter);
void exogenesis_fhd_config_advanced_OnBtnApply_Click (ExogenesisFHDConfigAdvanced* self);
GType exogenesis_fcreate_partition_get_type (void) G_GNUC_CONST;
guint64 exogenesis_install_hard_disk_AvailableSize (ExogenesisInstallHardDisk* self);
guint64 exogenesis_install_hard_disk_get_StartSector (ExogenesisInstallHardDisk* self);
ExogenesisFCreatePartition* exogenesis_fcreate_partition_new (ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner);
ExogenesisFCreatePartition* exogenesis_fcreate_partition_construct (GType object_type, ExogenesisInstallHardDisk* hd, guint64 availablesize, ExogenesisFHDConfigAdvanced* owner);
void exogenesis_general_functions_ShowWindow (GtkBox* layout, const gchar* Title, gboolean Modal);
void exogenesis_fhd_config_advanced_OnBtnCancel_Click (ExogenesisFHDConfigAdvanced* self);
static void exogenesis_fhd_config_advanced_finalize (GObject* obj);


static GType exogenesis_fhd_config_advanced_partition_cols_get_type (void) {
	static volatile gsize exogenesis_fhd_config_advanced_partition_cols_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fhd_config_advanced_partition_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint", "mountpoint"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize", "displaysize"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType", "formattype"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label", "label"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk", "harddisk"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag", "formatflag"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag", "useflag"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon", "removeicon"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize", "bytesize"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID", "fstypeid"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device", "device"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_PartitionID, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_PartitionID", "partitionid"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition", "newpartition"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Partition, "EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Partition", "partition"}, {0, NULL, NULL}};
		GType exogenesis_fhd_config_advanced_partition_cols_type_id;
		exogenesis_fhd_config_advanced_partition_cols_type_id = g_enum_register_static ("ExogenesisFHDConfigAdvancedPartitionCols", values);
		g_once_init_leave (&exogenesis_fhd_config_advanced_partition_cols_type_id__volatile, exogenesis_fhd_config_advanced_partition_cols_type_id);
	}
	return exogenesis_fhd_config_advanced_partition_cols_type_id__volatile;
}


static GType exogenesis_fhd_config_advanced_tree_cols_get_type (void) {
	static volatile gsize exogenesis_fhd_config_advanced_tree_cols_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fhd_config_advanced_tree_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_HardDisk, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_HardDisk", "harddisk"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_MountPoint, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_MountPoint", "mountpoint"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatType, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatType", "formattype"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_DisplaySize, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_DisplaySize", "displaysize"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatFlag, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatFlag", "formatflag"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_UseFlag, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_UseFlag", "useflag"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Label, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Label", "label"}, {EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Remove, "EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_Remove", "remove"}, {0, NULL, NULL}};
		GType exogenesis_fhd_config_advanced_tree_cols_type_id;
		exogenesis_fhd_config_advanced_tree_cols_type_id = g_enum_register_static ("ExogenesisFHDConfigAdvancedTreeCols", values);
		g_once_init_leave (&exogenesis_fhd_config_advanced_tree_cols_type_id__volatile, exogenesis_fhd_config_advanced_tree_cols_type_id);
	}
	return exogenesis_fhd_config_advanced_tree_cols_type_id__volatile;
}


ExogenesisFHDConfigAdvanced* exogenesis_fhd_config_advanced_construct (GType object_type) {
	ExogenesisFHDConfigAdvanced * self = NULL;
	gint _tmp0_;
	self = (ExogenesisFHDConfigAdvanced*) g_object_new (object_type, NULL);
	exogenesis_fhd_config_advanced_GetMountPoints (self);
	exogenesis_fhd_config_advanced_GetDiskInfo (self);
	exogenesis_fhd_config_advanced_CopyOldSchemaToNew (self);
	exogenesis_fhd_config_advanced_Build (self);
	_tmp0_ = exogenesis_hd_manager_get_HardDiskCount (exogenesis_gHDManager);
	if (_tmp0_ > 0) {
		gpointer _tmp1_ = NULL;
		ExogenesisHardDisk* _tmp2_;
		_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) exogenesis_gHDManager->HardDisks, 0);
		_tmp2_ = (ExogenesisHardDisk*) _tmp1_;
		exogenesis_fhd_config_advanced_SetSelectedHD (self, _tmp2_);
		_g_object_unref0 (_tmp2_);
	}
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->boxHDAdvanced);
	return self;
}


ExogenesisFHDConfigAdvanced* exogenesis_fhd_config_advanced_new (void) {
	return exogenesis_fhd_config_advanced_construct (EXOGENESIS_TYPE_FHD_CONFIG_ADVANCED);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _exogenesis_fhd_config_advanced_OnDriveMounted_exogenesis_hd_manager_drive_mounted (ExogenesisHDManager* _sender, const gchar* mountpoint, gpointer self) {
	exogenesis_fhd_config_advanced_OnDriveMounted (self, mountpoint);
}


static void _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_drive_un_mounted (ExogenesisHDManager* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnDeviceConnected (self);
}


static void _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_devices_refreshed (ExogenesisHDManager* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnDeviceConnected (self);
}


static void _exogenesis_fhd_config_advanced_OnCboHD_Changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnCboHD_Changed (self);
}


static void _exogenesis_fhd_config_advanced_OnRdoAfter_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnRdoAfter_Click (self);
}


static void _exogenesis_fhd_config_advanced_OnRdoBefore_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnRdoBefore_Click (self);
}


static void _exogenesis_fhd_config_advanced_OnRealized_gtk_widget_realize (GtkWidget* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnRealized (self);
}


static void _exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click (self);
}


static void exogenesis_fhd_config_advanced_Build (ExogenesisFHDConfigAdvanced* self) {
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* builder;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GObject* _tmp3_ = NULL;
	GtkBox* _tmp4_;
	GObject* _tmp5_ = NULL;
	GtkBox* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkLabel* _tmp8_;
	GObject* _tmp9_ = NULL;
	GtkImage* _tmp10_;
	GObject* _tmp11_ = NULL;
	GtkSeparator* _tmp12_;
	GObject* _tmp13_ = NULL;
	GtkBox* _tmp14_;
	GObject* _tmp15_ = NULL;
	GtkButton* _tmp16_;
	GObject* _tmp17_ = NULL;
	GtkImage* _tmp18_;
	GObject* _tmp19_ = NULL;
	GtkBox* _tmp20_;
	GObject* _tmp21_ = NULL;
	GtkBox* _tmp22_;
	GObject* _tmp23_ = NULL;
	GtkLabel* _tmp24_;
	GObject* _tmp25_ = NULL;
	GtkComboBox* _tmp26_;
	GObject* _tmp27_ = NULL;
	GtkButton* _tmp28_;
	GObject* _tmp29_ = NULL;
	GtkImage* _tmp30_;
	GObject* _tmp31_ = NULL;
	GtkLabel* _tmp32_;
	GObject* _tmp33_ = NULL;
	GtkBox* _tmp34_;
	GObject* _tmp35_ = NULL;
	GtkBox* _tmp36_;
	GObject* _tmp37_ = NULL;
	GtkScrolledWindow* _tmp38_;
	GObject* _tmp39_ = NULL;
	GtkTreeView* _tmp40_;
	GObject* _tmp41_ = NULL;
	GtkGrid* _tmp42_;
	GObject* _tmp43_ = NULL;
	GtkButton* _tmp44_;
	GObject* _tmp45_ = NULL;
	GtkButton* _tmp46_;
	GObject* _tmp47_ = NULL;
	GtkLabel* _tmp48_;
	GObject* _tmp49_ = NULL;
	GtkRadioButton* _tmp50_;
	GObject* _tmp51_ = NULL;
	GtkRadioButton* _tmp52_;
	GObject* _tmp53_ = NULL;
	GtkTreeSelection* _tmp54_;
	GtkCellRendererText* _tmp55_ = NULL;
	GtkCellRendererText* cellHD;
	SegmentedBar* _tmp56_ = NULL;
	gint _tmp57_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	_tmp1_ = g_strdup_printf ("%s/src/exogenesis.ui", exogenesis_AppPath);
	_tmp2_ = _tmp1_;
	gtk_builder_add_from_file (builder, _tmp2_, &_inner_error_);
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		goto __catch28_g_error;
	}
	_tmp3_ = gtk_builder_get_object (builder, "boxHDAdvanced");
	_tmp4_ = _g_object_ref0 (GTK_BOX (_tmp3_));
	_g_object_unref0 (self->priv->boxHDAdvanced);
	self->priv->boxHDAdvanced = _tmp4_;
	_tmp5_ = gtk_builder_get_object (builder, "boxHDAHead");
	_tmp6_ = _g_object_ref0 (GTK_BOX (_tmp5_));
	_g_object_unref0 (self->priv->boxHDAHead);
	self->priv->boxHDAHead = _tmp6_;
	_tmp7_ = gtk_builder_get_object (builder, "lblHDAdvancedTitle");
	_tmp8_ = _g_object_ref0 (GTK_LABEL (_tmp7_));
	_g_object_unref0 (self->priv->lblHDAdvancedTitle);
	self->priv->lblHDAdvancedTitle = _tmp8_;
	_tmp9_ = gtk_builder_get_object (builder, "imgHD2");
	_tmp10_ = _g_object_ref0 (GTK_IMAGE (_tmp9_));
	_g_object_unref0 (self->priv->imgHD2);
	self->priv->imgHD2 = _tmp10_;
	_tmp11_ = gtk_builder_get_object (builder, "sepHD2");
	_tmp12_ = _g_object_ref0 (GTK_SEPARATOR (_tmp11_));
	_g_object_unref0 (self->priv->sepHD2);
	self->priv->sepHD2 = _tmp12_;
	_tmp13_ = gtk_builder_get_object (builder, "boxHD2Main");
	_tmp14_ = _g_object_ref0 (GTK_BOX (_tmp13_));
	_g_object_unref0 (self->priv->boxHD2Main);
	self->priv->boxHD2Main = _tmp14_;
	_tmp15_ = gtk_builder_get_object (builder, "btnHDAPrevious");
	_tmp16_ = _g_object_ref0 (GTK_BUTTON (_tmp15_));
	_g_object_unref0 (self->priv->btnHDAPrevious);
	self->priv->btnHDAPrevious = _tmp16_;
	_tmp17_ = gtk_builder_get_object (builder, "imgBtnHDAPrevious");
	_tmp18_ = _g_object_ref0 (GTK_IMAGE (_tmp17_));
	_g_object_unref0 (self->priv->imgBtnHDAPrevious);
	self->priv->imgBtnHDAPrevious = _tmp18_;
	_tmp19_ = gtk_builder_get_object (builder, "boxHDADetails");
	_tmp20_ = _g_object_ref0 (GTK_BOX (_tmp19_));
	_g_object_unref0 (self->priv->boxHDADetails);
	self->priv->boxHDADetails = _tmp20_;
	_tmp21_ = gtk_builder_get_object (builder, "boxHDAHardDisk");
	_tmp22_ = _g_object_ref0 (GTK_BOX (_tmp21_));
	_g_object_unref0 (self->priv->boxHDAHardDisk);
	self->priv->boxHDAHardDisk = _tmp22_;
	_tmp23_ = gtk_builder_get_object (builder, "lblHDADrives");
	_tmp24_ = _g_object_ref0 (GTK_LABEL (_tmp23_));
	_g_object_unref0 (self->priv->lblHDADrives);
	self->priv->lblHDADrives = _tmp24_;
	_tmp25_ = gtk_builder_get_object (builder, "cboHDADrives");
	_tmp26_ = _g_object_ref0 (GTK_COMBO_BOX (_tmp25_));
	_g_object_unref0 (self->priv->cboHDADrives);
	self->priv->cboHDADrives = _tmp26_;
	_tmp27_ = gtk_builder_get_object (builder, "btnHDAAddPartition");
	_tmp28_ = _g_object_ref0 (GTK_BUTTON (_tmp27_));
	_g_object_unref0 (self->priv->btnHDAAddPartition);
	self->priv->btnHDAAddPartition = _tmp28_;
	_tmp29_ = gtk_builder_get_object (builder, "imgBtnHDAAddPartition");
	_tmp30_ = _g_object_ref0 (GTK_IMAGE (_tmp29_));
	_g_object_unref0 (self->priv->imgBtnHDAAddPartition);
	self->priv->imgBtnHDAAddPartition = _tmp30_;
	_tmp31_ = gtk_builder_get_object (builder, "lblBtnHDAAddPartition");
	_tmp32_ = _g_object_ref0 (GTK_LABEL (_tmp31_));
	_g_object_unref0 (self->priv->lblBtnHDAAddPartition);
	self->priv->lblBtnHDAAddPartition = _tmp32_;
	_tmp33_ = gtk_builder_get_object (builder, "boxBtnAddPartition");
	_tmp34_ = _g_object_ref0 (GTK_BOX (_tmp33_));
	_g_object_unref0 (self->priv->boxBtnAddPartition);
	self->priv->boxBtnAddPartition = _tmp34_;
	_tmp35_ = gtk_builder_get_object (builder, "boxHDWidget");
	_tmp36_ = _g_object_ref0 (GTK_BOX (_tmp35_));
	_g_object_unref0 (self->priv->boxHDWidget);
	self->priv->boxHDWidget = _tmp36_;
	_tmp37_ = gtk_builder_get_object (builder, "sclHDALayout");
	_tmp38_ = _g_object_ref0 (GTK_SCROLLED_WINDOW (_tmp37_));
	_g_object_unref0 (self->priv->sclHDALayout);
	self->priv->sclHDALayout = _tmp38_;
	_tmp39_ = gtk_builder_get_object (builder, "trvHDALayout");
	_tmp40_ = _g_object_ref0 (GTK_TREE_VIEW (_tmp39_));
	_g_object_unref0 (self->priv->trvHDALayout);
	self->priv->trvHDALayout = _tmp40_;
	_tmp41_ = gtk_builder_get_object (builder, "grdHDAButtons");
	_tmp42_ = _g_object_ref0 (GTK_GRID (_tmp41_));
	_g_object_unref0 (self->priv->grdHDAButtons);
	self->priv->grdHDAButtons = _tmp42_;
	_tmp43_ = gtk_builder_get_object (builder, "btnHDAApply");
	_tmp44_ = _g_object_ref0 (GTK_BUTTON (_tmp43_));
	_g_object_unref0 (self->priv->btnHDAApply);
	self->priv->btnHDAApply = _tmp44_;
	_tmp45_ = gtk_builder_get_object (builder, "btnHDARevert");
	_tmp46_ = _g_object_ref0 (GTK_BUTTON (_tmp45_));
	_g_object_unref0 (self->priv->btnHDARevert);
	self->priv->btnHDARevert = _tmp46_;
	_tmp47_ = gtk_builder_get_object (builder, "lblPrevious");
	_tmp48_ = _g_object_ref0 (GTK_LABEL (_tmp47_));
	_g_object_unref0 (self->priv->lblPrevious);
	self->priv->lblPrevious = _tmp48_;
	_tmp49_ = gtk_builder_get_object (builder, "rdoHDBefore");
	_tmp50_ = _g_object_ref0 (GTK_RADIO_BUTTON (_tmp49_));
	_g_object_unref0 (self->priv->rdoHDBefore);
	self->priv->rdoHDBefore = _tmp50_;
	_tmp51_ = gtk_builder_get_object (builder, "rdoHDAfter");
	_tmp52_ = _g_object_ref0 (GTK_RADIO_BUTTON (_tmp51_));
	_g_object_unref0 (self->priv->rdoHDAfter);
	self->priv->rdoHDAfter = _tmp52_;
	_tmp53_ = gtk_builder_get_object (builder, "selHDALayout");
	_tmp54_ = _g_object_ref0 (GTK_TREE_SELECTION (_tmp53_));
	_g_object_unref0 (self->priv->selHDALayout);
	self->priv->selHDALayout = _tmp54_;
	g_signal_connect_object (exogenesis_gHDManager, "drive-mounted", (GCallback) _exogenesis_fhd_config_advanced_OnDriveMounted_exogenesis_hd_manager_drive_mounted, self, 0);
	g_signal_connect_object (exogenesis_gHDManager, "drive-un-mounted", (GCallback) _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_drive_un_mounted, self, 0);
	g_signal_connect_object (exogenesis_gHDManager, "devices-refreshed", (GCallback) _exogenesis_fhd_config_advanced_OnDeviceConnected_exogenesis_hd_manager_devices_refreshed, self, 0);
	gtk_combo_box_set_model (self->priv->cboHDADrives, (GtkTreeModel*) self->priv->_lstDisks);
	_tmp55_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	cellHD = g_object_ref_sink (_tmp55_);
	gtk_cell_layout_pack_start ((GtkCellLayout*) self->priv->cboHDADrives, (GtkCellRenderer*) cellHD, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) self->priv->cboHDADrives, (GtkCellRenderer*) cellHD, "text", 0);
	g_signal_connect_object (self->priv->cboHDADrives, "changed", (GCallback) _exogenesis_fhd_config_advanced_OnCboHD_Changed_gtk_combo_box_changed, self, 0);
	g_signal_connect_object ((GtkButton*) self->priv->rdoHDAfter, "clicked", (GCallback) _exogenesis_fhd_config_advanced_OnRdoAfter_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object ((GtkButton*) self->priv->rdoHDBefore, "clicked", (GCallback) _exogenesis_fhd_config_advanced_OnRdoBefore_Click_gtk_button_clicked, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "realize", (GCallback) _exogenesis_fhd_config_advanced_OnRealized_gtk_widget_realize, self, 0);
	g_signal_connect_object (self->priv->btnHDAAddPartition, "clicked", (GCallback) _exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click_gtk_button_clicked, self, 0);
	_tmp56_ = segmented_bar_new ();
	_g_object_unref0 (self->priv->segbarHD);
	self->priv->segbarHD = g_object_ref_sink (_tmp56_);
	segmented_bar_set_BarHeight (self->priv->segbarHD, 20);
	_tmp57_ = segmented_bar_get_BarHeight (self->priv->segbarHD);
	segmented_bar_set_HorizontalPadding (self->priv->segbarHD, _tmp57_ / 2);
	segmented_bar_set_ShowReflection (self->priv->segbarHD, TRUE);
	gtk_box_pack_start (self->priv->boxHDWidget, (GtkWidget*) self->priv->segbarHD, FALSE, FALSE, (guint) 0);
	gtk_widget_show_all ((GtkWidget*) self->priv->boxHDWidget);
	exogenesis_fhd_config_advanced_SetTreeColumns (self);
	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->rdoHDBefore, TRUE);
	exogenesis_previous_os_GetFSTabMountPoints (exogenesis_gPreviousOS);
	gtk_tree_view_set_model (self->priv->trvHDALayout, (GtkTreeModel*) self->priv->_lstPartitions);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (cellHD);
	_g_object_unref0 (builder);
	goto __finally28;
	__catch28_g_error:
	{
		GError * err;
		gchar* _tmp58_;
		gchar* _tmp59_;
		GtkMessageDialog* _tmp60_ = NULL;
		GtkMessageDialog* _tmp61_;
		GtkMessageDialog* msg;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp58_ = g_strconcat ("Failed to load UI\n", err->message, NULL);
		_tmp59_ = _tmp58_;
		_tmp60_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CANCEL, _tmp59_);
		_tmp61_ = g_object_ref_sink (_tmp60_);
		_g_free0 (_tmp59_);
		msg = _tmp61_;
		gtk_dialog_run ((GtkDialog*) msg);
		gtk_main_quit ();
		_g_object_unref0 (msg);
		_g_error_free0 (err);
	}
	__finally28:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void exogenesis_fhd_config_advanced_GetMountPoints (ExogenesisFHDConfigAdvanced* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->_lstMountPoints);
	{
		ExogenesisMountPoints* _tmp0_ = NULL;
		ExogenesisMountPoints* _tmp1_;
		GeeIterator* _tmp2_ = NULL;
		GeeIterator* _tmp3_;
		GeeIterator* _mp_it;
		_tmp0_ = exogenesis_hd_manager_GetMountPoints (exogenesis_gHDManager);
		_tmp1_ = _tmp0_;
		_tmp2_ = gee_iterable_iterator ((GeeIterable*) _tmp1_);
		_tmp3_ = _tmp2_;
		_g_object_unref0 (_tmp1_);
		_mp_it = _tmp3_;
		while (TRUE) {
			gboolean _tmp4_;
			gpointer _tmp5_ = NULL;
			ExogenesisMountPoint* mp;
			gchar* sDisplay = NULL;
			const gchar* _tmp6_ = NULL;
			GtkTreeIter _tmp12_ = {0};
			_tmp4_ = gee_iterator_next (_mp_it);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = gee_iterator_get (_mp_it);
			mp = (ExogenesisMountPoint*) _tmp5_;
			_tmp6_ = exogenesis_mount_point_get_Key (mp);
			if (g_strcmp0 (_tmp6_, "none") != 0) {
				const gchar* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp7_ = exogenesis_mount_point_get_Key (mp);
				_tmp8_ = exogenesis_mount_point_get_Path (mp);
				_tmp9_ = g_strdup_printf ("%s - %s", _tmp7_, _tmp8_);
				_g_free0 (sDisplay);
				sDisplay = _tmp9_;
			} else {
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				_tmp10_ = exogenesis_mount_point_get_Key (mp);
				_tmp11_ = g_strdup_printf ("%s", _tmp10_);
				_g_free0 (sDisplay);
				sDisplay = _tmp11_;
			}
			gtk_list_store_append (self->priv->_lstMountPoints, &_tmp12_);
			iter = _tmp12_;
			gtk_list_store_set (self->priv->_lstMountPoints, &iter, 0, sDisplay, 1, mp, -1);
			_g_free0 (sDisplay);
			_g_object_unref0 (mp);
		}
		_g_object_unref0 (_mp_it);
	}
}


static void _lambda0_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFHDConfigAdvanced* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_tree_store_set (self->priv->_lstNewPartitions, &iter, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, !_tmp2_, -1, -1);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda0__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda0_ (_sender, path, self);
}


static void _lambda1_ (GtkCellRendererToggle* toggle, const gchar* path, ExogenesisFHDConfigAdvanced* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_tree_store_set (self->priv->_lstNewPartitions, &iter, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, !_tmp2_, -1, -1);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda1__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda1_ (_sender, path, self);
}


static void _exogenesis_fhd_config_advanced_OnCellDelClicked_exogenesis_cell_renderer_button_clicked (ExogenesisCellRendererButton* _sender, const gchar* path, gpointer self) {
	exogenesis_fhd_config_advanced_OnCellDelClicked (self, path);
}


static void exogenesis_fhd_config_advanced_SetTreeColumns (ExogenesisFHDConfigAdvanced* self) {
	GList* _tmp0_ = NULL;
	gboolean _tmp2_;
	GtkCellRendererText* _tmp7_ = NULL;
	GtkCellRendererText* _tmp8_;
	GtkCellRendererText* _tmp9_ = NULL;
	GtkCellRendererText* _tmp10_;
	gboolean _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_view_get_columns (self->priv->trvHDALayout);
	{
		GList* tvc_collection;
		GList* tvc_it;
		tvc_collection = _tmp0_;
		for (tvc_it = tvc_collection; tvc_it != NULL; tvc_it = tvc_it->next) {
			GtkTreeViewColumn* _tmp1_;
			GtkTreeViewColumn* tvc;
			_tmp1_ = _g_object_ref0 ((GtkTreeViewColumn*) tvc_it->data);
			tvc = _tmp1_;
			{
				gtk_tree_view_remove_column (self->priv->trvHDALayout, tvc);
				_g_object_unref0 (tvc);
			}
		}
		_g_list_free0 (tvc_collection);
	}
	_tmp2_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoHDBefore);
	if (_tmp2_) {
		GtkCellRendererText* _tmp3_ = NULL;
		GtkCellRendererText* _tmp4_;
		GtkCellRendererText* _tmp5_ = NULL;
		GtkCellRendererText* _tmp6_;
		_tmp3_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
		_tmp4_ = g_object_ref_sink (_tmp3_);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 0, "Mount Point", (GtkCellRenderer*) _tmp4_, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, NULL, NULL);
		_g_object_unref0 (_tmp4_);
		_tmp5_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
		_tmp6_ = g_object_ref_sink (_tmp5_);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 1, "Type", (GtkCellRenderer*) _tmp6_, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, NULL, NULL);
		_g_object_unref0 (_tmp6_);
	}
	_tmp7_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp8_ = g_object_ref_sink (_tmp7_);
	gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 2, "Size", (GtkCellRenderer*) _tmp8_, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, NULL, NULL);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp10_ = g_object_ref_sink (_tmp9_);
	gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 3, "Label", (GtkCellRenderer*) _tmp10_, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label, NULL, NULL);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoHDAfter);
	if (_tmp11_) {
		GtkCellRendererCombo* _tmp12_ = NULL;
		GtkCellRendererCombo* cboMountPoints;
		GtkCellRendererCombo* _tmp13_ = NULL;
		GtkCellRendererCombo* cboFileTypes;
		GtkCellRendererToggle* _tmp14_ = NULL;
		GtkCellRendererToggle* togCellF;
		GtkCellRendererToggle* _tmp15_ = NULL;
		GtkCellRendererToggle* togCellU;
		ExogenesisCellRendererButton* _tmp16_ = NULL;
		ExogenesisCellRendererButton* cellButtonDel;
		_tmp12_ = (GtkCellRendererCombo*) gtk_cell_renderer_combo_new ();
		cboMountPoints = g_object_ref_sink (_tmp12_);
		g_object_set (cboMountPoints, "text-column", 0, NULL);
		g_object_set (cboMountPoints, "model", (GtkTreeModel*) self->priv->_lstMountPoints, NULL);
		g_object_set ((GtkCellRenderer*) cboMountPoints, "mode", GTK_CELL_RENDERER_MODE_ACTIVATABLE, NULL);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 0, "Mount Point", (GtkCellRenderer*) cboMountPoints, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, NULL, NULL);
		_tmp13_ = (GtkCellRendererCombo*) gtk_cell_renderer_combo_new ();
		cboFileTypes = g_object_ref_sink (_tmp13_);
		g_object_set (cboFileTypes, "model", (GtkTreeModel*) self->priv->_lstPartTypes, NULL);
		g_object_set ((GtkCellRenderer*) cboFileTypes, "mode", GTK_CELL_RENDERER_MODE_ACTIVATABLE, NULL);
		g_object_set (cboFileTypes, "text-column", 0, NULL);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 1, "Type", (GtkCellRenderer*) cboFileTypes, "text", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, NULL, NULL);
		_tmp14_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
		togCellF = g_object_ref_sink (_tmp14_);
		g_signal_connect_object (togCellF, "toggled", (GCallback) __lambda0__gtk_cell_renderer_toggle_toggled, self, 0);
		_tmp15_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
		togCellU = g_object_ref_sink (_tmp15_);
		g_signal_connect_object (togCellU, "toggled", (GCallback) __lambda1__gtk_cell_renderer_toggle_toggled, self, 0);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 4, "Format", (GtkCellRenderer*) togCellF, "active", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, NULL, NULL);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 5, "Use", (GtkCellRenderer*) togCellU, "active", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, NULL, NULL);
		_tmp16_ = exogenesis_cell_renderer_button_new ();
		cellButtonDel = g_object_ref_sink (_tmp16_);
		g_signal_connect_object (cellButtonDel, "clicked", (GCallback) _exogenesis_fhd_config_advanced_OnCellDelClicked_exogenesis_cell_renderer_button_clicked, self, 0);
		gtk_tree_view_insert_column_with_attributes (self->priv->trvHDALayout, 6, "Delete", (GtkCellRenderer*) cellButtonDel, "stockicon", EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon, NULL, NULL);
		_g_object_unref0 (cellButtonDel);
		_g_object_unref0 (togCellU);
		_g_object_unref0 (togCellF);
		_g_object_unref0 (cboFileTypes);
		_g_object_unref0 (cboMountPoints);
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


static void exogenesis_fhd_config_advanced_CopyOldSchemaToNew (ExogenesisFHDConfigAdvanced* self) {
	ExogenesisInstallPartition* ip = NULL;
	g_return_if_fail (self != NULL);
	exogenesis_install_data_ClearInstallDisks (exogenesis_gInstallData);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _hd_list;
		gint _tmp1_;
		gint _hd_size;
		gint _hd_index;
		_tmp0_ = _g_object_ref0 (exogenesis_gHDManager->HardDisks);
		_hd_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _hd_list);
		_hd_size = _tmp1_;
		_hd_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* hd;
			ExogenesisInstallHardDisk* _tmp3_ = NULL;
			ExogenesisInstallHardDisk* ihd;
			const gchar* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			guint64 _tmp6_;
			const gchar* _tmp7_ = NULL;
			guint64 _tmp8_;
			_hd_index = _hd_index + 1;
			if (!(_hd_index < _hd_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _hd_list, _hd_index);
			hd = (ExogenesisHardDisk*) _tmp2_;
			_tmp3_ = exogenesis_install_hard_disk_new ();
			ihd = _tmp3_;
			_tmp4_ = exogenesis_hard_disk_get_SerialNumber (hd);
			exogenesis_install_hard_disk_set_SerialNumber (ihd, _tmp4_);
			_tmp5_ = exogenesis_hard_disk_get_Device (hd);
			exogenesis_install_hard_disk_set_DeviceName (ihd, _tmp5_);
			_tmp6_ = exogenesis_hard_disk_get_Capacity (hd);
			exogenesis_install_hard_disk_set_DriveSize (ihd, _tmp6_);
			_tmp7_ = exogenesis_hard_disk_get_Model (hd);
			exogenesis_install_hard_disk_set_Model (ihd, _tmp7_);
			_tmp8_ = exogenesis_hard_disk_get_StartSector (hd);
			exogenesis_install_hard_disk_set_StartSector (ihd, _tmp8_);
			{
				GeeIterator* _tmp9_ = NULL;
				GeeIterator* _pi_it;
				_tmp9_ = gee_iterable_iterator ((GeeIterable*) hd);
				_pi_it = _tmp9_;
				while (TRUE) {
					gboolean _tmp10_;
					gpointer _tmp11_ = NULL;
					ExogenesisPartitionInfo* pi;
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					gchar* _tmp14_;
					gboolean _tmp15_;
					gboolean _tmp16_;
					_tmp10_ = gee_iterator_next (_pi_it);
					if (!_tmp10_) {
						break;
					}
					_tmp11_ = gee_iterator_get (_pi_it);
					pi = (ExogenesisPartitionInfo*) _tmp11_;
					_tmp12_ = exogenesis_partition_info_get_PartitionType (pi);
					_tmp13_ = g_utf8_strdown (_tmp12_, (gssize) (-1));
					_tmp14_ = _tmp13_;
					_tmp15_ = string_contains (_tmp14_, "extended");
					_tmp16_ = _tmp15_;
					_g_free0 (_tmp14_);
					if (_tmp16_) {
						ExogenesisInstallPartition* _tmp17_ = NULL;
						guint64 _tmp18_;
						const gchar* _tmp19_ = NULL;
						const gchar* _tmp20_ = NULL;
						const gchar* _tmp21_ = NULL;
						guint64 _tmp22_;
						guint64 _tmp23_;
						const gchar* _tmp24_ = NULL;
						_tmp17_ = exogenesis_install_partition_new ();
						_g_object_unref0 (ip);
						ip = _tmp17_;
						_tmp18_ = exogenesis_partition_info_get_Capacity (pi);
						exogenesis_install_partition_set_ByteSize (ip, _tmp18_);
						_tmp19_ = exogenesis_partition_info_get_Device (pi);
						exogenesis_install_partition_set_Device (ip, _tmp19_);
						_tmp20_ = exogenesis_partition_info_get_CapacityDescription (pi);
						exogenesis_install_partition_set_DisplaySize (ip, _tmp20_);
						_tmp21_ = exogenesis_partition_info_get_PartitionType (pi);
						exogenesis_install_partition_set_Type (ip, _tmp21_);
						exogenesis_install_partition_set_MountPoint (ip, "");
						_tmp22_ = exogenesis_partition_info_get_StartSector (pi);
						exogenesis_install_partition_set_Start (ip, _tmp22_);
						_tmp23_ = exogenesis_partition_info_get_EndSector (pi);
						exogenesis_install_partition_set_End (ip, _tmp23_);
						_tmp24_ = exogenesis_partition_info_get_OSTypeID (pi);
						exogenesis_install_partition_set_TypeID (ip, _tmp24_);
						exogenesis_install_partition_set_NewPartition (ip, FALSE);
						exogenesis_install_partition_set_Format (ip, FALSE);
						{
							GeeIterator* _tmp25_ = NULL;
							GeeIterator* _p_it;
							_tmp25_ = gee_iterable_iterator ((GeeIterable*) pi);
							_p_it = _tmp25_;
							while (TRUE) {
								gboolean _tmp26_;
								gpointer _tmp27_ = NULL;
								ExogenesisPartitionInfo* p;
								ExogenesisInstallPartition* _tmp28_ = NULL;
								ExogenesisInstallPartition* _tmp29_;
								_tmp26_ = gee_iterator_next (_p_it);
								if (!_tmp26_) {
									break;
								}
								_tmp27_ = gee_iterator_get (_p_it);
								p = (ExogenesisPartitionInfo*) _tmp27_;
								_tmp28_ = exogenesis_fhd_config_advanced_CopyPartition (self, p);
								_tmp29_ = _tmp28_;
								exogenesis_install_partition_AddInstallPartition (ip, _tmp29_);
								_g_object_unref0 (_tmp29_);
								_g_object_unref0 (p);
							}
							_g_object_unref0 (_p_it);
						}
					} else {
						ExogenesisInstallPartition* _tmp30_ = NULL;
						_tmp30_ = exogenesis_fhd_config_advanced_CopyPartition (self, pi);
						_g_object_unref0 (ip);
						ip = _tmp30_;
					}
					exogenesis_install_hard_disk_AddPartition (ihd, ip);
					_g_object_unref0 (pi);
				}
				_g_object_unref0 (_pi_it);
			}
			exogenesis_install_data_AddInstallDisk (exogenesis_gInstallData, ihd);
			_g_object_unref0 (ihd);
			_g_object_unref0 (hd);
		}
		_g_object_unref0 (_hd_list);
	}
	_g_object_unref0 (ip);
}


static ExogenesisInstallPartition* exogenesis_fhd_config_advanced_CopyPartition (ExogenesisFHDConfigAdvanced* self, ExogenesisPartitionInfo* pi) {
	ExogenesisInstallPartition* result = NULL;
	ExogenesisInstallPartition* _tmp0_ = NULL;
	ExogenesisInstallPartition* ip;
	guint64 _tmp1_;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	guint64 _tmp7_;
	const gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pi != NULL, NULL);
	_tmp0_ = exogenesis_install_partition_new ();
	ip = _tmp0_;
	_tmp1_ = exogenesis_partition_info_get_Capacity (pi);
	exogenesis_install_partition_set_ByteSize (ip, _tmp1_);
	_tmp2_ = exogenesis_partition_info_get_CapacityDescription (pi);
	exogenesis_install_partition_set_DisplaySize (ip, _tmp2_);
	exogenesis_install_partition_set_Format (ip, FALSE);
	exogenesis_install_partition_set_Use (ip, FALSE);
	exogenesis_install_partition_set_NewPartition (ip, FALSE);
	_tmp3_ = exogenesis_partition_info_get_FSTabMountPoint (pi);
	exogenesis_install_partition_set_MountPoint (ip, _tmp3_);
	_tmp4_ = exogenesis_partition_info_get_OSType (pi);
	exogenesis_install_partition_set_Type (ip, _tmp4_);
	_tmp5_ = exogenesis_partition_info_get_OSTypeID (pi);
	exogenesis_install_partition_set_TypeID (ip, _tmp5_);
	_tmp6_ = exogenesis_partition_info_get_Label (pi);
	exogenesis_install_partition_set_Label (ip, _tmp6_);
	_tmp7_ = exogenesis_partition_info_get_StartSector (pi);
	exogenesis_install_partition_set_Start (ip, _tmp7_);
	_tmp8_ = exogenesis_partition_info_get_Device (pi);
	exogenesis_install_partition_set_Device (ip, _tmp8_);
	result = ip;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void exogenesis_fhd_config_advanced_ModelFromNewLayout (ExogenesisFHDConfigAdvanced* self) {
	ExogenesisHardDisk* _tmp0_ = NULL;
	ExogenesisHardDisk* selectedHD;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear (self->priv->_lstNewPartitions);
	_tmp0_ = exogenesis_fhd_config_advanced_GetSelectedHD (self);
	selectedHD = _tmp0_;
	_tmp1_ = exogenesis_install_data_get_HardDiskCount (exogenesis_gInstallData);
	if (_tmp1_ > 0) {
		{
			GeeIterator* _tmp2_ = NULL;
			GeeIterator* _iHD_it;
			_tmp2_ = gee_iterable_iterator ((GeeIterable*) exogenesis_gInstallData);
			_iHD_it = _tmp2_;
			while (TRUE) {
				gboolean _tmp3_;
				gpointer _tmp4_ = NULL;
				ExogenesisInstallHardDisk* iHD;
				GtkTreeIter iterDisk = {0};
				GtkTreeIter _tmp5_ = {0};
				const gchar* _tmp6_ = NULL;
				_tmp3_ = gee_iterator_next (_iHD_it);
				if (!_tmp3_) {
					break;
				}
				_tmp4_ = gee_iterator_get (_iHD_it);
				iHD = (ExogenesisInstallHardDisk*) _tmp4_;
				gtk_tree_store_append (self->priv->_lstNewPartitions, &_tmp5_, NULL);
				iterDisk = _tmp5_;
				_tmp6_ = exogenesis_install_hard_disk_get_Model (iHD);
				gtk_tree_store_set (self->priv->_lstNewPartitions, &iterDisk, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, _tmp6_, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, iHD, -1, -1);
				gtk_tree_store_set (self->priv->_lstNewPartitions, &iterDisk, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon, GTK_STOCK_DELETE, -1, -1);
				{
					GeeIterator* _tmp7_ = NULL;
					GeeIterator* _ip_it;
					_tmp7_ = gee_iterable_iterator ((GeeIterable*) iHD);
					_ip_it = _tmp7_;
					while (TRUE) {
						gboolean _tmp8_;
						gpointer _tmp9_ = NULL;
						ExogenesisInstallPartition* ip;
						GtkTreeIter iterPart = {0};
						gint PartCount;
						const gchar* _tmp10_ = NULL;
						gchar* _tmp11_ = NULL;
						gchar* _tmp12_;
						gboolean _tmp13_;
						gboolean _tmp14_;
						_tmp8_ = gee_iterator_next (_ip_it);
						if (!_tmp8_) {
							break;
						}
						_tmp9_ = gee_iterator_get (_ip_it);
						ip = (ExogenesisInstallPartition*) _tmp9_;
						PartCount = 0;
						_tmp10_ = exogenesis_install_partition_get_Type (ip);
						_tmp11_ = g_utf8_strdown (_tmp10_, (gssize) (-1));
						_tmp12_ = _tmp11_;
						_tmp13_ = string_contains (_tmp12_, "extended");
						_tmp14_ = !_tmp13_;
						_g_free0 (_tmp12_);
						if (_tmp14_) {
							GtkTreeIter _tmp15_ = {0};
							const gchar* _tmp16_ = NULL;
							const gchar* _tmp17_ = NULL;
							const gchar* _tmp18_ = NULL;
							guint64 _tmp19_;
							const gchar* _tmp20_ = NULL;
							const gchar* _tmp21_ = NULL;
							gtk_tree_store_append (self->priv->_lstNewPartitions, &_tmp15_, &iterDisk);
							iterPart = _tmp15_;
							_tmp16_ = exogenesis_install_partition_get_MountPoint (ip);
							_tmp17_ = exogenesis_install_partition_get_Type (ip);
							_tmp18_ = exogenesis_install_partition_get_Label (ip);
							_tmp19_ = exogenesis_install_partition_get_ByteSize (ip);
							_tmp20_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp21_ = exogenesis_install_partition_get_Device (ip);
							exogenesis_fhd_config_advanced_PopulateListItemNew (self, &iterPart, _tmp16_, _tmp17_, iHD, _tmp18_, FALSE, FALSE, "", _tmp19_, _tmp20_, _tmp21_, "", FALSE, ip);
							exogenesis_fhd_config_advanced_UpdateSegbarNew (self, iHD, ip, PartCount);
							PartCount++;
						} else {
							GtkTreeIter partExt = {0};
							GtkTreeIter _tmp22_ = {0};
							guint64 _tmp23_;
							gchar* _tmp24_ = NULL;
							gchar* _tmp25_;
							const gchar* _tmp26_ = NULL;
							const gchar* _tmp27_ = NULL;
							const gchar* _tmp28_ = NULL;
							guint64 _tmp29_;
							const gchar* _tmp30_ = NULL;
							const gchar* _tmp31_ = NULL;
							gtk_tree_store_append (self->priv->_lstNewPartitions, &_tmp22_, &iterDisk);
							partExt = _tmp22_;
							_tmp23_ = exogenesis_install_partition_get_ByteSize (ip);
							_tmp24_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp23_);
							_tmp25_ = _tmp24_;
							_tmp26_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp27_ = string_to_string (_tmp26_);
							_tmp28_ = exogenesis_install_partition_get_Device (ip);
							fprintf (stdout, "Size = %s TypeID = %s  Device = %s\n", _tmp25_, _tmp27_, _tmp28_);
							_g_free0 (_tmp25_);
							_tmp29_ = exogenesis_install_partition_get_ByteSize (ip);
							_tmp30_ = exogenesis_install_partition_get_TypeID (ip);
							_tmp31_ = exogenesis_install_partition_get_Device (ip);
							exogenesis_fhd_config_advanced_PopulateListItemNew (self, &partExt, "", "Extended", iHD, "", FALSE, FALSE, "", _tmp29_, _tmp30_, _tmp31_, "", FALSE, ip);
							PartCount++;
							{
								GeeIterator* _tmp32_ = NULL;
								GeeIterator* _p_it;
								_tmp32_ = gee_iterable_iterator ((GeeIterable*) ip);
								_p_it = _tmp32_;
								while (TRUE) {
									gboolean _tmp33_;
									gpointer _tmp34_ = NULL;
									ExogenesisInstallPartition* p;
									GtkTreeIter it = {0};
									GtkTreeIter _tmp35_ = {0};
									const gchar* _tmp36_ = NULL;
									const gchar* _tmp37_ = NULL;
									const gchar* _tmp38_ = NULL;
									guint64 _tmp39_;
									const gchar* _tmp40_ = NULL;
									const gchar* _tmp41_ = NULL;
									const gchar* _tmp42_ = NULL;
									const gchar* _tmp43_ = NULL;
									_tmp33_ = gee_iterator_next (_p_it);
									if (!_tmp33_) {
										break;
									}
									_tmp34_ = gee_iterator_get (_p_it);
									p = (ExogenesisInstallPartition*) _tmp34_;
									gtk_tree_store_append (self->priv->_lstNewPartitions, &_tmp35_, &partExt);
									it = _tmp35_;
									_tmp36_ = exogenesis_install_partition_get_MountPoint (p);
									_tmp37_ = exogenesis_install_partition_get_Type (p);
									_tmp38_ = exogenesis_install_partition_get_Label (p);
									_tmp39_ = exogenesis_install_partition_get_ByteSize (p);
									_tmp40_ = exogenesis_install_partition_get_TypeID (p);
									_tmp41_ = exogenesis_install_partition_get_Device (p);
									exogenesis_fhd_config_advanced_PopulateListItemNew (self, &it, _tmp36_, _tmp37_, iHD, _tmp38_, FALSE, FALSE, "", _tmp39_, _tmp40_, _tmp41_, "", FALSE, p);
									_tmp42_ = exogenesis_install_hard_disk_get_SerialNumber (iHD);
									_tmp43_ = exogenesis_hard_disk_get_SerialNumber (selectedHD);
									if (g_strcmp0 (_tmp42_, _tmp43_) == 0) {
										exogenesis_fhd_config_advanced_UpdateSegbarNew (self, iHD, p, PartCount);
									}
									PartCount++;
									_g_object_unref0 (p);
								}
								_g_object_unref0 (_p_it);
							}
						}
						_g_object_unref0 (ip);
					}
					_g_object_unref0 (_ip_it);
				}
				_g_object_unref0 (iHD);
			}
			_g_object_unref0 (_iHD_it);
		}
	}
	gtk_tree_view_set_model (self->priv->trvHDALayout, (GtkTreeModel*) self->priv->_lstNewPartitions);
	_g_object_unref0 (selectedHD);
}


static void exogenesis_fhd_config_advanced_PopulateListItemNew (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisInstallHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition, ExogenesisInstallPartition* p) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mountpoint != NULL);
	g_return_if_fail (ostype != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (icon != NULL);
	g_return_if_fail (ostypeid != NULL);
	g_return_if_fail (device != NULL);
	g_return_if_fail (partitionid != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = exogenesis_general_functions_FormatHDSize (size);
	_tmp1_ = _tmp0_;
	gtk_tree_store_set (self->priv->_lstNewPartitions, iter, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, mountpoint, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, _tmp1_, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, ostype, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, hd, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label, label, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, format, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, use, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon, GTK_STOCK_DELETE, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, size, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID, ostypeid, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device, device, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_PartitionID, partitionid, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition, newpartition, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Partition, p, -1, -1);
	_g_free0 (_tmp1_);
}


static void exogenesis_fhd_config_advanced_ModelFromCurrentLayout (ExogenesisFHDConfigAdvanced* self) {
	gint PartCount;
	ExogenesisHardDisk* _tmp0_ = NULL;
	ExogenesisHardDisk* hd;
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear (self->priv->_lstPartitions);
	PartCount = 0;
	_tmp0_ = exogenesis_fhd_config_advanced_GetSelectedHD (self);
	hd = _tmp0_;
	if (hd != NULL) {
		GtkTreeIter iterDisk = {0};
		GtkTreeIter _tmp1_ = {0};
		const gchar* _tmp2_ = NULL;
		gboolean _tmp42_ = FALSE;
		const gchar* _tmp43_ = NULL;
		gtk_tree_store_append (self->priv->_lstPartitions, &_tmp1_, NULL);
		iterDisk = _tmp1_;
		_tmp2_ = exogenesis_hard_disk_get_Model (hd);
		gtk_tree_store_set (self->priv->_lstPartitions, &iterDisk, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, _tmp2_, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, hd, -1, -1);
		{
			GeeIterator* _tmp3_ = NULL;
			GeeIterator* _pi_it;
			_tmp3_ = gee_iterable_iterator ((GeeIterable*) hd);
			_pi_it = _tmp3_;
			while (TRUE) {
				gboolean _tmp4_;
				gpointer _tmp5_ = NULL;
				ExogenesisPartitionInfo* pi;
				GtkTreeIter iterPart = {0};
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				const gchar* _tmp8_ = NULL;
				_tmp4_ = gee_iterator_next (_pi_it);
				if (!_tmp4_) {
					break;
				}
				_tmp5_ = gee_iterator_get (_pi_it);
				pi = (ExogenesisPartitionInfo*) _tmp5_;
				_tmp8_ = exogenesis_partition_info_get_OSType (pi);
				if (g_strcmp0 (_tmp8_, "") != 0) {
					const gchar* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					_tmp9_ = exogenesis_partition_info_get_Device (pi);
					_tmp10_ = exogenesis_hard_disk_get_Device (hd);
					_tmp7_ = g_strcmp0 (_tmp9_, _tmp10_) != 0;
				} else {
					_tmp7_ = FALSE;
				}
				if (_tmp7_) {
					const gchar* _tmp11_ = NULL;
					gchar* _tmp12_ = NULL;
					gchar* _tmp13_;
					gboolean _tmp14_;
					_tmp11_ = exogenesis_partition_info_get_PartitionType (pi);
					_tmp12_ = g_utf8_strdown (_tmp11_, (gssize) (-1));
					_tmp13_ = _tmp12_;
					_tmp14_ = string_contains (_tmp13_, "extended");
					_tmp6_ = !_tmp14_;
					_g_free0 (_tmp13_);
				} else {
					_tmp6_ = FALSE;
				}
				if (_tmp6_) {
					GtkTreeIter _tmp15_ = {0};
					const gchar* _tmp16_ = NULL;
					const gchar* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					guint64 _tmp19_;
					const gchar* _tmp20_ = NULL;
					const gchar* _tmp21_ = NULL;
					gtk_tree_store_append (self->priv->_lstPartitions, &_tmp15_, &iterDisk);
					iterPart = _tmp15_;
					_tmp16_ = exogenesis_partition_info_get_FSTabMountPoint (pi);
					_tmp17_ = exogenesis_partition_info_get_OSType (pi);
					_tmp18_ = exogenesis_partition_info_get_Label (pi);
					_tmp19_ = exogenesis_partition_info_get_Capacity (pi);
					_tmp20_ = exogenesis_partition_info_get_OSTypeID (pi);
					_tmp21_ = exogenesis_partition_info_get_Device (pi);
					exogenesis_fhd_config_advanced_PopulateListItemCurrent (self, &iterPart, _tmp16_, _tmp17_, hd, _tmp18_, FALSE, FALSE, "", _tmp19_, _tmp20_, _tmp21_, "", FALSE, pi);
					exogenesis_fhd_config_advanced_UpdateSegbarCurrent (self, hd, pi, PartCount);
					PartCount++;
				} else {
					const gchar* _tmp22_ = NULL;
					gchar* _tmp23_ = NULL;
					gchar* _tmp24_;
					gboolean _tmp25_;
					gboolean _tmp26_;
					_tmp22_ = exogenesis_partition_info_get_PartitionType (pi);
					_tmp23_ = g_utf8_strdown (_tmp22_, (gssize) (-1));
					_tmp24_ = _tmp23_;
					_tmp25_ = string_contains (_tmp24_, "extended");
					_tmp26_ = _tmp25_;
					_g_free0 (_tmp24_);
					if (_tmp26_) {
						GtkTreeIter _tmp27_ = {0};
						const gchar* _tmp28_ = NULL;
						guint64 _tmp29_;
						const gchar* _tmp30_ = NULL;
						const gchar* _tmp31_ = NULL;
						gtk_tree_store_append (self->priv->_lstPartitions, &_tmp27_, &iterDisk);
						iterPart = _tmp27_;
						_tmp28_ = exogenesis_partition_info_get_Label (pi);
						_tmp29_ = exogenesis_partition_info_get_Capacity (pi);
						_tmp30_ = exogenesis_partition_info_get_OSTypeID (pi);
						_tmp31_ = exogenesis_partition_info_get_Device (pi);
						exogenesis_fhd_config_advanced_PopulateListItemCurrent (self, &iterPart, "", "Extended", hd, _tmp28_, FALSE, FALSE, "", _tmp29_, _tmp30_, _tmp31_, "", FALSE, pi);
						PartCount++;
						{
							GeeIterator* _tmp32_ = NULL;
							GeeIterator* _p_it;
							_tmp32_ = gee_iterable_iterator ((GeeIterable*) pi);
							_p_it = _tmp32_;
							while (TRUE) {
								gboolean _tmp33_;
								gpointer _tmp34_ = NULL;
								ExogenesisPartitionInfo* p;
								GtkTreeIter ti = {0};
								GtkTreeIter _tmp35_ = {0};
								const gchar* _tmp36_ = NULL;
								const gchar* _tmp37_ = NULL;
								const gchar* _tmp38_ = NULL;
								guint64 _tmp39_;
								const gchar* _tmp40_ = NULL;
								const gchar* _tmp41_ = NULL;
								_tmp33_ = gee_iterator_next (_p_it);
								if (!_tmp33_) {
									break;
								}
								_tmp34_ = gee_iterator_get (_p_it);
								p = (ExogenesisPartitionInfo*) _tmp34_;
								gtk_tree_store_append (self->priv->_lstPartitions, &_tmp35_, &iterPart);
								ti = _tmp35_;
								_tmp36_ = exogenesis_partition_info_get_FSTabMountPoint (p);
								_tmp37_ = exogenesis_partition_info_get_OSType (p);
								_tmp38_ = exogenesis_partition_info_get_Label (p);
								_tmp39_ = exogenesis_partition_info_get_Capacity (p);
								_tmp40_ = exogenesis_partition_info_get_OSTypeID (p);
								_tmp41_ = exogenesis_partition_info_get_Device (p);
								exogenesis_fhd_config_advanced_PopulateListItemCurrent (self, &ti, _tmp36_, _tmp37_, hd, _tmp38_, FALSE, FALSE, "", _tmp39_, _tmp40_, _tmp41_, "", FALSE, p);
								exogenesis_fhd_config_advanced_UpdateSegbarCurrent (self, hd, p, PartCount);
								PartCount++;
								_g_object_unref0 (p);
							}
							_g_object_unref0 (_p_it);
						}
					}
				}
				_g_object_unref0 (pi);
			}
			_g_object_unref0 (_pi_it);
		}
		_tmp43_ = exogenesis_hard_disk_get_PreviousOS (hd);
		if (_tmp43_ != NULL) {
			const gchar* _tmp44_ = NULL;
			_tmp44_ = exogenesis_hard_disk_get_PreviousOS (hd);
			_tmp42_ = g_strcmp0 (_tmp44_, "") != 0;
		} else {
			_tmp42_ = FALSE;
		}
		if (_tmp42_) {
			const gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			gchar* _tmp47_;
			_tmp45_ = exogenesis_hard_disk_get_PreviousOS (hd);
			_tmp46_ = g_strdup_printf ("This disk contains a version of \n%s", _tmp45_);
			_tmp47_ = _tmp46_;
			gtk_label_set_label (self->priv->lblPrevious, _tmp47_);
			_g_free0 (_tmp47_);
		} else {
			gtk_label_set_label (self->priv->lblPrevious, "");
		}
	}
	_g_object_unref0 (hd);
}


static void exogenesis_fhd_config_advanced_UpdateSegbarCurrent (ExogenesisFHDConfigAdvanced* self, ExogenesisHardDisk* hd, ExogenesisPartitionInfo* pi, gint PartCount) {
	gchar* label = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	guint64 _tmp3_;
	guint64 _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (pi != NULL);
	_tmp0_ = exogenesis_partition_info_get_OSType (pi);
	_tmp1_ = exogenesis_partition_info_get_CapacityDescription (pi);
	_tmp2_ = g_strdup_printf ("%s\n%s", _tmp0_, _tmp1_);
	_g_free0 (label);
	label = _tmp2_;
	_tmp3_ = exogenesis_hard_disk_get_Capacity (hd);
	_tmp4_ = exogenesis_partition_info_get_Capacity (pi);
	exogenesis_fhd_config_advanced_AddToDiskDisplayBar (self, self->priv->segbarHD, _tmp3_, _tmp4_, label, PartCount);
	_g_free0 (label);
}


static void exogenesis_fhd_config_advanced_UpdateSegbarNew (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd, ExogenesisInstallPartition* pi, gint PartCount) {
	gchar* label = NULL;
	const gchar* _tmp0_ = NULL;
	ExogenesisHardDisk* _tmp1_ = NULL;
	ExogenesisHardDisk* _tmp2_;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (pi != NULL);
	_tmp0_ = exogenesis_install_hard_disk_get_SerialNumber (hd);
	_tmp1_ = exogenesis_fhd_config_advanced_GetSelectedHD (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = exogenesis_hard_disk_get_SerialNumber (_tmp2_);
	_tmp4_ = g_strcmp0 (_tmp0_, _tmp3_) == 0;
	_g_object_unref0 (_tmp2_);
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		guint64 _tmp8_;
		guint64 _tmp9_;
		_tmp5_ = exogenesis_install_partition_get_Type (pi);
		_tmp6_ = exogenesis_install_partition_get_DisplaySize (pi);
		_tmp7_ = g_strdup_printf ("%s\n%s", _tmp5_, _tmp6_);
		_g_free0 (label);
		label = _tmp7_;
		_tmp8_ = exogenesis_install_hard_disk_get_DriveSize (hd);
		_tmp9_ = exogenesis_install_partition_get_ByteSize (pi);
		exogenesis_fhd_config_advanced_AddToDiskDisplayBar (self, self->priv->segbarHD, _tmp8_, _tmp9_, label, PartCount);
	}
	_g_free0 (label);
}


static void exogenesis_fhd_config_advanced_PopulateListItemCurrent (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, const gchar* mountpoint, const gchar* ostype, ExogenesisHardDisk* hd, const gchar* label, gboolean format, gboolean use, const gchar* icon, guint64 size, const gchar* ostypeid, const gchar* device, const gchar* partitionid, gboolean newpartition, ExogenesisPartitionInfo* p) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mountpoint != NULL);
	g_return_if_fail (ostype != NULL);
	g_return_if_fail (hd != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (icon != NULL);
	g_return_if_fail (ostypeid != NULL);
	g_return_if_fail (device != NULL);
	g_return_if_fail (partitionid != NULL);
	g_return_if_fail (p != NULL);
	_tmp0_ = exogenesis_general_functions_FormatHDSize (size);
	_tmp1_ = _tmp0_;
	gtk_tree_store_set (self->priv->_lstPartitions, iter, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, mountpoint, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, _tmp1_, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, ostype, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, hd, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label, label, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, format, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, use, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_RemoveIcon, GTK_STOCK_DELETE, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, size, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID, ostypeid, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device, device, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_PartitionID, partitionid, EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition, newpartition, -1, -1);
	_g_free0 (_tmp1_);
}


static void exogenesis_fhd_config_advanced_AddToDiskDisplayBar (ExogenesisFHDConfigAdvanced* self, SegmentedBar* bar, guint64 HDSize, guint64 PartitionSize, const gchar* title, gint count) {
	gdouble hdtotal;
	gdouble ptnsize;
	gdouble _tmp0_;
	gint percent;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (bar != NULL);
	g_return_if_fail (title != NULL);
	hdtotal = ((gdouble) (HDSize / 1024)) / 1024;
	ptnsize = ((gdouble) (PartitionSize / 1024)) / 1024;
	_tmp0_ = round ((ptnsize / hdtotal) * 100);
	percent = (gint) _tmp0_;
	segmented_bar_set_SegmentLabelSpacing (self->priv->segbarHD, 20);
	_tmp1_ = exogenesis_general_functions_BarColour (count);
	segmented_bar_AddSegmentRgb (self->priv->segbarHD, title, percent, _tmp1_);
}


static void exogenesis_fhd_config_advanced_GetDiskInfo (ExogenesisFHDConfigAdvanced* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->_lstDisks);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _d_list;
		gint _tmp1_;
		gint _d_size;
		gint _d_index;
		_tmp0_ = _g_object_ref0 (exogenesis_gHDManager->HardDisks);
		_d_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _d_list);
		_d_size = _tmp1_;
		_d_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisHardDisk* d;
			gboolean _tmp3_;
			_d_index = _d_index + 1;
			if (!(_d_index < _d_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _d_list, _d_index);
			d = (ExogenesisHardDisk*) _tmp2_;
			_tmp3_ = exogenesis_hard_disk_get_IsOptical (d);
			if (!_tmp3_) {
				GtkTreeIter _tmp4_ = {0};
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* displaytxt;
				gtk_list_store_append (self->priv->_lstDisks, &_tmp4_);
				iter = _tmp4_;
				_tmp5_ = exogenesis_hard_disk_get_Model (d);
				_tmp6_ = exogenesis_hard_disk_get_CapacityDescription (d);
				_tmp7_ = g_strdup_printf ("%s - %s", _tmp5_, _tmp6_);
				displaytxt = _tmp7_;
				gtk_list_store_set (self->priv->_lstDisks, &iter, 0, displaytxt, 1, d, -1, -1);
				_g_free0 (displaytxt);
			}
			_g_object_unref0 (d);
		}
		_g_object_unref0 (_d_list);
	}
	gtk_combo_box_set_active (self->priv->cboHDADrives, 0);
}


static void exogenesis_fhd_config_advanced_SetSelectedHD (ExogenesisFHDConfigAdvanced* self, ExogenesisHardDisk* hd) {
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstDisks, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp4_ = {0};
			if (!_tmp1_) {
				GtkTreeModel* _tmp2_ = NULL;
				gboolean _tmp3_;
				_tmp2_ = gtk_combo_box_get_model (self->priv->cboHDADrives);
				_tmp3_ = gtk_tree_model_iter_next (_tmp2_, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstDisks, &iter, 1, &_tmp4_);
			G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
			val = _tmp4_;
			if (g_value_get_object (&val) == hd) {
				gtk_combo_box_set_active_iter (self->priv->cboHDADrives, &iter);
				break;
			}
		}
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static ExogenesisHardDisk* exogenesis_fhd_config_advanced_GetSelectedHD (ExogenesisFHDConfigAdvanced* self) {
	ExogenesisHardDisk* result = NULL;
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeIter _tmp0_ = {0};
	GValue _tmp1_ = {0};
	ExogenesisHardDisk* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_combo_box_get_active_iter (self->priv->cboHDADrives, &_tmp0_);
	iter = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstDisks, &iter, 1, &_tmp1_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp1_;
	_tmp2_ = _g_object_ref0 (g_value_get_object (&val));
	result = _tmp2_;
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return result;
}


gboolean exogenesis_fhd_config_advanced_IsMountPointUsed (ExogenesisFHDConfigAdvanced* self, const gchar* MountPoint) {
	gboolean result = FALSE;
	GtkTreeIter iter = {0};
	GValue hdVal = {0};
	GValue mp = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (MountPoint != NULL, FALSE);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			GtkTreeIter partIter = {0};
			gboolean _tmp4_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp3_;
			_tmp4_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
			if (_tmp4_) {
				gint _tmp5_;
				gint i;
				_tmp5_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
				i = _tmp5_;
				{
					gint x;
					x = 0;
					{
						gboolean _tmp6_;
						_tmp6_ = TRUE;
						while (TRUE) {
							GtkTreeIter _tmp7_ = {0};
							GValue _tmp8_ = {0};
							gboolean _tmp9_ = FALSE;
							const gchar* _tmp10_ = NULL;
							gchar* _tmp11_ = NULL;
							gchar* _tmp12_;
							gboolean _tmp13_;
							if (!_tmp6_) {
								x++;
							}
							_tmp6_ = FALSE;
							if (!(x < i)) {
								break;
							}
							gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp7_, &iter, x);
							partIter = _tmp7_;
							gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, &_tmp8_);
							G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
							mp = _tmp8_;
							_tmp10_ = g_value_get_string (&mp);
							_tmp11_ = g_utf8_strdown (_tmp10_, (gssize) (-1));
							_tmp12_ = _tmp11_;
							_tmp13_ = g_strcmp0 (_tmp12_, MountPoint) == 0;
							_g_free0 (_tmp12_);
							if (_tmp13_) {
								_tmp9_ = g_strcmp0 (MountPoint, "none") != 0;
							} else {
								_tmp9_ = FALSE;
							}
							if (_tmp9_) {
								result = TRUE;
								G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
								G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
								return result;
							}
						}
					}
				}
			}
		}
	}
	result = FALSE;
	G_IS_VALUE (&mp) ? (g_value_unset (&mp), NULL) : NULL;
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
	return result;
}


static gboolean exogenesis_fhd_config_advanced_HardDiskExists (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd, GtkTreeIter* iter) {
	GtkTreeIter _iter = {0};
	gboolean result = FALSE;
	GValue valHD = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (hd != NULL, FALSE);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp0_);
	_iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstNewPartitions, &_iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &_iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
			valHD = _tmp3_;
			_tmp5_ = G_VALUE_HOLDS (&valHD, EXOGENESIS_TYPE_INSTALL_HARD_DISK);
			if (_tmp5_) {
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp6_ = exogenesis_install_hard_disk_get_SerialNumber (g_value_get_object (&valHD));
				_tmp7_ = exogenesis_install_hard_disk_get_SerialNumber (hd);
				_tmp4_ = g_strcmp0 (_tmp6_, _tmp7_) == 0;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				result = TRUE;
				G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
				if (iter) {
					*iter = _iter;
				}
				return result;
			}
		}
	}
	result = FALSE;
	G_IS_VALUE (&valHD) ? (g_value_unset (&valHD), NULL) : NULL;
	if (iter) {
		*iter = _iter;
	}
	return result;
}


static guint64 exogenesis_fhd_config_advanced_AvailablePartSize (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd) {
	guint64 result = 0ULL;
	GtkTreeIter iter = {0};
	guint64 Allocated;
	GValue size = {0};
	GValue hdVal = {0};
	GtkTreeIter _tmp0_ = {0};
	guint64 _tmp14_;
	guint64 available;
	guint64 _tmp15_ = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (hd != NULL, 0ULL);
	Allocated = (guint64) 0;
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GValue _tmp3_ = {0};
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp3_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp3_;
			_tmp5_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
			if (_tmp5_) {
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp6_ = exogenesis_hard_disk_get_SerialNumber (g_value_get_object (&hdVal));
				_tmp7_ = exogenesis_install_hard_disk_get_SerialNumber (hd);
				_tmp4_ = g_strcmp0 (_tmp6_, _tmp7_) == 0;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				GtkTreeIter partIter = {0};
				gboolean _tmp8_;
				_tmp8_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
				if (_tmp8_) {
					gint _tmp9_;
					gint i;
					_tmp9_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
					i = _tmp9_;
					{
						gint x;
						x = 0;
						{
							gboolean _tmp10_;
							_tmp10_ = TRUE;
							while (TRUE) {
								GtkTreeIter _tmp11_ = {0};
								GValue _tmp12_ = {0};
								guint64 _tmp13_;
								if (!_tmp10_) {
									x++;
								}
								_tmp10_ = FALSE;
								if (!(x < i)) {
									break;
								}
								gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp11_, &iter, x);
								partIter = _tmp11_;
								gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp12_);
								G_IS_VALUE (&size) ? (g_value_unset (&size), NULL) : NULL;
								size = _tmp12_;
								_tmp13_ = g_value_get_uint64 (&size);
								Allocated = Allocated + _tmp13_;
							}
						}
					}
				}
			}
		}
	}
	_tmp14_ = exogenesis_install_hard_disk_get_DriveSize (hd);
	available = _tmp14_ - Allocated;
	if (available >= 0) {
		_tmp15_ = available;
	} else {
		_tmp15_ = (guint64) 0;
	}
	result = _tmp15_;
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
	G_IS_VALUE (&size) ? (g_value_unset (&size), NULL) : NULL;
	return result;
}


static void exogenesis_fhd_config_advanced_HDDisplayAfter (ExogenesisFHDConfigAdvanced* self, ExogenesisInstallHardDisk* hd) {
	GtkTreeIter iter = {0};
	guint64 _tmp0_;
	guint64 available;
	GValue hdVal = {0};
	GtkTreeIter _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (hd != NULL);
	_tmp0_ = exogenesis_fhd_config_advanced_AvailablePartSize (self, hd);
	available = _tmp0_;
	segmented_bar_RemoveAllSegments (self->priv->segbarHD);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp1_);
	iter = _tmp1_;
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			GValue _tmp4_ = {0};
			gboolean _tmp5_ = FALSE;
			gboolean _tmp6_;
			if (!_tmp2_) {
				gboolean _tmp3_;
				_tmp3_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp4_);
			G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
			hdVal = _tmp4_;
			_tmp6_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
			if (_tmp6_) {
				const gchar* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				_tmp7_ = exogenesis_hard_disk_get_SerialNumber (g_value_get_object (&hdVal));
				_tmp8_ = exogenesis_install_hard_disk_get_SerialNumber (hd);
				_tmp5_ = g_strcmp0 (_tmp7_, _tmp8_) == 0;
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				GtkTreeIter partIter = {0};
				gboolean _tmp9_;
				_tmp9_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (_tmp9_) {
					gint _tmp10_;
					gint i;
					_tmp10_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
					i = _tmp10_;
					{
						gint x;
						x = 0;
						{
							gboolean _tmp11_;
							_tmp11_ = TRUE;
							while (TRUE) {
								GtkTreeIter _tmp12_ = {0};
								gboolean _tmp13_;
								if (!_tmp11_) {
									x++;
								}
								_tmp11_ = FALSE;
								if (!(x < i)) {
									break;
								}
								gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp12_, &iter, x);
								partIter = _tmp12_;
								_tmp13_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
								if (_tmp13_) {
									{
										gint y;
										y = 0;
										{
											gboolean _tmp14_;
											_tmp14_ = TRUE;
											while (TRUE) {
												gint _tmp15_;
												GtkTreeIter it = {0};
												GtkTreeIter _tmp16_ = {0};
												if (!_tmp14_) {
													y++;
												}
												_tmp14_ = FALSE;
												_tmp15_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
												if (!(y < _tmp15_)) {
													break;
												}
												gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp16_, &partIter, y);
												it = _tmp16_;
											}
										}
									}
								} else {
								}
							}
						}
					}
				}
			}
		}
	}
	if (available > 1) {
		guint64 _tmp17_;
		_tmp17_ = exogenesis_install_hard_disk_get_DriveSize (hd);
		exogenesis_fhd_config_advanced_AddToDiskDisplayBar (self, self->priv->segbarHD, _tmp17_, available, "UNALLOCATED", 7);
	}
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
}


static void exogenesis_fhd_config_advanced_AddInstallPartitions (ExogenesisFHDConfigAdvanced* self) {
	GtkTreeIter iter = {0};
	GValue hdVal = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	exogenesis_install_data_ClearInstallDisks (exogenesis_gInstallData);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			gint _tmp3_;
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			_tmp3_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &iter);
			if (_tmp3_ == 0) {
				GValue _tmp4_ = {0};
				gboolean _tmp5_;
				gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp4_);
				G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
				hdVal = _tmp4_;
				_tmp5_ = G_VALUE_HOLDS (&hdVal, EXOGENESIS_TYPE_HARD_DISK);
				if (_tmp5_) {
					ExogenesisHardDisk* _tmp6_;
					ExogenesisHardDisk* hd;
					ExogenesisInstallHardDisk* _tmp7_ = NULL;
					ExogenesisInstallHardDisk* iHD;
					const gchar* _tmp8_ = NULL;
					const gchar* _tmp9_ = NULL;
					guint64 start;
					GtkTreeIter partIter = {0};
					gboolean _tmp10_;
					_tmp6_ = _g_object_ref0 (g_value_get_object (&hdVal));
					hd = _tmp6_;
					_tmp7_ = exogenesis_install_hard_disk_new ();
					iHD = _tmp7_;
					_tmp8_ = exogenesis_hard_disk_get_Device (hd);
					exogenesis_install_hard_disk_set_DeviceName (iHD, _tmp8_);
					_tmp9_ = exogenesis_hard_disk_get_SerialNumber (hd);
					exogenesis_install_hard_disk_set_SerialNumber (iHD, _tmp9_);
					start = (guint64) 1048576;
					_tmp10_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
					if (_tmp10_) {
						GValue vSize = {0};
						gint _tmp11_;
						gint i;
						_tmp11_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
						i = _tmp11_;
						{
							gint x;
							x = 0;
							{
								gboolean _tmp12_;
								_tmp12_ = TRUE;
								while (TRUE) {
									GtkTreeIter _tmp13_ = {0};
									gboolean _tmp14_ = FALSE;
									gboolean _tmp15_;
									if (!_tmp12_) {
										x++;
									}
									_tmp12_ = FALSE;
									if (!(x < i)) {
										break;
									}
									gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp13_, &iter, x);
									partIter = _tmp13_;
									_tmp15_ = exogenesis_fhd_config_advanced_IsAllocated (self, &partIter);
									if (_tmp15_) {
										gint _tmp16_;
										_tmp16_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &partIter);
										_tmp14_ = _tmp16_ == 1;
									} else {
										_tmp14_ = FALSE;
									}
									if (_tmp14_) {
										GValue vUse = {0};
										ExogenesisInstallPartition* p;
										GValue _tmp17_ = {0};
										GValue _tmp18_ = {0};
										gboolean _tmp19_;
										gboolean _tmp21_;
										guint64 _tmp33_;
										p = NULL;
										gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp17_);
										G_IS_VALUE (&vSize) ? (g_value_unset (&vSize), NULL) : NULL;
										vSize = _tmp17_;
										gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, &_tmp18_);
										G_IS_VALUE (&vUse) ? (g_value_unset (&vUse), NULL) : NULL;
										vUse = _tmp18_;
										_tmp19_ = g_value_get_boolean (&vUse);
										if (_tmp19_) {
											ExogenesisInstallPartition* _tmp20_ = NULL;
											_tmp20_ = exogenesis_fhd_config_advanced_PopulateInstallPartition (self, &partIter, start);
											_g_object_unref0 (p);
											p = _tmp20_;
										}
										_tmp21_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
										if (_tmp21_) {
											guint64 estart;
											GValue veSize = {0};
											GValue veUse = {0};
											estart = start;
											{
												gint y;
												y = 0;
												{
													gboolean _tmp22_;
													_tmp22_ = TRUE;
													while (TRUE) {
														gint _tmp23_;
														GtkTreeIter it = {0};
														GtkTreeIter _tmp24_ = {0};
														gboolean _tmp25_;
														if (!_tmp22_) {
															y++;
														}
														_tmp22_ = FALSE;
														_tmp23_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstPartitions, &partIter);
														if (!(y < _tmp23_)) {
															break;
														}
														gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp24_, &partIter, y);
														it = _tmp24_;
														_tmp25_ = exogenesis_fhd_config_advanced_IsAllocated (self, &it);
														if (_tmp25_) {
															GValue _tmp26_ = {0};
															GValue _tmp27_ = {0};
															gboolean _tmp28_ = FALSE;
															gboolean _tmp29_;
															guint64 _tmp32_;
															gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &it, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp26_);
															G_IS_VALUE (&veSize) ? (g_value_unset (&veSize), NULL) : NULL;
															veSize = _tmp26_;
															gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, &it, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_UseFlag, &_tmp27_);
															G_IS_VALUE (&veUse) ? (g_value_unset (&veUse), NULL) : NULL;
															veUse = _tmp27_;
															_tmp29_ = g_value_get_boolean (&veUse);
															if (_tmp29_) {
																_tmp28_ = p != NULL;
															} else {
																_tmp28_ = FALSE;
															}
															if (_tmp28_) {
																ExogenesisInstallPartition* _tmp30_ = NULL;
																ExogenesisInstallPartition* _tmp31_;
																_tmp30_ = exogenesis_fhd_config_advanced_PopulateInstallPartition (self, &it, estart);
																_tmp31_ = _tmp30_;
																exogenesis_install_partition_AddInstallPartition (p, _tmp31_);
																_g_object_unref0 (_tmp31_);
															}
															_tmp32_ = g_value_get_uint64 (&veSize);
															estart = estart + _tmp32_;
														}
													}
												}
											}
											G_IS_VALUE (&veUse) ? (g_value_unset (&veUse), NULL) : NULL;
											G_IS_VALUE (&veSize) ? (g_value_unset (&veSize), NULL) : NULL;
										}
										_tmp33_ = g_value_get_uint64 (&vSize);
										start = start + _tmp33_;
										exogenesis_install_hard_disk_AddPartition (iHD, p);
										_g_object_unref0 (p);
										p = NULL;
										_g_object_unref0 (p);
										G_IS_VALUE (&vUse) ? (g_value_unset (&vUse), NULL) : NULL;
									}
								}
							}
						}
						G_IS_VALUE (&vSize) ? (g_value_unset (&vSize), NULL) : NULL;
					}
					exogenesis_install_data_AddInstallDisk (exogenesis_gInstallData, iHD);
					_g_object_unref0 (iHD);
					iHD = NULL;
					_g_object_unref0 (iHD);
					_g_object_unref0 (hd);
				}
			}
		}
	}
	G_IS_VALUE (&hdVal) ? (g_value_unset (&hdVal), NULL) : NULL;
}


static gboolean exogenesis_fhd_config_advanced_IsAllocated (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* i) {
	gboolean result = FALSE;
	GValue val = {0};
	GValue _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, i, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, &_tmp0_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp0_;
	_tmp3_ = g_value_get_string (&val);
	if (_tmp3_ == NULL) {
		_tmp2_ = TRUE;
	} else {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = g_value_get_string (&val);
		_tmp2_ = g_strcmp0 (_tmp4_, "") == 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		_tmp5_ = g_value_get_string (&val);
		_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) (-1));
		_tmp7_ = _tmp6_;
		_tmp1_ = g_strcmp0 (_tmp7_, "unallocated") == 0;
		_g_free0 (_tmp7_);
	}
	if (_tmp1_) {
		result = FALSE;
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		return result;
	} else {
		result = TRUE;
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		return result;
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static ExogenesisInstallPartition* exogenesis_fhd_config_advanced_PopulateInstallPartition (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter, guint64 start) {
	ExogenesisInstallPartition* result = NULL;
	GValue pVal = {0};
	ExogenesisInstallPartition* _tmp0_ = NULL;
	ExogenesisInstallPartition* ip;
	GValue _tmp1_ = {0};
	guint64 _tmp2_;
	GValue _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	GValue _tmp5_ = {0};
	const gchar* _tmp6_ = NULL;
	GValue _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	GValue _tmp9_ = {0};
	gboolean _tmp10_;
	GValue _tmp11_ = {0};
	gboolean _tmp12_;
	GValue _tmp13_ = {0};
	gboolean _tmp14_;
	GValue _tmp15_ = {0};
	const gchar* _tmp16_ = NULL;
	GValue _tmp17_ = {0};
	const gchar* _tmp18_ = NULL;
	GValue _tmp19_ = {0};
	const gchar* _tmp20_ = NULL;
	gboolean _tmp21_;
	guint64 _tmp23_;
	guint64 _tmp24_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = exogenesis_install_partition_new ();
	ip = _tmp0_;
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp1_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp1_;
	_tmp2_ = g_value_get_uint64 (&pVal);
	exogenesis_install_partition_set_ByteSize (ip, _tmp2_ - 1048576);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, &_tmp3_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp3_;
	_tmp4_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_DisplaySize (ip, _tmp4_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Label, &_tmp5_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp5_;
	_tmp6_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_Label (ip, _tmp6_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_MountPoint, &_tmp7_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp7_;
	_tmp8_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_MountPoint (ip, _tmp8_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, &_tmp9_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp9_;
	_tmp10_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_Format (ip, _tmp10_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatFlag, &_tmp11_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp11_;
	_tmp12_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_Use (ip, _tmp12_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_NewPartition, &_tmp13_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp13_;
	_tmp14_ = g_value_get_boolean (&pVal);
	exogenesis_install_partition_set_NewPartition (ip, _tmp14_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FormatType, &_tmp15_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp15_;
	_tmp16_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_Type (ip, _tmp16_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_FSTypeID, &_tmp17_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp17_;
	_tmp18_ = g_value_get_string (&pVal);
	exogenesis_install_partition_set_TypeID (ip, _tmp18_);
	gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstPartitions, iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_Device, &_tmp19_);
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	pVal = _tmp19_;
	_tmp21_ = G_VALUE_HOLDS (&pVal, G_TYPE_STRING);
	if (_tmp21_) {
		const gchar* _tmp22_ = NULL;
		_tmp22_ = g_value_get_string (&pVal);
		_tmp20_ = _tmp22_;
	} else {
		_tmp20_ = "";
	}
	exogenesis_install_partition_set_Device (ip, _tmp20_);
	exogenesis_install_partition_set_Start (ip, start);
	_tmp23_ = exogenesis_install_partition_get_Start (ip);
	_tmp24_ = exogenesis_install_partition_get_ByteSize (ip);
	exogenesis_install_partition_set_End (ip, _tmp23_ + _tmp24_);
	result = ip;
	G_IS_VALUE (&pVal) ? (g_value_unset (&pVal), NULL) : NULL;
	return result;
}


static void exogenesis_fhd_config_advanced_DebugTree (ExogenesisFHDConfigAdvanced* self) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->_lstPartitions, &_tmp0_);
	iter = _tmp0_;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			if (!_tmp1_) {
				gboolean _tmp2_;
				_tmp2_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->_lstPartitions, &iter);
				if (!_tmp2_) {
					break;
				}
			}
			_tmp1_ = FALSE;
			exogenesis_general_functions_LogIt ("ITER\n");
		}
	}
}


void exogenesis_fhd_config_advanced_OnCellDelClicked (ExogenesisFHDConfigAdvanced* self, const gchar* path) {
	GtkTreeIter iter = {0};
	GValue val = {0};
	ExogenesisInstallHardDisk* ihd = NULL;
	guint64 available = 0ULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tp;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tp = _tmp0_;
	{
		GtkTreeIter _tmp1_ = {0};
		GValue _tmp2_ = {0};
		guint64 _tmp3_;
		GValue _tmp4_ = {0};
		ExogenesisInstallHardDisk* _tmp5_;
		gboolean _tmp6_;
		ExogenesisInstallPartition* _tmp10_ = NULL;
		ExogenesisInstallPartition* ipart;
		const gchar* _tmp11_ = NULL;
		gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp1_, tp);
		iter = _tmp1_;
		gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp2_);
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		val = _tmp2_;
		_tmp3_ = g_value_get_uint64 (&val);
		available = _tmp3_;
		gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_HardDisk, &_tmp4_);
		G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		val = _tmp4_;
		_tmp5_ = _g_object_ref0 (g_value_get_object (&val));
		_g_object_unref0 (ihd);
		ihd = _tmp5_;
		_tmp6_ = gtk_tree_model_iter_has_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
		if (_tmp6_) {
			GtkTreeIter childIter = {0};
			gint i = 0;
			gint _tmp7_;
			_tmp7_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstNewPartitions, &iter);
			i = _tmp7_ - 1;
			{
				gint x;
				x = i;
				{
					gboolean _tmp8_;
					_tmp8_ = TRUE;
					while (TRUE) {
						GtkTreeIter _tmp9_ = {0};
						if (!_tmp8_) {
							x--;
						}
						_tmp8_ = FALSE;
						if (!(x > (-1))) {
							break;
						}
						gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp9_, &iter, x);
						childIter = _tmp9_;
						gtk_tree_store_remove (self->priv->_lstNewPartitions, &childIter);
					}
				}
			}
		}
		_tmp10_ = exogenesis_install_partition_new ();
		ipart = _tmp10_;
		_tmp11_ = exogenesis_install_hard_disk_get_DeviceName (ihd);
		exogenesis_fhd_config_advanced_PopulateListItemNew (self, &iter, "", "Unallocated", ihd, "", FALSE, FALSE, "", available, "Unallocated", _tmp11_, "", TRUE, ipart);
		exogenesis_fhd_config_advanced_RecalcUnallocated (self, &iter);
		_g_object_unref0 (ipart);
	}
	_gtk_tree_path_free0 (tp);
	_g_object_unref0 (ihd);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


static void exogenesis_fhd_config_advanced_RecalcUnallocated (ExogenesisFHDConfigAdvanced* self, GtkTreeIter* iter) {
	GtkTreeIter partIter = {0};
	GtkTreeIter parentIter = {0};
	GValue val = {0};
	gint _tmp0_;
	gint level;
	gint i = 0;
	gboolean bPreviousUnalloc;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_store_iter_depth (self->priv->_lstNewPartitions, iter);
	level = _tmp0_;
	bPreviousUnalloc = FALSE;
	gtk_tree_model_iter_parent ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp1_, iter);
	parentIter = _tmp1_;
	_tmp2_ = gtk_tree_store_iter_is_valid (self->priv->_lstNewPartitions, &parentIter);
	if (_tmp2_) {
		gint _tmp3_;
		_tmp3_ = gtk_tree_model_iter_n_children ((GtkTreeModel*) self->priv->_lstNewPartitions, &parentIter);
		i = _tmp3_ - 1;
		{
			gint x;
			x = i;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					GtkTreeIter _tmp5_ = {0};
					GValue _tmp6_ = {0};
					gboolean _tmp7_ = FALSE;
					const gchar* _tmp8_ = NULL;
					gchar* _tmp9_ = NULL;
					gchar* _tmp10_;
					gboolean _tmp11_;
					if (!_tmp4_) {
						x--;
					}
					_tmp4_ = FALSE;
					if (!(x > (-1))) {
						break;
					}
					gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp5_, &parentIter, x);
					partIter = _tmp5_;
					gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_TREE_COLS_FormatType, &_tmp6_);
					G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
					val = _tmp6_;
					_tmp8_ = g_value_get_string (&val);
					_tmp9_ = g_utf8_strdown (_tmp8_, (gssize) (-1));
					_tmp10_ = _tmp9_;
					_tmp11_ = g_strcmp0 (_tmp10_, "unallocated") == 0;
					_g_free0 (_tmp10_);
					if (_tmp11_) {
						gint _tmp12_;
						_tmp12_ = gtk_tree_store_iter_depth (self->priv->_lstPartitions, &partIter);
						_tmp7_ = _tmp12_ == level;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						GValue _tmp13_ = {0};
						guint64 _tmp14_;
						guint64 partsize;
						gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp13_);
						G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
						val = _tmp13_;
						_tmp14_ = g_value_get_uint64 (&val);
						partsize = _tmp14_;
						if (bPreviousUnalloc) {
							guint64 available;
							guint64 total = 0ULL;
							GtkTreeIter nextIter = {0};
							GtkTreeIter _tmp15_ = {0};
							GValue _tmp16_ = {0};
							guint64 _tmp17_;
							GValue _tmp18_ = {0};
							gchar* _tmp19_ = NULL;
							GValue _tmp20_ = {0};
							available = (guint64) 0;
							gtk_tree_model_iter_nth_child ((GtkTreeModel*) self->priv->_lstNewPartitions, &_tmp15_, &parentIter, x + 1);
							nextIter = _tmp15_;
							gtk_tree_model_get_value ((GtkTreeModel*) self->priv->_lstNewPartitions, &nextIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp16_);
							G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
							val = _tmp16_;
							_tmp17_ = g_value_get_uint64 (&val);
							available = available + _tmp17_;
							total = available + partsize;
							g_value_init (&_tmp18_, G_TYPE_UINT64);
							g_value_set_uint64 (&_tmp18_, total);
							gtk_tree_store_set_value (self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_ByteSize, &_tmp18_);
							G_IS_VALUE (&_tmp18_) ? (g_value_unset (&_tmp18_), NULL) : NULL;
							_tmp19_ = exogenesis_general_functions_FormatHDSize (total);
							g_value_init (&_tmp20_, G_TYPE_STRING);
							g_value_take_string (&_tmp20_, _tmp19_);
							gtk_tree_store_set_value (self->priv->_lstNewPartitions, &partIter, (gint) EXOGENESIS_FHD_CONFIG_ADVANCED_PARTITION_COLS_DisplaySize, &_tmp20_);
							G_IS_VALUE (&_tmp20_) ? (g_value_unset (&_tmp20_), NULL) : NULL;
							gtk_tree_store_remove (self->priv->_lstNewPartitions, &nextIter);
						}
						bPreviousUnalloc = TRUE;
					} else {
						bPreviousUnalloc = FALSE;
					}
				}
			}
		}
	}
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
}


void exogenesis_fhd_config_advanced_OnBtnApply_Click (ExogenesisFHDConfigAdvanced* self) {
	GtkContainer* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_AddInstallPartitions (self);
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


void exogenesis_fhd_config_advanced_OnRdoBefore_Click (ExogenesisFHDConfigAdvanced* self) {
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_OnCboHD_Changed (self);
}


void exogenesis_fhd_config_advanced_OnRdoAfter_Click (ExogenesisFHDConfigAdvanced* self) {
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_OnCboHD_Changed (self);
}


void exogenesis_fhd_config_advanced_OnBtnCreatePartition_Click (ExogenesisFHDConfigAdvanced* self) {
	ExogenesisFCreatePartition* fcp = NULL;
	ExogenesisInstallHardDisk* ihd;
	ExogenesisHardDisk* _tmp0_ = NULL;
	ExogenesisHardDisk* selectedHD;
	guint64 _tmp7_;
	guint64 _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gboolean _tmp11_ = FALSE;
	g_return_if_fail (self != NULL);
	ihd = NULL;
	_tmp0_ = exogenesis_fhd_config_advanced_GetSelectedHD (self);
	selectedHD = _tmp0_;
	{
		GeeIterator* _tmp1_ = NULL;
		GeeIterator* _h_it;
		_tmp1_ = gee_iterable_iterator ((GeeIterable*) exogenesis_gInstallData);
		_h_it = _tmp1_;
		while (TRUE) {
			gboolean _tmp2_;
			gpointer _tmp3_ = NULL;
			ExogenesisInstallHardDisk* h;
			const gchar* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			_tmp2_ = gee_iterator_next (_h_it);
			if (!_tmp2_) {
				break;
			}
			_tmp3_ = gee_iterator_get (_h_it);
			h = (ExogenesisInstallHardDisk*) _tmp3_;
			_tmp4_ = exogenesis_install_hard_disk_get_SerialNumber (h);
			_tmp5_ = exogenesis_hard_disk_get_SerialNumber (selectedHD);
			if (g_strcmp0 (_tmp4_, _tmp5_) == 0) {
				ExogenesisInstallHardDisk* _tmp6_;
				_tmp6_ = _g_object_ref0 (h);
				_g_object_unref0 (ihd);
				ihd = _tmp6_;
				_g_object_unref0 (h);
				break;
			}
			_g_object_unref0 (h);
		}
		_g_object_unref0 (_h_it);
	}
	_tmp7_ = exogenesis_install_hard_disk_AvailableSize (ihd);
	_tmp8_ = exogenesis_install_hard_disk_get_StartSector (ihd);
	_tmp9_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp7_ - _tmp8_);
	_tmp10_ = _tmp9_;
	fprintf (stdout, "AVAILABLE SIZE %s\n", _tmp10_);
	_g_free0 (_tmp10_);
	if (ihd != NULL) {
		guint64 _tmp12_;
		_tmp12_ = exogenesis_install_hard_disk_AvailableSize (ihd);
		_tmp11_ = _tmp12_ > 0;
	} else {
		_tmp11_ = FALSE;
	}
	if (_tmp11_) {
		guint64 _tmp13_;
		ExogenesisFCreatePartition* _tmp14_ = NULL;
		_tmp13_ = exogenesis_install_hard_disk_AvailableSize (ihd);
		_tmp14_ = exogenesis_fcreate_partition_new (ihd, _tmp13_, self);
		_g_object_unref0 (fcp);
		fcp = g_object_ref_sink (_tmp14_);
		exogenesis_general_functions_ShowWindow (GTK_BOX (fcp), "Exogenesis", TRUE);
	}
	_g_object_unref0 (selectedHD);
	_g_object_unref0 (ihd);
	_g_object_unref0 (fcp);
}


void exogenesis_fhd_config_advanced_OnBtnCancel_Click (ExogenesisFHDConfigAdvanced* self) {
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* msg;
	gint _tmp1_;
	GtkResponseType res;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, "Do your really wish to cancel and return to the previous screen?");
	msg = g_object_ref_sink (_tmp0_);
	_tmp1_ = gtk_dialog_run ((GtkDialog*) msg);
	res = (GtkResponseType) _tmp1_;
	if (res == GTK_RESPONSE_YES) {
		GtkContainer* _tmp2_ = NULL;
		gtk_widget_destroy ((GtkWidget*) msg);
		_tmp2_ = gtk_widget_get_parent ((GtkWidget*) self);
		gtk_widget_destroy ((GtkWidget*) _tmp2_);
	}
	_g_object_unref0 (msg);
}


void exogenesis_fhd_config_advanced_OnCboHD_Changed (ExogenesisFHDConfigAdvanced* self) {
	ExogenesisHardDisk* di = NULL;
	ExogenesisHardDisk* _tmp0_ = NULL;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_SetTreeColumns (self);
	segmented_bar_RemoveAllSegments (self->priv->segbarHD);
	_tmp0_ = exogenesis_fhd_config_advanced_GetSelectedHD (self);
	_g_object_unref0 (di);
	di = _tmp0_;
	_tmp1_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->rdoHDBefore);
	if (_tmp1_) {
		exogenesis_fhd_config_advanced_ModelFromCurrentLayout (self);
	} else {
		exogenesis_fhd_config_advanced_ModelFromNewLayout (self);
	}
	gtk_tree_view_expand_all (self->priv->trvHDALayout);
	_g_object_unref0 (di);
}


void exogenesis_fhd_config_advanced_OnDeviceConnected (ExogenesisFHDConfigAdvanced* self) {
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_GetDiskInfo (self);
}


static void exogenesis_fhd_config_advanced_OnDriveMounted (ExogenesisFHDConfigAdvanced* self, const gchar* mountpoint) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (mountpoint != NULL);
	exogenesis_previous_os_GetFSTabMountPoints (exogenesis_gPreviousOS);
	exogenesis_fhd_config_advanced_OnCboHD_Changed (self);
}


static void exogenesis_fhd_config_advanced_OnRealized (ExogenesisFHDConfigAdvanced* self) {
	g_return_if_fail (self != NULL);
	exogenesis_fhd_config_advanced_OnCboHD_Changed (self);
	gtk_widget_show_all ((GtkWidget*) self);
}


static void exogenesis_fhd_config_advanced_class_init (ExogenesisFHDConfigAdvancedClass * klass) {
	exogenesis_fhd_config_advanced_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisFHDConfigAdvancedPrivate));
	G_OBJECT_CLASS (klass)->finalize = exogenesis_fhd_config_advanced_finalize;
}


static void exogenesis_fhd_config_advanced_instance_init (ExogenesisFHDConfigAdvanced * self) {
	GtkListStore* _tmp0_ = NULL;
	GtkTreeStore* _tmp1_ = NULL;
	GtkTreeStore* _tmp2_ = NULL;
	GtkListStore* _tmp3_ = NULL;
	GtkListStore* _tmp4_ = NULL;
	self->priv = EXOGENESIS_FHD_CONFIG_ADVANCED_GET_PRIVATE (self);
	_tmp0_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_HARD_DISK);
	self->priv->_lstDisks = _tmp0_;
	_tmp1_ = gtk_tree_store_new (14, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, EXOGENESIS_TYPE_HARD_DISK, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_UINT64, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN, EXOGENESIS_TYPE_PARTITION_INFO);
	self->priv->_lstPartitions = _tmp1_;
	_tmp2_ = gtk_tree_store_new (14, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, EXOGENESIS_TYPE_INSTALL_HARD_DISK, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_UINT64, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN, EXOGENESIS_TYPE_INSTALL_PARTITION);
	self->priv->_lstNewPartitions = _tmp2_;
	_tmp3_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_FILESYSTEM_TYPE);
	self->priv->_lstPartTypes = _tmp3_;
	_tmp4_ = gtk_list_store_new (2, G_TYPE_STRING, EXOGENESIS_TYPE_MOUNT_POINT);
	self->priv->_lstMountPoints = _tmp4_;
}


static void exogenesis_fhd_config_advanced_finalize (GObject* obj) {
	ExogenesisFHDConfigAdvanced * self;
	self = EXOGENESIS_FHD_CONFIG_ADVANCED (obj);
	_g_object_unref0 (self->priv->boxHDAdvanced);
	_g_object_unref0 (self->priv->boxHDAHead);
	_g_object_unref0 (self->priv->lblHDAdvancedTitle);
	_g_object_unref0 (self->priv->imgHD2);
	_g_object_unref0 (self->priv->sepHD2);
	_g_object_unref0 (self->priv->boxHD2Main);
	_g_object_unref0 (self->priv->btnHDAPrevious);
	_g_object_unref0 (self->priv->imgBtnHDAPrevious);
	_g_object_unref0 (self->priv->boxHDADetails);
	_g_object_unref0 (self->priv->boxHDAHardDisk);
	_g_object_unref0 (self->priv->lblHDADrives);
	_g_object_unref0 (self->priv->cboHDADrives);
	_g_object_unref0 (self->priv->btnHDAAddPartition);
	_g_object_unref0 (self->priv->boxBtnAddPartition);
	_g_object_unref0 (self->priv->imgBtnHDAAddPartition);
	_g_object_unref0 (self->priv->lblBtnHDAAddPartition);
	_g_object_unref0 (self->priv->boxHDWidget);
	_g_object_unref0 (self->priv->sclHDALayout);
	_g_object_unref0 (self->priv->trvHDALayout);
	_g_object_unref0 (self->priv->selHDALayout);
	_g_object_unref0 (self->priv->grdHDAButtons);
	_g_object_unref0 (self->priv->btnHDAApply);
	_g_object_unref0 (self->priv->btnHDARevert);
	_g_object_unref0 (self->priv->lblPrevious);
	_g_object_unref0 (self->priv->rdoHDBefore);
	_g_object_unref0 (self->priv->rdoHDAfter);
	_g_object_unref0 (self->priv->segbarHD);
	_g_object_unref0 (self->priv->_lstDisks);
	_g_object_unref0 (self->priv->_lstPartitions);
	_g_object_unref0 (self->priv->_lstNewPartitions);
	_g_object_unref0 (self->priv->_lstPartTypes);
	_g_object_unref0 (self->priv->_lstMountPoints);
	G_OBJECT_CLASS (exogenesis_fhd_config_advanced_parent_class)->finalize (obj);
}


GType exogenesis_fhd_config_advanced_get_type (void) {
	static volatile gsize exogenesis_fhd_config_advanced_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_fhd_config_advanced_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisFHDConfigAdvancedClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_fhd_config_advanced_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisFHDConfigAdvanced), 0, (GInstanceInitFunc) exogenesis_fhd_config_advanced_instance_init, NULL };
		GType exogenesis_fhd_config_advanced_type_id;
		exogenesis_fhd_config_advanced_type_id = g_type_register_static (GTK_TYPE_BOX, "ExogenesisFHDConfigAdvanced", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_fhd_config_advanced_type_id__volatile, exogenesis_fhd_config_advanced_type_id);
	}
	return exogenesis_fhd_config_advanced_type_id__volatile;
}



