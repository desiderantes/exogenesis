/* exogeneralfuncs.c generated by valac 0.12.1, the Vala compiler
 * generated from exogeneralfuncs.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <gdu/gdu.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define EXOGENESIS_TYPE_GENERAL_FUNCTIONS (exogenesis_general_functions_get_type ())
#define EXOGENESIS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctions))
#define EXOGENESIS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_GENERAL_FUNCTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))

typedef struct _ExogenesisGeneralFunctions ExogenesisGeneralFunctions;
typedef struct _ExogenesisGeneralFunctionsClass ExogenesisGeneralFunctionsClass;
typedef struct _ExogenesisGeneralFunctionsPrivate ExogenesisGeneralFunctionsPrivate;

#define EXOGENESIS_TYPE_EXO_XML (exogenesis_exo_xml_get_type ())
#define EXOGENESIS_EXO_XML(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_EXO_XML, ExogenesisexoXml))
#define EXOGENESIS_EXO_XML_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_EXO_XML, ExogenesisexoXmlClass))
#define EXOGENESIS_IS_EXO_XML(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_EXO_XML))
#define EXOGENESIS_IS_EXO_XML_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_EXO_XML))
#define EXOGENESIS_EXO_XML_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_EXO_XML, ExogenesisexoXmlClass))

typedef struct _ExogenesisexoXml ExogenesisexoXml;
typedef struct _ExogenesisexoXmlClass ExogenesisexoXmlClass;
#define _exogenesis_exo_xml_unref0(var) ((var == NULL) ? NULL : (var = (exogenesis_exo_xml_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define EXOGENESIS_TYPE_MAIN_WIN (exogenesis_main_win_get_type ())
#define EXOGENESIS_MAIN_WIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_MAIN_WIN, ExogenesisMainWin))
#define EXOGENESIS_MAIN_WIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_MAIN_WIN, ExogenesisMainWinClass))
#define EXOGENESIS_IS_MAIN_WIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_MAIN_WIN))
#define EXOGENESIS_IS_MAIN_WIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_MAIN_WIN))
#define EXOGENESIS_MAIN_WIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_MAIN_WIN, ExogenesisMainWinClass))

typedef struct _ExogenesisMainWin ExogenesisMainWin;
typedef struct _ExogenesisMainWinClass ExogenesisMainWinClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define EXOGENESIS_TYPE_EXO_ERROR (exogenesis_exo_error_get_type ())
#define EXOGENESIS_EXO_ERROR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_EXO_ERROR, ExogenesisexoError))
#define EXOGENESIS_EXO_ERROR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_EXO_ERROR, ExogenesisexoErrorClass))
#define EXOGENESIS_IS_EXO_ERROR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_EXO_ERROR))
#define EXOGENESIS_IS_EXO_ERROR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_EXO_ERROR))
#define EXOGENESIS_EXO_ERROR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_EXO_ERROR, ExogenesisexoErrorClass))

typedef struct _ExogenesisexoError ExogenesisexoError;
typedef struct _ExogenesisexoErrorClass ExogenesisexoErrorClass;
#define _exogenesis_exo_error_unref0(var) ((var == NULL) ? NULL : (var = (exogenesis_exo_error_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ExogenesisParamSpecGeneralFunctions ExogenesisParamSpecGeneralFunctions;
typedef struct _ExogenesisexoErrorPrivate ExogenesisexoErrorPrivate;
typedef struct _ExogenesisParamSpecexoError ExogenesisParamSpecexoError;

#define EXOGENESIS_TYPE_EXO_FILE_PATHS (exogenesis_exo_file_paths_get_type ())
#define EXOGENESIS_EXO_FILE_PATHS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_EXO_FILE_PATHS, ExogenesisexoFilePaths))
#define EXOGENESIS_EXO_FILE_PATHS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_EXO_FILE_PATHS, ExogenesisexoFilePathsClass))
#define EXOGENESIS_IS_EXO_FILE_PATHS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_EXO_FILE_PATHS))
#define EXOGENESIS_IS_EXO_FILE_PATHS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_EXO_FILE_PATHS))
#define EXOGENESIS_EXO_FILE_PATHS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_EXO_FILE_PATHS, ExogenesisexoFilePathsClass))

typedef struct _ExogenesisexoFilePaths ExogenesisexoFilePaths;
typedef struct _ExogenesisexoFilePathsClass ExogenesisexoFilePathsClass;
typedef struct _ExogenesisexoFilePathsPrivate ExogenesisexoFilePathsPrivate;
typedef struct _ExogenesisParamSpecexoFilePaths ExogenesisParamSpecexoFilePaths;

#define EXOGENESIS_TYPE_ENCODING (exogenesis_encoding_get_type ())
#define EXOGENESIS_ENCODING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_ENCODING, ExogenesisEncoding))
#define EXOGENESIS_ENCODING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_ENCODING, ExogenesisEncodingClass))
#define EXOGENESIS_IS_ENCODING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_ENCODING))
#define EXOGENESIS_IS_ENCODING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_ENCODING))
#define EXOGENESIS_ENCODING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_ENCODING, ExogenesisEncodingClass))

typedef struct _ExogenesisEncoding ExogenesisEncoding;
typedef struct _ExogenesisEncodingClass ExogenesisEncodingClass;
typedef struct _ExogenesisEncodingPrivate ExogenesisEncodingPrivate;

struct _ExogenesisGeneralFunctions {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisGeneralFunctionsPrivate * priv;
};

struct _ExogenesisGeneralFunctionsClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisGeneralFunctions *self);
};

struct _ExogenesisGeneralFunctionsPrivate {
	ExogenesisexoXml* _xmlH;
	gchar* _CurLang;
};

struct _ExogenesisParamSpecGeneralFunctions {
	GParamSpec parent_instance;
};

struct _ExogenesisexoError {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisexoErrorPrivate * priv;
};

struct _ExogenesisexoErrorClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisexoError *self);
};

struct _ExogenesisexoErrorPrivate {
	gint _Number;
	gchar* _Message;
};

struct _ExogenesisParamSpecexoError {
	GParamSpec parent_instance;
};

struct _ExogenesisexoFilePaths {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisexoFilePathsPrivate * priv;
};

struct _ExogenesisexoFilePathsClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisexoFilePaths *self);
};

struct _ExogenesisParamSpecexoFilePaths {
	GParamSpec parent_instance;
};

struct _ExogenesisEncoding {
	GObject parent_instance;
	ExogenesisEncodingPrivate * priv;
};

struct _ExogenesisEncodingClass {
	GObjectClass parent_class;
};


static gpointer exogenesis_general_functions_parent_class = NULL;
static guint* exogenesis_general_functions__barcolours;
static gint exogenesis_general_functions__barcolours_length1;
static guint* exogenesis_general_functions__barcolours = NULL;
static gint exogenesis_general_functions__barcolours_length1 = 0;
static gint _exogenesis_general_functions__barcolours_size_ = 0;
extern ExogenesisMainWin* exogenesis_exoMainWin;
static gpointer exogenesis_exo_error_parent_class = NULL;
static gpointer exogenesis_exo_file_paths_parent_class = NULL;
static gchar* exogenesis_exo_file_paths__SupportedLanguages;
static gchar* exogenesis_exo_file_paths__SupportedLanguages = NULL;
static gpointer exogenesis_encoding_parent_class = NULL;

gpointer exogenesis_general_functions_ref (gpointer instance);
void exogenesis_general_functions_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_general_functions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_general_functions (GValue* value, gpointer v_object);
void exogenesis_value_take_general_functions (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_general_functions (const GValue* value);
GType exogenesis_general_functions_get_type (void) G_GNUC_CONST;
gpointer exogenesis_exo_xml_ref (gpointer instance);
void exogenesis_exo_xml_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_exo_xml (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_exo_xml (GValue* value, gpointer v_object);
void exogenesis_value_take_exo_xml (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_exo_xml (const GValue* value);
GType exogenesis_exo_xml_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_GENERAL_FUNCTIONS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsPrivate))
enum  {
	EXOGENESIS_GENERAL_FUNCTIONS_DUMMY_PROPERTY
};
guint exogenesis_general_functions_BarColour (gint idx);
gdouble exogenesis_general_functions_ToDecimal (gdouble x);
void exogenesis_general_functions_ShowWindow (GtkBox* layout, const gchar* Title, gboolean Modal);
GType exogenesis_main_win_get_type (void) G_GNUC_CONST;
gchar* exogenesis_general_functions_Read_UTF8 (const gchar* path, gchar** encoding, GError** error);
gchar* exogenesis_encoding_get_charset (const gchar* text);
gchar* exogenesis_encoding_convert (const gchar* text, const gchar* to_codeset, const gchar* from_codeset, GError** error);
gchar* exogenesis_general_functions_FormatHDSize (guint64 size);
void exogenesis_general_functions_LogIt (const gchar* Message);
ExogenesisGeneralFunctions* exogenesis_general_functions_new (void);
ExogenesisGeneralFunctions* exogenesis_general_functions_construct (GType object_type);
ExogenesisexoXml* exogenesis_exo_xml_new (void);
ExogenesisexoXml* exogenesis_exo_xml_construct (GType object_type);
gchar* exogenesis_general_functions_GetOSCurrentLanguage (ExogenesisGeneralFunctions* self);
gchar* exogenesis_general_functions_GetGDMCurrentLanguage (ExogenesisGeneralFunctions* self);
gboolean exogenesis_general_functions_SetLanguage (ExogenesisGeneralFunctions* self, const gchar* selectedlang);
gchar* exogenesis_general_functions_GetLabelText (ExogenesisGeneralFunctions* self, const gchar* formname, const gchar* controlname);
gchar* exogenesis_exo_xml_GetText (ExogenesisexoXml* self, const gchar* currentlanguage, const gchar* formname, const gchar* item);
GtkResponseType exogenesis_general_functions_ShowDialogue (ExogenesisGeneralFunctions* self, const gchar* Title, const gchar* Message, GtkButtonsType buttons, GtkMessageType type);
gchar* exogenesis_general_functions_ReadTextFile (ExogenesisGeneralFunctions* self, const gchar* filename);
ExogenesisexoError* exogenesis_exo_error_new (void);
ExogenesisexoError* exogenesis_exo_error_construct (GType object_type);
gpointer exogenesis_exo_error_ref (gpointer instance);
void exogenesis_exo_error_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_exo_error (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_exo_error (GValue* value, gpointer v_object);
void exogenesis_value_take_exo_error (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_exo_error (const GValue* value);
GType exogenesis_exo_error_get_type (void) G_GNUC_CONST;
void exogenesis_exo_error_set_Number (ExogenesisexoError* self, gint value);
void exogenesis_exo_error_set_Message (ExogenesisexoError* self, const gchar* value);
const gchar* exogenesis_exo_error_get_Message (ExogenesisexoError* self);
static void g_cclosure_user_marshal_VOID__EXOGENESIS_EXO_ERROR (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void exogenesis_general_functions_finalize (ExogenesisGeneralFunctions* obj);
#define EXOGENESIS_EXO_ERROR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_EXO_ERROR, ExogenesisexoErrorPrivate))
enum  {
	EXOGENESIS_EXO_ERROR_DUMMY_PROPERTY
};
gint exogenesis_exo_error_get_Number (ExogenesisexoError* self);
static void exogenesis_exo_error_finalize (ExogenesisexoError* obj);
gpointer exogenesis_exo_file_paths_ref (gpointer instance);
void exogenesis_exo_file_paths_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_exo_file_paths (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_exo_file_paths (GValue* value, gpointer v_object);
void exogenesis_value_take_exo_file_paths (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_exo_file_paths (const GValue* value);
GType exogenesis_exo_file_paths_get_type (void) G_GNUC_CONST;
enum  {
	EXOGENESIS_EXO_FILE_PATHS_DUMMY_PROPERTY
};
ExogenesisexoFilePaths* exogenesis_exo_file_paths_new (void);
ExogenesisexoFilePaths* exogenesis_exo_file_paths_construct (GType object_type);
const gchar* exogenesis_exo_file_paths_get_SupportedLanguages (void);
void exogenesis_exo_file_paths_set_SupportedLanguages (const gchar* value);
static void exogenesis_exo_file_paths_finalize (ExogenesisexoFilePaths* obj);
GType exogenesis_encoding_get_type (void) G_GNUC_CONST;
enum  {
	EXOGENESIS_ENCODING_DUMMY_PROPERTY
};
static gboolean exogenesis_encoding_test (const gchar* text, const gchar* charset);
ExogenesisEncoding* exogenesis_encoding_new (void);
ExogenesisEncoding* exogenesis_encoding_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const gchar* EXOGENESIS_ENCODING_charsets[2] = {"UTF-8", "ISO-8859-15"};

guint exogenesis_general_functions_BarColour (gint idx) {
	guint result = 0U;
	result = exogenesis_general_functions__barcolours[idx];
	return result;
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = g_ascii_strtod (str, NULL);
	result = _tmp0_;
	return result;
}


gdouble exogenesis_general_functions_ToDecimal (gdouble x) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* y;
	gchar* _tmp2_;
	gchar* z;
	gdouble _tmp3_;
	_tmp0_ = trunc (x);
	_tmp1_ = double_to_string (_tmp0_);
	y = _tmp1_;
	_tmp2_ = g_strconcat ("0.", y, NULL);
	z = _tmp2_;
	fprintf (stdout, "TRUNC = %s\n", z);
	_tmp3_ = double_parse (z);
	result = _tmp3_;
	_g_free0 (z);
	_g_free0 (y);
	return result;
}


void exogenesis_general_functions_ShowWindow (GtkBox* layout, const gchar* Title, gboolean Modal) {
	GtkAllocation alloc = {0};
	GtkAllocation _tmp0_ = {0};
	GtkWindow* _tmp1_ = NULL;
	GtkWindow* win;
	gint _tmp2_;
	gint _tmp3_;
	g_return_if_fail (layout != NULL);
	g_return_if_fail (Title != NULL);
	gtk_widget_get_allocation ((GtkWidget*) layout, &_tmp0_);
	alloc = _tmp0_;
	_tmp1_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	win = g_object_ref_sink (_tmp1_);
	g_object_get ((GtkWidget*) layout, "height-request", &_tmp2_, NULL);
	g_object_set ((GtkWidget*) win, "height-request", _tmp2_, NULL);
	g_object_get ((GtkWidget*) layout, "width-request", &_tmp3_, NULL);
	g_object_set ((GtkWidget*) win, "width-request", _tmp3_, NULL);
	gtk_window_set_title (win, Title);
	gtk_window_set_modal (win, Modal);
	gtk_container_add ((GtkContainer*) win, (GtkWidget*) layout);
	gtk_window_set_type_hint (win, GDK_WINDOW_TYPE_HINT_NORMAL);
	gtk_window_set_transient_for (win, (GtkWindow*) exogenesis_exoMainWin);
	gtk_window_set_position (win, GTK_WIN_POS_CENTER_ALWAYS);
	gtk_widget_show_all ((GtkWidget*) win);
	_g_object_unref0 (win);
}


gchar* exogenesis_general_functions_Read_UTF8 (const gchar* path, gchar** encoding, GError** error) {
	gchar* _encoding = NULL;
	gchar* result = NULL;
	gchar* text;
	gchar* _tmp0_;
	gchar* contents;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	text = NULL;
	_tmp0_ = g_strdup ("");
	contents = _tmp0_;
	g_file_get_contents (path, &_tmp1_, NULL, &_inner_error_);
	_g_free0 (text);
	text = _tmp1_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (contents);
		_g_free0 (text);
		return NULL;
	}
	_tmp2_ = exogenesis_encoding_get_charset (text);
	_g_free0 (_encoding);
	_encoding = _tmp2_;
	if (_encoding != NULL) {
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp3_ = exogenesis_encoding_convert (text, "UTF-8", _encoding, &_inner_error_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (contents);
			_g_free0 (text);
			return NULL;
		}
		_g_free0 (contents);
		contents = _tmp4_;
	} else {
		gchar* _tmp5_;
		_tmp5_ = g_strdup ("");
		_g_free0 (contents);
		contents = _tmp5_;
		fprintf (stdout, "error encoding");
	}
	result = contents;
	_g_free0 (text);
	if (encoding) {
		*encoding = _encoding;
	} else {
		_g_free0 (_encoding);
	}
	return result;
}


gchar* exogenesis_general_functions_FormatHDSize (guint64 size) {
	gchar* result = NULL;
	gdouble gSize;
	gchar* _tmp0_;
	gchar* sizetype;
	gdouble _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gSize = ((((gdouble) size) / 1024) / 1024) / 1024;
	_tmp0_ = g_strdup ("GB");
	sizetype = _tmp0_;
	if (gSize < 1) {
		gchar* _tmp1_;
		gSize = gSize * 1024;
		_tmp1_ = g_strdup ("MB");
		_g_free0 (sizetype);
		sizetype = _tmp1_;
	}
	if (gSize < 1) {
		gchar* _tmp2_;
		gSize = gSize * 1024;
		_tmp2_ = g_strdup ("KB");
		_g_free0 (sizetype);
		sizetype = _tmp2_;
	}
	_tmp3_ = round (gSize);
	gSize = _tmp3_;
	_tmp4_ = gdu_util_get_size_for_display (size, FALSE, FALSE);
	_tmp5_ = g_strdup (_tmp4_);
	result = _tmp5_;
	_g_free0 (sizetype);
	return result;
}


void exogenesis_general_functions_LogIt (const gchar* Message) {
	g_return_if_fail (Message != NULL);
	fprintf (stdout, "%s", Message);
}


ExogenesisGeneralFunctions* exogenesis_general_functions_construct (GType object_type) {
	ExogenesisGeneralFunctions* self = NULL;
	ExogenesisexoXml* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	self = (ExogenesisGeneralFunctions*) g_type_create_instance (object_type);
	_tmp0_ = exogenesis_exo_xml_new ();
	_exogenesis_exo_xml_unref0 (self->priv->_xmlH);
	self->priv->_xmlH = _tmp0_;
	_tmp1_ = exogenesis_general_functions_GetOSCurrentLanguage (self);
	_g_free0 (self->priv->_CurLang);
	self->priv->_CurLang = _tmp1_;
	return self;
}


ExogenesisGeneralFunctions* exogenesis_general_functions_new (void) {
	return exogenesis_general_functions_construct (EXOGENESIS_TYPE_GENERAL_FUNCTIONS);
}


gchar* exogenesis_general_functions_GetOSCurrentLanguage (ExogenesisGeneralFunctions* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar* _tmp4_;
	gchar* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_getenv ("LANG");
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ".", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = g_strdup (_tmp3_[0]);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp5_;
	return result;
}


gchar* exogenesis_general_functions_GetGDMCurrentLanguage (ExogenesisGeneralFunctions* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar* _tmp4_;
	gchar* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_getenv ("GDM_LANG");
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ".", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = g_strdup (_tmp3_[0]);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp5_;
	return result;
}


gboolean exogenesis_general_functions_SetLanguage (ExogenesisGeneralFunctions* self, const gchar* selectedlang) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (selectedlang != NULL, FALSE);
	result = TRUE;
	return result;
}


gchar* exogenesis_general_functions_GetLabelText (ExogenesisGeneralFunctions* self, const gchar* formname, const gchar* controlname) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (formname != NULL, NULL);
	g_return_val_if_fail (controlname != NULL, NULL);
	_tmp0_ = exogenesis_exo_xml_GetText (self->priv->_xmlH, self->priv->_CurLang, formname, controlname);
	result = _tmp0_;
	return result;
}


GtkResponseType exogenesis_general_functions_ShowDialogue (ExogenesisGeneralFunctions* self, const gchar* Title, const gchar* Message, GtkButtonsType buttons, GtkMessageType type) {
	GtkResponseType result = 0;
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* msg;
	gint _tmp1_;
	GtkResponseType res;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (Title != NULL, 0);
	g_return_val_if_fail (Message != NULL, 0);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, type, buttons, Message);
	msg = g_object_ref_sink (_tmp0_);
	gtk_window_set_title ((GtkWindow*) msg, Title);
	gtk_window_set_type_hint ((GtkWindow*) msg, GDK_WINDOW_TYPE_HINT_POPUP_MENU);
	gtk_window_set_transient_for ((GtkWindow*) msg, (GtkWindow*) exogenesis_exoMainWin);
	gtk_window_set_position ((GtkWindow*) msg, GTK_WIN_POS_CENTER_ALWAYS);
	_tmp1_ = gtk_dialog_run ((GtkDialog*) msg);
	res = (GtkResponseType) _tmp1_;
	gtk_widget_destroy ((GtkWidget*) msg);
	result = res;
	_g_object_unref0 (msg);
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* exogenesis_general_functions_ReadTextFile (ExogenesisGeneralFunctions* self, const gchar* filename) {
	gchar* result = NULL;
	GFile* _tmp0_ = NULL;
	GFile* file;
	GString* _tmp1_ = NULL;
	GString* sb;
	gboolean _tmp2_;
	const gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = g_file_new_for_path (filename);
	file = _tmp0_;
	_tmp1_ = g_string_new ("");
	sb = _tmp1_;
	_tmp2_ = g_file_query_exists (file, NULL);
	if (!_tmp2_) {
		ExogenesisexoError* _tmp3_ = NULL;
		ExogenesisexoError* err;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		const gchar* _tmp6_ = NULL;
		_tmp3_ = exogenesis_exo_error_new ();
		err = _tmp3_;
		exogenesis_exo_error_set_Number (err, 1001);
		_tmp4_ = g_strdup_printf ("%s not found.", filename);
		_tmp5_ = _tmp4_;
		exogenesis_exo_error_set_Message (err, _tmp5_);
		_g_free0 (_tmp5_);
		_tmp6_ = exogenesis_exo_error_get_Message (err);
		fprintf (stdout, "%s\n", _tmp6_);
		g_string_append (sb, "");
		g_signal_emit_by_name (self, "error-found", err);
		_exogenesis_exo_error_unref0 (err);
	} else {
		gchar* line = NULL;
		GFileInputStream* _tmp7_ = NULL;
		GFileInputStream* _tmp8_;
		GFileInputStream* _tmp9_;
		GDataInputStream* _tmp10_ = NULL;
		GDataInputStream* _tmp11_;
		GDataInputStream* stream;
		_tmp7_ = g_file_read (file, NULL, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_free0 (line);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch13_g_io_error;
			}
			goto __finally13;
		}
		_tmp9_ = _tmp8_;
		_tmp10_ = g_data_input_stream_new ((GInputStream*) _tmp9_);
		_tmp11_ = _tmp10_;
		_g_object_unref0 (_tmp9_);
		stream = _tmp11_;
		while (TRUE) {
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_;
			gchar* _tmp14_ = NULL;
			gchar* _tmp15_;
			_tmp12_ = g_data_input_stream_read_line (stream, NULL, NULL, &_inner_error_);
			_tmp13_ = _tmp12_;
			if (_inner_error_ != NULL) {
				_g_object_unref0 (stream);
				_g_free0 (line);
				if (_inner_error_->domain == G_IO_ERROR) {
					goto __catch13_g_io_error;
				}
				_g_object_unref0 (stream);
				_g_free0 (line);
				_g_string_free0 (sb);
				_g_object_unref0 (file);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_g_free0 (line);
			line = _tmp13_;
			if (!(line != NULL)) {
				break;
			}
			_tmp14_ = g_strdup_printf ("%s\n", line);
			_tmp15_ = _tmp14_;
			g_string_append (sb, _tmp15_);
			_g_free0 (_tmp15_);
		}
		_g_object_unref0 (stream);
		_g_free0 (line);
	}
	_tmp16_ = string_to_string (sb->str);
	_tmp17_ = g_strdup (_tmp16_);
	result = _tmp17_;
	_g_string_free0 (sb);
	_g_object_unref0 (file);
	return result;
	goto __finally13;
	__catch13_g_io_error:
	{
		GError * e;
		ExogenesisexoError* _tmp18_ = NULL;
		ExogenesisexoError* err;
		gchar* _tmp19_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp18_ = exogenesis_exo_error_new ();
		err = _tmp18_;
		exogenesis_exo_error_set_Number (err, e->code);
		exogenesis_exo_error_set_Message (err, e->message);
		g_signal_emit_by_name (self, "error-found", err);
		_tmp19_ = g_strdup ("");
		result = _tmp19_;
		_exogenesis_exo_error_unref0 (err);
		_g_error_free0 (e);
		_g_string_free0 (sb);
		_g_object_unref0 (file);
		return result;
	}
	__finally13:
	_g_string_free0 (sb);
	_g_object_unref0 (file);
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


static void g_cclosure_user_marshal_VOID__EXOGENESIS_EXO_ERROR (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__EXOGENESIS_EXO_ERROR) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__EXOGENESIS_EXO_ERROR callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__EXOGENESIS_EXO_ERROR) (marshal_data ? marshal_data : cc->callback);
	callback (data1, exogenesis_value_get_exo_error (param_values + 1), data2);
}


static void exogenesis_value_general_functions_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_general_functions_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_general_functions_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_general_functions_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_general_functions_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_general_functions_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_general_functions_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisGeneralFunctions* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_general_functions_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_general_functions_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisGeneralFunctions** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_general_functions_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_general_functions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecGeneralFunctions* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_GENERAL_FUNCTIONS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_general_functions (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_GENERAL_FUNCTIONS), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_general_functions (GValue* value, gpointer v_object) {
	ExogenesisGeneralFunctions* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_GENERAL_FUNCTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_GENERAL_FUNCTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_general_functions_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_general_functions_unref (old);
	}
}


void exogenesis_value_take_general_functions (GValue* value, gpointer v_object) {
	ExogenesisGeneralFunctions* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_GENERAL_FUNCTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_GENERAL_FUNCTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_general_functions_unref (old);
	}
}


static void exogenesis_general_functions_class_init (ExogenesisGeneralFunctionsClass * klass) {
	guint* _tmp0_ = NULL;
	exogenesis_general_functions_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_GENERAL_FUNCTIONS_CLASS (klass)->finalize = exogenesis_general_functions_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisGeneralFunctionsPrivate));
	g_signal_new ("error_found", EXOGENESIS_TYPE_GENERAL_FUNCTIONS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__EXOGENESIS_EXO_ERROR, G_TYPE_NONE, 1, EXOGENESIS_TYPE_EXO_ERROR);
	_tmp0_ = g_new0 (guint, 8);
	_tmp0_[0] = (guint) 0xf57900;
	_tmp0_[1] = (guint) 0x3465a4;
	_tmp0_[2] = (guint) 0x73d216;
	_tmp0_[3] = (guint) 0xCA4141;
	_tmp0_[4] = (guint) 0x9CF2DE;
	_tmp0_[5] = (guint) 0xFFFE8E;
	_tmp0_[6] = (guint) 0xA2A2A2;
	_tmp0_[7] = (guint) 0xE1E1E1;
	exogenesis_general_functions__barcolours = _tmp0_;
	exogenesis_general_functions__barcolours_length1 = 8;
}


static void exogenesis_general_functions_instance_init (ExogenesisGeneralFunctions * self) {
	self->priv = EXOGENESIS_GENERAL_FUNCTIONS_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void exogenesis_general_functions_finalize (ExogenesisGeneralFunctions* obj) {
	ExogenesisGeneralFunctions * self;
	self = EXOGENESIS_GENERAL_FUNCTIONS (obj);
	_exogenesis_exo_xml_unref0 (self->priv->_xmlH);
	_g_free0 (self->priv->_CurLang);
}


GType exogenesis_general_functions_get_type (void) {
	static volatile gsize exogenesis_general_functions_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_general_functions_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_general_functions_init, exogenesis_value_general_functions_free_value, exogenesis_value_general_functions_copy_value, exogenesis_value_general_functions_peek_pointer, "p", exogenesis_value_general_functions_collect_value, "p", exogenesis_value_general_functions_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisGeneralFunctionsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_general_functions_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisGeneralFunctions), 0, (GInstanceInitFunc) exogenesis_general_functions_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_general_functions_type_id;
		exogenesis_general_functions_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisGeneralFunctions", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_general_functions_type_id__volatile, exogenesis_general_functions_type_id);
	}
	return exogenesis_general_functions_type_id__volatile;
}


gpointer exogenesis_general_functions_ref (gpointer instance) {
	ExogenesisGeneralFunctions* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_general_functions_unref (gpointer instance) {
	ExogenesisGeneralFunctions* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_GENERAL_FUNCTIONS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisexoError* exogenesis_exo_error_construct (GType object_type) {
	ExogenesisexoError* self = NULL;
	self = (ExogenesisexoError*) g_type_create_instance (object_type);
	return self;
}


ExogenesisexoError* exogenesis_exo_error_new (void) {
	return exogenesis_exo_error_construct (EXOGENESIS_TYPE_EXO_ERROR);
}


gint exogenesis_exo_error_get_Number (ExogenesisexoError* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_Number;
	return result;
}


void exogenesis_exo_error_set_Number (ExogenesisexoError* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_Number = value;
}


const gchar* exogenesis_exo_error_get_Message (ExogenesisexoError* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Message;
	return result;
}


void exogenesis_exo_error_set_Message (ExogenesisexoError* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Message);
	self->priv->_Message = _tmp0_;
}


static void exogenesis_value_exo_error_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_exo_error_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_exo_error_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_exo_error_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_exo_error_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_exo_error_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_exo_error_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisexoError* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_exo_error_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_exo_error_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisexoError** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_exo_error_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_exo_error (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecexoError* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_EXO_ERROR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_exo_error (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_ERROR), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_exo_error (GValue* value, gpointer v_object) {
	ExogenesisexoError* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_ERROR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_EXO_ERROR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_exo_error_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_exo_error_unref (old);
	}
}


void exogenesis_value_take_exo_error (GValue* value, gpointer v_object) {
	ExogenesisexoError* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_ERROR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_EXO_ERROR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_exo_error_unref (old);
	}
}


static void exogenesis_exo_error_class_init (ExogenesisexoErrorClass * klass) {
	exogenesis_exo_error_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_EXO_ERROR_CLASS (klass)->finalize = exogenesis_exo_error_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisexoErrorPrivate));
}


static void exogenesis_exo_error_instance_init (ExogenesisexoError * self) {
	self->priv = EXOGENESIS_EXO_ERROR_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void exogenesis_exo_error_finalize (ExogenesisexoError* obj) {
	ExogenesisexoError * self;
	self = EXOGENESIS_EXO_ERROR (obj);
	_g_free0 (self->priv->_Message);
}


GType exogenesis_exo_error_get_type (void) {
	static volatile gsize exogenesis_exo_error_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_exo_error_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_exo_error_init, exogenesis_value_exo_error_free_value, exogenesis_value_exo_error_copy_value, exogenesis_value_exo_error_peek_pointer, "p", exogenesis_value_exo_error_collect_value, "p", exogenesis_value_exo_error_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisexoErrorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_exo_error_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisexoError), 0, (GInstanceInitFunc) exogenesis_exo_error_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_exo_error_type_id;
		exogenesis_exo_error_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisexoError", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_exo_error_type_id__volatile, exogenesis_exo_error_type_id);
	}
	return exogenesis_exo_error_type_id__volatile;
}


gpointer exogenesis_exo_error_ref (gpointer instance) {
	ExogenesisexoError* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_exo_error_unref (gpointer instance) {
	ExogenesisexoError* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_EXO_ERROR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisexoFilePaths* exogenesis_exo_file_paths_construct (GType object_type) {
	ExogenesisexoFilePaths* self = NULL;
	self = (ExogenesisexoFilePaths*) g_type_create_instance (object_type);
	return self;
}


ExogenesisexoFilePaths* exogenesis_exo_file_paths_new (void) {
	return exogenesis_exo_file_paths_construct (EXOGENESIS_TYPE_EXO_FILE_PATHS);
}


const gchar* exogenesis_exo_file_paths_get_SupportedLanguages (void) {
	const gchar* result;
	result = exogenesis_exo_file_paths__SupportedLanguages;
	return result;
}


void exogenesis_exo_file_paths_set_SupportedLanguages (const gchar* value) {
	gchar* _tmp0_;
	_tmp0_ = g_strdup (value);
	_g_free0 (exogenesis_exo_file_paths__SupportedLanguages);
	exogenesis_exo_file_paths__SupportedLanguages = _tmp0_;
}


static void exogenesis_value_exo_file_paths_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_exo_file_paths_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_exo_file_paths_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_exo_file_paths_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_exo_file_paths_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_exo_file_paths_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_exo_file_paths_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisexoFilePaths* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_exo_file_paths_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_exo_file_paths_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisexoFilePaths** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_exo_file_paths_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_exo_file_paths (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecexoFilePaths* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_EXO_FILE_PATHS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_exo_file_paths (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_FILE_PATHS), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_exo_file_paths (GValue* value, gpointer v_object) {
	ExogenesisexoFilePaths* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_FILE_PATHS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_EXO_FILE_PATHS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_exo_file_paths_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_exo_file_paths_unref (old);
	}
}


void exogenesis_value_take_exo_file_paths (GValue* value, gpointer v_object) {
	ExogenesisexoFilePaths* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_EXO_FILE_PATHS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_EXO_FILE_PATHS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_exo_file_paths_unref (old);
	}
}


static void exogenesis_exo_file_paths_class_init (ExogenesisexoFilePathsClass * klass) {
	exogenesis_exo_file_paths_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_EXO_FILE_PATHS_CLASS (klass)->finalize = exogenesis_exo_file_paths_finalize;
}


static void exogenesis_exo_file_paths_instance_init (ExogenesisexoFilePaths * self) {
	self->ref_count = 1;
}


static void exogenesis_exo_file_paths_finalize (ExogenesisexoFilePaths* obj) {
	ExogenesisexoFilePaths * self;
	self = EXOGENESIS_EXO_FILE_PATHS (obj);
}


GType exogenesis_exo_file_paths_get_type (void) {
	static volatile gsize exogenesis_exo_file_paths_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_exo_file_paths_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_exo_file_paths_init, exogenesis_value_exo_file_paths_free_value, exogenesis_value_exo_file_paths_copy_value, exogenesis_value_exo_file_paths_peek_pointer, "p", exogenesis_value_exo_file_paths_collect_value, "p", exogenesis_value_exo_file_paths_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisexoFilePathsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_exo_file_paths_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisexoFilePaths), 0, (GInstanceInitFunc) exogenesis_exo_file_paths_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_exo_file_paths_type_id;
		exogenesis_exo_file_paths_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisexoFilePaths", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_exo_file_paths_type_id__volatile, exogenesis_exo_file_paths_type_id);
	}
	return exogenesis_exo_file_paths_type_id__volatile;
}


gpointer exogenesis_exo_file_paths_ref (gpointer instance) {
	ExogenesisexoFilePaths* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_exo_file_paths_unref (gpointer instance) {
	ExogenesisexoFilePaths* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_EXO_FILE_PATHS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


gchar* exogenesis_encoding_convert (const gchar* text, const gchar* to_codeset, const gchar* from_codeset, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	g_return_val_if_fail (to_codeset != NULL, NULL);
	g_return_val_if_fail (from_codeset != NULL, NULL);
	_tmp0_ = g_convert (text, (gssize) (-1), to_codeset, from_codeset, NULL, NULL, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	result = _tmp1_;
	return result;
}


gchar* exogenesis_encoding_get_charset (const gchar* text) {
	gchar* result = NULL;
	gchar* charset;
	g_return_val_if_fail (text != NULL, NULL);
	charset = NULL;
	{
		const gchar** c_collection;
		int c_collection_length1;
		int c_it;
		c_collection = EXOGENESIS_ENCODING_charsets;
		c_collection_length1 = G_N_ELEMENTS (EXOGENESIS_ENCODING_charsets);
		for (c_it = 0; c_it < G_N_ELEMENTS (EXOGENESIS_ENCODING_charsets); c_it = c_it + 1) {
			gchar* _tmp0_;
			gchar* c;
			_tmp0_ = g_strdup (c_collection[c_it]);
			c = _tmp0_;
			{
				gboolean _tmp1_;
				_tmp1_ = exogenesis_encoding_test (text, c);
				if (_tmp1_) {
					gchar* _tmp2_;
					_tmp2_ = g_strdup (c);
					_g_free0 (charset);
					charset = _tmp2_;
					_g_free0 (c);
					break;
				}
				_g_free0 (c);
			}
		}
	}
	result = charset;
	return result;
}


static gboolean exogenesis_encoding_test (const gchar* text, const gchar* charset) {
	gboolean result = FALSE;
	gboolean valid;
	gchar* convert = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (text != NULL, FALSE);
	g_return_val_if_fail (charset != NULL, FALSE);
	valid = FALSE;
	_tmp0_ = g_convert (text, (gssize) (-1), "UTF-8", charset, NULL, NULL, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		_g_free0 (convert);
		goto __catch14_g_error;
	}
	_g_free0 (convert);
	convert = _tmp1_;
	valid = TRUE;
	_g_free0 (convert);
	goto __finally14;
	__catch14_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_debug ("exogeneralfuncs.vala:230: %s", e->message);
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = valid;
	return result;
}


ExogenesisEncoding* exogenesis_encoding_construct (GType object_type) {
	ExogenesisEncoding * self = NULL;
	self = (ExogenesisEncoding*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisEncoding* exogenesis_encoding_new (void) {
	return exogenesis_encoding_construct (EXOGENESIS_TYPE_ENCODING);
}


static void exogenesis_encoding_class_init (ExogenesisEncodingClass * klass) {
	exogenesis_encoding_parent_class = g_type_class_peek_parent (klass);
}


static void exogenesis_encoding_instance_init (ExogenesisEncoding * self) {
}


GType exogenesis_encoding_get_type (void) {
	static volatile gsize exogenesis_encoding_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_encoding_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisEncodingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_encoding_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisEncoding), 0, (GInstanceInitFunc) exogenesis_encoding_instance_init, NULL };
		GType exogenesis_encoding_type_id;
		exogenesis_encoding_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisEncoding", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_encoding_type_id__volatile, exogenesis_encoding_type_id);
	}
	return exogenesis_encoding_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



