/* exoFInstall.c generated by valac 0.12.1, the Vala compiler
 * generated from exoFInstall.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define EXOGENESIS_TYPE_FINSTALL (exogenesis_finstall_get_type ())
#define EXOGENESIS_FINSTALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_FINSTALL, ExogenesisFInstall))
#define EXOGENESIS_FINSTALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_FINSTALL, ExogenesisFInstallClass))
#define EXOGENESIS_IS_FINSTALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_FINSTALL))
#define EXOGENESIS_IS_FINSTALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_FINSTALL))
#define EXOGENESIS_FINSTALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_FINSTALL, ExogenesisFInstallClass))

typedef struct _ExogenesisFInstall ExogenesisFInstall;
typedef struct _ExogenesisFInstallClass ExogenesisFInstallClass;
typedef struct _ExogenesisFInstallPrivate ExogenesisFInstallPrivate;

#define TYPE_SEGMENTED_BAR (segmented_bar_get_type ())
#define SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SEGMENTED_BAR, SegmentedBar))
#define SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SEGMENTED_BAR, SegmentedBarClass))
#define IS_SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SEGMENTED_BAR))
#define IS_SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SEGMENTED_BAR))
#define SEGMENTED_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SEGMENTED_BAR, SegmentedBarClass))

typedef struct _SegmentedBar SegmentedBar;
typedef struct _SegmentedBarClass SegmentedBarClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _SegmentedBarPrivate SegmentedBarPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _ExogenesisFInstall {
	GtkLayout parent_instance;
	ExogenesisFInstallPrivate * priv;
};

struct _ExogenesisFInstallClass {
	GtkLayoutClass parent_class;
};

struct _ExogenesisFInstallPrivate {
	GtkFixed* fxdLayout;
	GtkImage* imgInfo;
	GtkLabel* lblInfo;
	GtkVBox* vbxProgress;
	SegmentedBar* segProgress;
	gchar** _imageFiles;
	gint _imageFiles_length1;
	gint __imageFiles_size_;
	guint _timerId;
	gint _lastImgId;
	gint _progress;
};

struct _SegmentedBar {
	GtkWidget parent_instance;
	SegmentedBarPrivate * priv;
	gboolean show_labels;
	gboolean reflect;
};

struct _SegmentedBarClass {
	GtkWidgetClass parent_class;
};


static gpointer exogenesis_finstall_parent_class = NULL;
extern gchar* exogenesis_AppPath;

GType exogenesis_finstall_get_type (void) G_GNUC_CONST;
GType segmented_bar_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_FINSTALL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_FINSTALL, ExogenesisFInstallPrivate))
enum  {
	EXOGENESIS_FINSTALL_DUMMY_PROPERTY
};
ExogenesisFInstall* exogenesis_finstall_new (void);
ExogenesisFInstall* exogenesis_finstall_construct (GType object_type);
static void exogenesis_finstall_GetImageFiles (ExogenesisFInstall* self);
static void exogenesis_finstall_Build (ExogenesisFInstall* self);
#define EXOGENESIS_UIPath "/home/steve/1-work/anjuta/exogenesis/src/exogenesis.ui"
SegmentedBar* segmented_bar_new (void);
SegmentedBar* segmented_bar_construct (GType object_type);
void segmented_bar_set_BarHeight (SegmentedBar* self, gint value);
gint segmented_bar_get_BarHeight (SegmentedBar* self);
void segmented_bar_set_HorizontalPadding (SegmentedBar* self, gint value);
void segmented_bar_set_ShowReflection (SegmentedBar* self, gboolean value);
void exogenesis_finstall_OnFxdLayout_Realise (ExogenesisFInstall* self);
static void _exogenesis_finstall_OnFxdLayout_Realise_gtk_widget_realize (GtkWidget* _sender, gpointer self);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static void exogenesis_finstall_UpdateProgressBar (ExogenesisFInstall* self, gint percentage);
void segmented_bar_AddSegmentRgb (SegmentedBar* self, const gchar* title, gint percent, guint rgbColor);
guint exogenesis_general_functions_BarColour (gint idx);
gboolean exogenesis_finstall_OnTimer (ExogenesisFInstall* self);
void exogenesis_finstall_DisplayImage (ExogenesisFInstall* self);
static void exogenesis_finstall_UpdateLabel (ExogenesisFInstall* self, const gchar* text);
static gboolean _exogenesis_finstall_OnTimer_gsource_func (gpointer self);
static void exogenesis_finstall_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


ExogenesisFInstall* exogenesis_finstall_construct (GType object_type) {
	ExogenesisFInstall * self = NULL;
	self = (ExogenesisFInstall*) g_object_new (object_type, NULL);
	exogenesis_finstall_GetImageFiles (self);
	exogenesis_finstall_Build (self);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->fxdLayout);
	return self;
}


ExogenesisFInstall* exogenesis_finstall_new (void) {
	return exogenesis_finstall_construct (EXOGENESIS_TYPE_FINSTALL);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _exogenesis_finstall_OnFxdLayout_Realise_gtk_widget_realize (GtkWidget* _sender, gpointer self) {
	exogenesis_finstall_OnFxdLayout_Realise (self);
}


static void exogenesis_finstall_Build (ExogenesisFInstall* self) {
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* builder;
	GObject* _tmp1_ = NULL;
	GtkFixed* _tmp2_;
	GObject* _tmp3_ = NULL;
	GtkImage* _tmp4_;
	GObject* _tmp5_ = NULL;
	GtkLabel* _tmp6_;
	GObject* _tmp7_ = NULL;
	GtkVBox* _tmp8_;
	SegmentedBar* _tmp9_ = NULL;
	gint _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_builder_new ();
	builder = _tmp0_;
	gtk_builder_add_from_file (builder, EXOGENESIS_UIPath, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		goto __catch6_g_error;
	}
	_tmp1_ = gtk_builder_get_object (builder, "fxdProgress");
	_tmp2_ = _g_object_ref0 (GTK_FIXED (_tmp1_));
	_g_object_unref0 (self->priv->fxdLayout);
	self->priv->fxdLayout = _tmp2_;
	_tmp3_ = gtk_builder_get_object (builder, "imgProgessInfo");
	_tmp4_ = _g_object_ref0 (GTK_IMAGE (_tmp3_));
	_g_object_unref0 (self->priv->imgInfo);
	self->priv->imgInfo = _tmp4_;
	_tmp5_ = gtk_builder_get_object (builder, "lblInstallInfo");
	_tmp6_ = _g_object_ref0 (GTK_LABEL (_tmp5_));
	_g_object_unref0 (self->priv->lblInfo);
	self->priv->lblInfo = _tmp6_;
	_tmp7_ = gtk_builder_get_object (builder, "vbxProgress");
	_tmp8_ = _g_object_ref0 (GTK_VBOX (_tmp7_));
	_g_object_unref0 (self->priv->vbxProgress);
	self->priv->vbxProgress = _tmp8_;
	gtk_image_set_from_file (self->priv->imgInfo, self->priv->_imageFiles[0]);
	_tmp9_ = segmented_bar_new ();
	_g_object_unref0 (self->priv->segProgress);
	self->priv->segProgress = g_object_ref_sink (_tmp9_);
	segmented_bar_set_BarHeight (self->priv->segProgress, 20);
	_tmp10_ = segmented_bar_get_BarHeight (self->priv->segProgress);
	segmented_bar_set_HorizontalPadding (self->priv->segProgress, _tmp10_ / 2);
	segmented_bar_set_ShowReflection (self->priv->segProgress, FALSE);
	self->priv->segProgress->show_labels = FALSE;
	gtk_box_pack_start ((GtkBox*) self->priv->vbxProgress, (GtkWidget*) self->priv->segProgress, FALSE, FALSE, (guint) 0);
	gtk_widget_show_all ((GtkWidget*) self->priv->vbxProgress);
	g_signal_connect_object ((GtkWidget*) self->priv->fxdLayout, "realize", (GCallback) _exogenesis_finstall_OnFxdLayout_Realise_gtk_widget_realize, self, 0);
	g_object_get ((GtkWidget*) self->priv->fxdLayout, "width-request", &_tmp11_, NULL);
	g_object_set ((GtkWidget*) self, "width-request", _tmp11_, NULL);
	g_object_get ((GtkWidget*) self->priv->fxdLayout, "height-request", &_tmp12_, NULL);
	g_object_set ((GtkWidget*) self, "height-request", _tmp12_, NULL);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (builder);
	goto __finally6;
	__catch6_g_error:
	{
		GError * err;
		gchar* _tmp13_;
		gchar* _tmp14_;
		GtkMessageDialog* _tmp15_ = NULL;
		GtkMessageDialog* _tmp16_;
		GtkMessageDialog* msg;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp13_ = g_strconcat ("Failed to load UI\n", err->message, NULL);
		_tmp14_ = _tmp13_;
		_tmp15_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_CANCEL, _tmp14_);
		_tmp16_ = g_object_ref_sink (_tmp15_);
		_g_free0 (_tmp14_);
		msg = _tmp16_;
		gtk_dialog_run ((GtkDialog*) msg);
		gtk_main_quit ();
		_g_object_unref0 (msg);
		_g_error_free0 (err);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void exogenesis_finstall_GetImageFiles (ExogenesisFInstall* self) {
	GFileInfo* file_info = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GFile* _tmp2_ = NULL;
	GFile* _tmp3_;
	GFile* directory;
	GFileEnumerator* _tmp4_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup_printf ("%s/slides", exogenesis_AppPath);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_file_new_for_path (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	directory = _tmp3_;
	_tmp4_ = g_file_enumerate_children (directory, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	enumerator = _tmp4_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (directory);
		_g_object_unref0 (file_info);
		goto __catch7_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp5_ = NULL;
		GFileInfo* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		_tmp5_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp6_ = _tmp5_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			_g_object_unref0 (directory);
			_g_object_unref0 (file_info);
			goto __catch7_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp6_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp7_ = g_file_info_get_name (file_info);
		_tmp8_ = g_strdup_printf ("%s/slides/%s", exogenesis_AppPath, _tmp7_);
		_vala_array_add1 (&self->priv->_imageFiles, &self->priv->_imageFiles_length1, &self->priv->__imageFiles_size_, _tmp8_);
	}
	_g_object_unref0 (enumerator);
	_g_object_unref0 (directory);
	_g_object_unref0 (file_info);
	goto __finally7;
	__catch7_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error: %s\n", e->message);
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void exogenesis_finstall_UpdateProgressBar (ExogenesisFInstall* self, gint percentage) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = exogenesis_general_functions_BarColour (2);
	segmented_bar_AddSegmentRgb (self->priv->segProgress, "one", percentage, _tmp0_);
}


gboolean exogenesis_finstall_OnTimer (ExogenesisFInstall* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	exogenesis_finstall_DisplayImage (self);
	result = TRUE;
	return result;
}


void exogenesis_finstall_DisplayImage (ExogenesisFInstall* self) {
	g_return_if_fail (self != NULL);
	if (self->priv->_lastImgId < (self->priv->_imageFiles_length1 - 1)) {
		self->priv->_lastImgId = self->priv->_lastImgId + 1;
	} else {
		self->priv->_lastImgId = 0;
	}
	gtk_image_set_from_file (self->priv->imgInfo, self->priv->_imageFiles[self->priv->_lastImgId]);
	self->priv->_progress = self->priv->_progress + 20;
	exogenesis_finstall_UpdateProgressBar (self, self->priv->_progress);
	exogenesis_finstall_UpdateLabel (self, "Copying System Files...");
}


static void exogenesis_finstall_UpdateLabel (ExogenesisFInstall* self, const gchar* text) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	gtk_label_set_label (self->priv->lblInfo, text);
}


static gboolean _exogenesis_finstall_OnTimer_gsource_func (gpointer self) {
	gboolean result;
	result = exogenesis_finstall_OnTimer (self);
	return result;
}


void exogenesis_finstall_OnFxdLayout_Realise (ExogenesisFInstall* self) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, _exogenesis_finstall_OnTimer_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->_timerId = _tmp0_;
}


static void exogenesis_finstall_class_init (ExogenesisFInstallClass * klass) {
	exogenesis_finstall_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisFInstallPrivate));
	G_OBJECT_CLASS (klass)->finalize = exogenesis_finstall_finalize;
}


static void exogenesis_finstall_instance_init (ExogenesisFInstall * self) {
	gchar** _tmp0_ = NULL;
	self->priv = EXOGENESIS_FINSTALL_GET_PRIVATE (self);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	self->priv->_imageFiles = _tmp0_;
	self->priv->_imageFiles_length1 = 0;
	self->priv->__imageFiles_size_ = self->priv->_imageFiles_length1;
	self->priv->_lastImgId = 0;
	self->priv->_progress = 0;
}


static void exogenesis_finstall_finalize (GObject* obj) {
	ExogenesisFInstall * self;
	self = EXOGENESIS_FINSTALL (obj);
	_g_object_unref0 (self->priv->fxdLayout);
	_g_object_unref0 (self->priv->imgInfo);
	_g_object_unref0 (self->priv->lblInfo);
	_g_object_unref0 (self->priv->vbxProgress);
	_g_object_unref0 (self->priv->segProgress);
	self->priv->_imageFiles = (_vala_array_free (self->priv->_imageFiles, self->priv->_imageFiles_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (exogenesis_finstall_parent_class)->finalize (obj);
}


GType exogenesis_finstall_get_type (void) {
	static volatile gsize exogenesis_finstall_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_finstall_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisFInstallClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_finstall_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisFInstall), 0, (GInstanceInitFunc) exogenesis_finstall_instance_init, NULL };
		GType exogenesis_finstall_type_id;
		exogenesis_finstall_type_id = g_type_register_static (GTK_TYPE_LAYOUT, "ExogenesisFInstall", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_finstall_type_id__volatile, exogenesis_finstall_type_id);
	}
	return exogenesis_finstall_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



