/* exoTZControl.c generated by valac 0.12.1, the Vala compiler
 * generated from exoTZControl.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>
#include <stdio.h>
#include <cairo.h>
#include <time.h>
#include <oobs/oobs.h>
#include <gobject/gvaluecollector.h>


#define EXOGENESIS_TYPE_CAIRO_CORNERS (exogenesis_cairo_corners_get_type ())

#define EXOGENESIS_TYPE_TZ_WIDGET (exogenesis_tz_widget_get_type ())
#define EXOGENESIS_TZ_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_TZ_WIDGET, ExogenesisTZWidget))
#define EXOGENESIS_TZ_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_TZ_WIDGET, ExogenesisTZWidgetClass))
#define EXOGENESIS_IS_TZ_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_TZ_WIDGET))
#define EXOGENESIS_IS_TZ_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_TZ_WIDGET))
#define EXOGENESIS_TZ_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_TZ_WIDGET, ExogenesisTZWidgetClass))

typedef struct _ExogenesisTZWidget ExogenesisTZWidget;
typedef struct _ExogenesisTZWidgetClass ExogenesisTZWidgetClass;
typedef struct _ExogenesisTZWidgetPrivate ExogenesisTZWidgetPrivate;

#define EXOGENESIS_TYPE_COLOUR_MAP (exogenesis_colour_map_get_type ())
#define EXOGENESIS_COLOUR_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_COLOUR_MAP, ExogenesisColourMap))
#define EXOGENESIS_COLOUR_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_COLOUR_MAP, ExogenesisColourMapClass))
#define EXOGENESIS_IS_COLOUR_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_COLOUR_MAP))
#define EXOGENESIS_IS_COLOUR_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_COLOUR_MAP))
#define EXOGENESIS_COLOUR_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_COLOUR_MAP, ExogenesisColourMapClass))

typedef struct _ExogenesisColourMap ExogenesisColourMap;
typedef struct _ExogenesisColourMapClass ExogenesisColourMapClass;

#define EXOGENESIS_TYPE_TZ_DISTANCE (exogenesis_tz_distance_get_type ())
#define EXOGENESIS_TZ_DISTANCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_TZ_DISTANCE, ExogenesisTZDistance))
#define EXOGENESIS_TZ_DISTANCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_TZ_DISTANCE, ExogenesisTZDistanceClass))
#define EXOGENESIS_IS_TZ_DISTANCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_TZ_DISTANCE))
#define EXOGENESIS_IS_TZ_DISTANCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_TZ_DISTANCE))
#define EXOGENESIS_TZ_DISTANCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_TZ_DISTANCE, ExogenesisTZDistanceClass))

typedef struct _ExogenesisTZDistance ExogenesisTZDistance;
typedef struct _ExogenesisTZDistanceClass ExogenesisTZDistanceClass;

#define EXOGENESIS_TYPE_TZ_DB (exogenesis_tz_db_get_type ())
#define EXOGENESIS_TZ_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_TZ_DB, ExogenesisTZDb))
#define EXOGENESIS_TZ_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_TZ_DB, ExogenesisTZDbClass))
#define EXOGENESIS_IS_TZ_DB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_TZ_DB))
#define EXOGENESIS_IS_TZ_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_TZ_DB))
#define EXOGENESIS_TZ_DB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_TZ_DB, ExogenesisTZDbClass))

typedef struct _ExogenesisTZDb ExogenesisTZDb;
typedef struct _ExogenesisTZDbClass ExogenesisTZDbClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _exogenesis_tz_db_unref0(var) ((var == NULL) ? NULL : (var = (exogenesis_tz_db_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

#define EXOGENESIS_TYPE_COLOUR (exogenesis_colour_get_type ())
#define EXOGENESIS_COLOUR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_COLOUR, ExogenesisColour))
#define EXOGENESIS_COLOUR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_COLOUR, ExogenesisColourClass))
#define EXOGENESIS_IS_COLOUR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_COLOUR))
#define EXOGENESIS_IS_COLOUR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_COLOUR))
#define EXOGENESIS_COLOUR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_COLOUR, ExogenesisColourClass))

typedef struct _ExogenesisColour ExogenesisColour;
typedef struct _ExogenesisColourClass ExogenesisColourClass;
#define _exogenesis_colour_unref0(var) ((var == NULL) ? NULL : (var = (exogenesis_colour_unref (var), NULL)))

#define EXOGENESIS_TYPE_LOCATION (exogenesis_location_get_type ())
#define EXOGENESIS_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_LOCATION, ExogenesisLocation))
#define EXOGENESIS_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_LOCATION, ExogenesisLocationClass))
#define EXOGENESIS_IS_LOCATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_LOCATION))
#define EXOGENESIS_IS_LOCATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_LOCATION))
#define EXOGENESIS_LOCATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_LOCATION, ExogenesisLocationClass))

typedef struct _ExogenesisLocation ExogenesisLocation;
typedef struct _ExogenesisLocationClass ExogenesisLocationClass;
#define _exogenesis_location_unref0(var) ((var == NULL) ? NULL : (var = (exogenesis_location_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _ExogenesisTZDbPrivate ExogenesisTZDbPrivate;

#define EXOGENESIS_TYPE_GENERAL_FUNCTIONS (exogenesis_general_functions_get_type ())
#define EXOGENESIS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctions))
#define EXOGENESIS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_IS_GENERAL_FUNCTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EXOGENESIS_TYPE_GENERAL_FUNCTIONS))
#define EXOGENESIS_GENERAL_FUNCTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EXOGENESIS_TYPE_GENERAL_FUNCTIONS, ExogenesisGeneralFunctionsClass))

typedef struct _ExogenesisGeneralFunctions ExogenesisGeneralFunctions;
typedef struct _ExogenesisGeneralFunctionsClass ExogenesisGeneralFunctionsClass;
typedef struct _ExogenesisParamSpecTZDb ExogenesisParamSpecTZDb;
typedef struct _ExogenesisLocationPrivate ExogenesisLocationPrivate;
typedef struct _ExogenesisParamSpecLocation ExogenesisParamSpecLocation;
typedef struct _ExogenesisColourMapPrivate ExogenesisColourMapPrivate;
typedef struct _ExogenesisColourPrivate ExogenesisColourPrivate;
typedef struct _ExogenesisParamSpecColour ExogenesisParamSpecColour;
typedef struct _ExogenesisTZDistancePrivate ExogenesisTZDistancePrivate;

typedef enum  {
	EXOGENESIS_CAIRO_CORNERS_None = 0,
	EXOGENESIS_CAIRO_CORNERS_TopLeft = 1,
	EXOGENESIS_CAIRO_CORNERS_TopRight = 2,
	EXOGENESIS_CAIRO_CORNERS_BottomLeft = 4,
	EXOGENESIS_CAIRO_CORNERS_BottomRight = 8,
	EXOGENESIS_CAIRO_CORNERS_All = 15
} ExogenesisCairoCorners;

struct _ExogenesisTZWidget {
	GtkWidget parent_instance;
	ExogenesisTZWidgetPrivate * priv;
};

struct _ExogenesisTZWidgetClass {
	GtkWidgetClass parent_class;
	void (*SelectCity) (ExogenesisTZWidget* self, const gchar* Zone);
};

struct _ExogenesisTZWidgetPrivate {
	ExogenesisColourMap* _colourmap;
	GeeArrayList* _Distances;
	ExogenesisTZDb* _TZDb;
	gdouble _PrevClickX;
	gdouble _PrevClickY;
	gint _DistPos;
	gchar* _ImagePath;
	GdkPixbuf* _OrigBackground;
	GdkPixbuf* _OrigColourMap;
	GdkPixbuf* _Background;
	GdkPixbuf* _ColourMap;
	guchar* _VisibleMapPixels;
	gint _VisibleMapPixels_length1;
	gint __VisibleMapPixels_size_;
	gint _VisibleMapRowStride;
	guint _timerID;
	gchar* _SelectedOffset;
	gchar* _SelectedCity;
	guint* _TimeoutID;
	gint _BgScaleHeight;
	gint _BgScaleWidth;
	gchar* _BackGroundFile;
	gchar* _ColourMapFile;
};

struct _ExogenesisTZDb {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisTZDbPrivate * priv;
};

struct _ExogenesisTZDbClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisTZDb *self);
};

struct _ExogenesisTZDbPrivate {
	gchar* _TZDataFile;
	gchar* _ISO3166File;
	GeeArrayList* _Locations;
};

struct _ExogenesisParamSpecTZDb {
	GParamSpec parent_instance;
};

struct _ExogenesisLocation {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisLocationPrivate * priv;
};

struct _ExogenesisLocationClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisLocation *self);
};

struct _ExogenesisLocationPrivate {
	OobsTimeConfig* _tc;
	gdouble _Longitude;
	gdouble _Latitude;
	gchar* _CountryCode;
	gchar* _CountryName;
	gchar* _CityName;
	gchar* _Comment;
	gchar* _Zone;
	struct tm _LocalTime;
};

struct _ExogenesisParamSpecLocation {
	GParamSpec parent_instance;
};

struct _ExogenesisColourMap {
	GObject parent_instance;
	ExogenesisColourMapPrivate * priv;
};

struct _ExogenesisColourMapClass {
	GObjectClass parent_class;
};

struct _ExogenesisColourMapPrivate {
	GeeArrayList* _colours;
};

struct _ExogenesisColour {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ExogenesisColourPrivate * priv;
};

struct _ExogenesisColourClass {
	GTypeClass parent_class;
	void (*finalize) (ExogenesisColour *self);
};

struct _ExogenesisColourPrivate {
	gchar* _Offset;
	gint _DataA;
	gint _DataB;
	gint _DataC;
	gint _DataD;
};

struct _ExogenesisParamSpecColour {
	GParamSpec parent_instance;
};

struct _ExogenesisTZDistance {
	GObject parent_instance;
	ExogenesisTZDistancePrivate * priv;
};

struct _ExogenesisTZDistanceClass {
	GObjectClass parent_class;
};

struct _ExogenesisTZDistancePrivate {
	gdouble _Distance;
	ExogenesisLocation* _Loc;
	gboolean _SameContext;
};


static gpointer exogenesis_tz_widget_parent_class = NULL;
extern gchar* exogenesis_AppPath;
static gpointer exogenesis_tz_db_parent_class = NULL;
extern ExogenesisGeneralFunctions* exogenesis_gGenFunc;
static gpointer exogenesis_location_parent_class = NULL;
static gpointer exogenesis_colour_map_parent_class = NULL;
static GeeIterableIface* exogenesis_colour_map_gee_iterable_parent_iface = NULL;
static gpointer exogenesis_colour_parent_class = NULL;
static gpointer exogenesis_tz_distance_parent_class = NULL;
static GeeComparableIface* exogenesis_tz_distance_gee_comparable_parent_iface = NULL;

GType exogenesis_cairo_corners_get_type (void) G_GNUC_CONST;
GType exogenesis_tz_widget_get_type (void) G_GNUC_CONST;
GType exogenesis_colour_map_get_type (void) G_GNUC_CONST;
GType exogenesis_tz_distance_get_type (void) G_GNUC_CONST;
gpointer exogenesis_tz_db_ref (gpointer instance);
void exogenesis_tz_db_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_tz_db (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_tz_db (GValue* value, gpointer v_object);
void exogenesis_value_take_tz_db (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_tz_db (const GValue* value);
GType exogenesis_tz_db_get_type (void) G_GNUC_CONST;
#define EXOGENESIS_TZ_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_TZ_WIDGET, ExogenesisTZWidgetPrivate))
enum  {
	EXOGENESIS_TZ_WIDGET_DUMMY_PROPERTY,
	EXOGENESIS_TZ_WIDGET_BACK_GROUND_FILE,
	EXOGENESIS_TZ_WIDGET_COLOUR_MAP_FILE
};
ExogenesisColourMap* exogenesis_colour_map_new (void);
ExogenesisColourMap* exogenesis_colour_map_construct (GType object_type);
ExogenesisTZDb* exogenesis_tz_db_new (void);
ExogenesisTZDb* exogenesis_tz_db_construct (GType object_type);
ExogenesisTZWidget* exogenesis_tz_widget_new (void);
ExogenesisTZWidget* exogenesis_tz_widget_construct (GType object_type);
static gboolean exogenesis_tz_widget_OnButtonPress (ExogenesisTZWidget* self, GdkEventButton* evt);
static gboolean _exogenesis_tz_widget_OnButtonPress_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
gboolean exogenesis_tz_widget_OnTimer (ExogenesisTZWidget* self);
static gboolean _exogenesis_tz_widget_OnTimer_gsource_func (gpointer self);
void exogenesis_tz_widget_OnUnRealised (ExogenesisTZWidget* self);
static void _exogenesis_tz_widget_OnUnRealised_gtk_widget_unrealize (GtkWidget* _sender, gpointer self);
static void exogenesis_tz_widget_PopulateColourMap (ExogenesisTZWidget* self);
void exogenesis_colour_map_AddColourMap (ExogenesisColourMap* self, const gchar* offset, gint a, gint b, gint c, gint d);
static gdouble exogenesis_tz_widget_ConvertLatitudeToY (ExogenesisTZWidget* self, gdouble latitude, gdouble mapheight);
static gdouble exogenesis_tz_widget_ConvertLongitudeToX (ExogenesisTZWidget* self, gdouble longitude, gdouble mapwidth);
gpointer exogenesis_colour_ref (gpointer instance);
void exogenesis_colour_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_colour (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_colour (GValue* value, gpointer v_object);
void exogenesis_value_take_colour (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_colour (const GValue* value);
GType exogenesis_colour_get_type (void) G_GNUC_CONST;
static ExogenesisColour* exogenesis_tz_widget_ConvertXYToOffset (ExogenesisTZWidget* self, gdouble X, gdouble Y);
ExogenesisColour* exogenesis_colour_new (void);
ExogenesisColour* exogenesis_colour_construct (GType object_type);
void exogenesis_colour_set_DataA (ExogenesisColour* self, gint value);
void exogenesis_colour_set_DataB (ExogenesisColour* self, gint value);
void exogenesis_colour_set_DataC (ExogenesisColour* self, gint value);
void exogenesis_colour_set_DataD (ExogenesisColour* self, gint value);
static gboolean exogenesis_tz_widget_CompareColour (ExogenesisTZWidget* self, ExogenesisColour* a, ExogenesisColour* b);
gint exogenesis_colour_get_DataA (ExogenesisColour* self);
gint exogenesis_colour_get_DataB (ExogenesisColour* self);
gint exogenesis_colour_get_DataC (ExogenesisColour* self);
gint exogenesis_colour_get_DataD (ExogenesisColour* self);
static void exogenesis_tz_widget_real_get_preferred_width (GtkWidget* base, gint* minwidth, gint* natwidth);
static void exogenesis_tz_widget_real_get_preferred_height (GtkWidget* base, gint* minheight, gint* natheight);
static void exogenesis_tz_widget_real_size_allocate (GtkWidget* base, GdkRectangle* rec);
static void exogenesis_tz_widget_real_realize (GtkWidget* base);
static gboolean exogenesis_tz_widget_real_draw (GtkWidget* base, cairo_t* cr);
gpointer exogenesis_location_ref (gpointer instance);
void exogenesis_location_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_location (GValue* value, gpointer v_object);
void exogenesis_value_take_location (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_location (const GValue* value);
GType exogenesis_location_get_type (void) G_GNUC_CONST;
void exogenesis_general_functions_LogIt (const gchar* Message);
ExogenesisLocation* exogenesis_tz_db_GetLocationForCity (ExogenesisTZDb* self, const gchar* city);
gdouble exogenesis_location_get_Longitude (ExogenesisLocation* self);
gdouble exogenesis_location_get_Latitude (ExogenesisLocation* self);
const gchar* exogenesis_location_get_CityName (ExogenesisLocation* self);
void exogenesis_location_get_LocalTime (ExogenesisLocation* self, struct tm* result);
void exogenesis_tz_widget_RoundedRectangle (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, ExogenesisCairoCorners corners, gboolean topBottomFallsThrough);
gboolean exogenesis_tz_widget_TimeOut (ExogenesisTZWidget* self);
void exogenesis_tz_widget_Mapped (ExogenesisTZWidget* self, GtkWidget* widget, GdkEvent* evt);
static gboolean _exogenesis_tz_widget_TimeOut_gsource_func (gpointer self);
static guint* _uint_dup (guint* self);
void exogenesis_tz_widget_UnMapped (ExogenesisTZWidget* self, GtkWidget* widget, GdkEvent* evt);
const gchar* exogenesis_colour_get_Offset (ExogenesisColour* self);
ExogenesisLocation* exogenesis_tz_distance_get_Loc (ExogenesisTZDistance* self);
const gchar* exogenesis_location_get_Zone (ExogenesisLocation* self);
GeeArrayList* exogenesis_tz_db_get_Locations (ExogenesisTZDb* self);
gint exogenesis_location_RawUTCOffsetDays (ExogenesisLocation* self);
gint exogenesis_location_RawUTCOffsetSeconds (ExogenesisLocation* self);
gchar* exogenesis_tz_widget_TZFormatString (ExogenesisTZWidget* self, gdouble tzdiff);
ExogenesisTZDistance* exogenesis_tz_distance_new (gdouble Dist, ExogenesisLocation* loc, gboolean samecontext);
ExogenesisTZDistance* exogenesis_tz_distance_construct (GType object_type, gdouble Dist, ExogenesisLocation* loc, gboolean samecontext);
gboolean exogenesis_tz_distance_get_SameContext (ExogenesisTZDistance* self);
void exogenesis_tz_widget_SelectCity (ExogenesisTZWidget* self, const gchar* Zone);
static void exogenesis_tz_widget_real_SelectCity (ExogenesisTZWidget* self, const gchar* Zone);
ExogenesisLocation* exogenesis_tz_db_GetLocationFromZone (ExogenesisTZDb* self, const gchar* Zone);
const gchar* exogenesis_tz_widget_get_BackGroundFile (ExogenesisTZWidget* self);
void exogenesis_tz_widget_set_BackGroundFile (ExogenesisTZWidget* self, const gchar* value);
const gchar* exogenesis_tz_widget_get_ColourMapFile (ExogenesisTZWidget* self);
void exogenesis_tz_widget_set_ColourMapFile (ExogenesisTZWidget* self, const gchar* value);
static void g_cclosure_user_marshal_VOID__STRING_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void exogenesis_tz_widget_finalize (GObject* obj);
static void _vala_exogenesis_tz_widget_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_tz_widget_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define EXOGENESIS_TZ_DB_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_TZ_DB, ExogenesisTZDbPrivate))
enum  {
	EXOGENESIS_TZ_DB_DUMMY_PROPERTY
};
static void exogenesis_tz_db_ReadTZFile (ExogenesisTZDb* self);
gpointer exogenesis_general_functions_ref (gpointer instance);
void exogenesis_general_functions_unref (gpointer instance);
GParamSpec* exogenesis_param_spec_general_functions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void exogenesis_value_set_general_functions (GValue* value, gpointer v_object);
void exogenesis_value_take_general_functions (GValue* value, gpointer v_object);
gpointer exogenesis_value_get_general_functions (const GValue* value);
GType exogenesis_general_functions_get_type (void) G_GNUC_CONST;
gchar* exogenesis_general_functions_ReadTextFile (ExogenesisGeneralFunctions* self, const gchar* filename);
const gchar* exogenesis_tz_db_get_TZDataFile (ExogenesisTZDb* self);
ExogenesisLocation* exogenesis_location_new (void);
ExogenesisLocation* exogenesis_location_construct (GType object_type);
static gint exogenesis_tz_db_StringFind (ExogenesisTZDb* self, const gchar* st, const gchar* chr, gint start);
void exogenesis_location_set_CountryCode (ExogenesisLocation* self, const gchar* value);
void exogenesis_location_set_CountryName (ExogenesisLocation* self, const gchar* value);
void exogenesis_location_set_Zone (ExogenesisLocation* self, const gchar* value);
void exogenesis_location_set_CityName (ExogenesisLocation* self, const gchar* value);
void exogenesis_location_set_Comment (ExogenesisLocation* self, const gchar* value);
static gdouble exogenesis_tz_db_ParsePosition (ExogenesisTZDb* self, const gchar* position, gint wholedigits);
void exogenesis_location_set_Latitude (ExogenesisLocation* self, gdouble value);
void exogenesis_location_set_Longitude (ExogenesisLocation* self, gdouble value);
void exogenesis_tz_db_set_TZDataFile (ExogenesisTZDb* self, const gchar* value);
const gchar* exogenesis_tz_db_get_ISO3166File (ExogenesisTZDb* self);
void exogenesis_tz_db_set_ISO3166File (ExogenesisTZDb* self, const gchar* value);
static void exogenesis_tz_db_finalize (ExogenesisTZDb* obj);
#define EXOGENESIS_LOCATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_LOCATION, ExogenesisLocationPrivate))
enum  {
	EXOGENESIS_LOCATION_DUMMY_PROPERTY
};
gdouble exogenesis_location_UtcOffset (ExogenesisLocation* self);
void exogenesis_location_set_LocalTime (ExogenesisLocation* self, struct tm* value);
gint exogenesis_location_RawUTCOffsetMinutes (ExogenesisLocation* self);
void exogenesis_location_Location (ExogenesisLocation* self);
const gchar* exogenesis_location_get_CountryCode (ExogenesisLocation* self);
const gchar* exogenesis_location_get_CountryName (ExogenesisLocation* self);
const gchar* exogenesis_location_get_Comment (ExogenesisLocation* self);
static void exogenesis_location_finalize (ExogenesisLocation* obj);
#define EXOGENESIS_COLOUR_MAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_COLOUR_MAP, ExogenesisColourMapPrivate))
enum  {
	EXOGENESIS_COLOUR_MAP_DUMMY_PROPERTY,
	EXOGENESIS_COLOUR_MAP_ELEMENT_TYPE
};
ExogenesisColourMap* exogenesis_colour_map_new_WithDetail (const gchar* offset, gint a, gint b, gint c, gint d);
ExogenesisColourMap* exogenesis_colour_map_construct_WithDetail (GType object_type, const gchar* offset, gint a, gint b, gint c, gint d);
void exogenesis_colour_set_Offset (ExogenesisColour* self, const gchar* value);
ExogenesisColour* exogenesis_colour_map_GetOffsetColour (ExogenesisColourMap* self, const gchar* offset);
static GeeIterator* exogenesis_colour_map_real_iterator (GeeIterable* base);
static void exogenesis_colour_map_finalize (GObject* obj);
static void _vala_exogenesis_colour_map_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define EXOGENESIS_COLOUR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_COLOUR, ExogenesisColourPrivate))
enum  {
	EXOGENESIS_COLOUR_DUMMY_PROPERTY
};
ExogenesisColour* exogenesis_colour_new_WithValues (const gchar* offset, gint a, gint b, gint c, gint d);
ExogenesisColour* exogenesis_colour_construct_WithValues (GType object_type, const gchar* offset, gint a, gint b, gint c, gint d);
static void exogenesis_colour_finalize (ExogenesisColour* obj);
#define EXOGENESIS_TZ_DISTANCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EXOGENESIS_TYPE_TZ_DISTANCE, ExogenesisTZDistancePrivate))
enum  {
	EXOGENESIS_TZ_DISTANCE_DUMMY_PROPERTY,
	EXOGENESIS_TZ_DISTANCE_DISTANCE,
	EXOGENESIS_TZ_DISTANCE_LOC,
	EXOGENESIS_TZ_DISTANCE_SAME_CONTEXT
};
void exogenesis_tz_distance_set_Distance (ExogenesisTZDistance* self, gdouble value);
void exogenesis_tz_distance_set_Loc (ExogenesisTZDistance* self, ExogenesisLocation* value);
void exogenesis_tz_distance_set_SameContext (ExogenesisTZDistance* self, gboolean value);
static gint exogenesis_tz_distance_real_compare_to (GeeComparable* base, ExogenesisTZDistance* comp);
gdouble exogenesis_tz_distance_get_Distance (ExogenesisTZDistance* self);
static void exogenesis_tz_distance_finalize (GObject* obj);
static void _vala_exogenesis_tz_distance_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_exogenesis_tz_distance_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType exogenesis_cairo_corners_get_type (void) {
	static volatile gsize exogenesis_cairo_corners_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_cairo_corners_type_id__volatile)) {
		static const GEnumValue values[] = {{EXOGENESIS_CAIRO_CORNERS_None, "EXOGENESIS_CAIRO_CORNERS_None", "none"}, {EXOGENESIS_CAIRO_CORNERS_TopLeft, "EXOGENESIS_CAIRO_CORNERS_TopLeft", "topleft"}, {EXOGENESIS_CAIRO_CORNERS_TopRight, "EXOGENESIS_CAIRO_CORNERS_TopRight", "topright"}, {EXOGENESIS_CAIRO_CORNERS_BottomLeft, "EXOGENESIS_CAIRO_CORNERS_BottomLeft", "bottomleft"}, {EXOGENESIS_CAIRO_CORNERS_BottomRight, "EXOGENESIS_CAIRO_CORNERS_BottomRight", "bottomright"}, {EXOGENESIS_CAIRO_CORNERS_All, "EXOGENESIS_CAIRO_CORNERS_All", "all"}, {0, NULL, NULL}};
		GType exogenesis_cairo_corners_type_id;
		exogenesis_cairo_corners_type_id = g_enum_register_static ("ExogenesisCairoCorners", values);
		g_once_init_leave (&exogenesis_cairo_corners_type_id__volatile, exogenesis_cairo_corners_type_id);
	}
	return exogenesis_cairo_corners_type_id__volatile;
}


static gboolean _exogenesis_tz_widget_OnButtonPress_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = exogenesis_tz_widget_OnButtonPress (self, event);
	return result;
}


static gboolean _exogenesis_tz_widget_OnTimer_gsource_func (gpointer self) {
	gboolean result;
	result = exogenesis_tz_widget_OnTimer (self);
	return result;
}


static void _exogenesis_tz_widget_OnUnRealised_gtk_widget_unrealize (GtkWidget* _sender, gpointer self) {
	exogenesis_tz_widget_OnUnRealised (self);
}


ExogenesisTZWidget* exogenesis_tz_widget_construct (GType object_type) {
	ExogenesisTZWidget * self = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GdkPixbuf* _tmp2_ = NULL;
	GdkPixbuf* _tmp3_;
	GdkPixbuf* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	GdkPixbuf* _tmp7_ = NULL;
	GdkPixbuf* _tmp8_;
	GdkPixbuf* _tmp9_;
	guint _tmp10_;
	GError * _inner_error_ = NULL;
	self = (ExogenesisTZWidget*) gtk_widget_new (object_type, NULL);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) _exogenesis_tz_widget_OnButtonPress_gtk_widget_button_press_event, self, 0);
	_tmp0_ = g_strdup_printf ("%s/timezone/bg.png", exogenesis_AppPath);
	_tmp1_ = _tmp0_;
	_tmp2_ = gdk_pixbuf_new_from_file (_tmp1_, &_inner_error_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	_tmp4_ = _tmp3_;
	if (_inner_error_ != NULL) {
		goto __catch20_g_error;
	}
	_g_object_unref0 (self->priv->_OrigBackground);
	self->priv->_OrigBackground = _tmp4_;
	_tmp5_ = g_strdup_printf ("%s/timezone/cc.png", exogenesis_AppPath);
	_tmp6_ = _tmp5_;
	_tmp7_ = gdk_pixbuf_new_from_file (_tmp6_, &_inner_error_);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	_tmp9_ = _tmp8_;
	if (_inner_error_ != NULL) {
		goto __catch20_g_error;
	}
	_g_object_unref0 (self->priv->_OrigColourMap);
	self->priv->_OrigColourMap = _tmp9_;
	_tmp10_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, _exogenesis_tz_widget_OnTimer_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->_timerID = _tmp10_;
	g_signal_connect_object ((GtkWidget*) self, "unrealize", (GCallback) _exogenesis_tz_widget_OnUnRealised_gtk_widget_unrealize, self, 0);
	exogenesis_tz_widget_PopulateColourMap (self);
	goto __finally20;
	__catch20_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "%s\n", err->message);
		_g_error_free0 (err);
	}
	__finally20:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


ExogenesisTZWidget* exogenesis_tz_widget_new (void) {
	return exogenesis_tz_widget_construct (EXOGENESIS_TYPE_TZ_WIDGET);
}


void exogenesis_tz_widget_OnUnRealised (ExogenesisTZWidget* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_set_parent_window ((GtkWidget*) self, NULL);
}


gboolean exogenesis_tz_widget_OnTimer (ExogenesisTZWidget* self) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_ = NULL;
	cairo_t* _tmp1_ = NULL;
	cairo_t* cr;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	_tmp1_ = gdk_cairo_create (_tmp0_);
	cr = _tmp1_;
	gtk_widget_draw ((GtkWidget*) self, cr);
	result = TRUE;
	_cairo_destroy0 (cr);
	return result;
}


static void exogenesis_tz_widget_PopulateColourMap (ExogenesisTZWidget* self) {
	g_return_if_fail (self != NULL);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-11.0", 43, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-10.0", 85, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-9.5", 102, 255, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-9.0", 128, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-8.0", 170, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-7.0", 212, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-6.0|north", 255, 0, 1, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-6.0|south", 255, 0, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-5.0", 255, 42, 42, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-4.5", 192, 255, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-4.0", 255, 85, 85, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-3.5", 0, 255, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-3.0", 255, 128, 128, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-2.0", 255, 170, 170, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "-1.0", 255, 213, 213, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "0.0", 43, 17, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "1.0", 85, 34, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "2.0", 128, 51, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "3.0", 170, 68, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "3.5", 0, 255, 102, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "4.0", 212, 85, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "4.5", 0, 204, 255, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "5.0", 255, 102, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "5.5", 0, 102, 255, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "5.75", 0, 238, 207, 247);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "6.0", 255, 127, 42, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "6.5", 204, 0, 254, 254);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "7.0", 255, 153, 85, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "8.0", 255, 179, 128, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "9.0", 255, 204, 170, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "9.5", 170, 0, 68, 250);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "10.0", 255, 230, 213, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "10.5", 212, 124, 21, 250);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "11.0", 212, 170, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "11.5", 249, 25, 87, 253);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "12.0", 255, 204, 0, 255);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "12.75", 254, 74, 100, 248);
	exogenesis_colour_map_AddColourMap (self->priv->_colourmap, "13.0", 255, 85, 153, 250);
}


static gdouble exogenesis_tz_widget_ConvertLatitudeToY (ExogenesisTZWidget* self, gdouble latitude, gdouble mapheight) {
	gdouble result = 0.0;
	gdouble bottomlat;
	gdouble toplat;
	gdouble topper;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble y;
	gdouble fullrange;
	gdouble topoffset;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble maprange;
	gdouble _tmp5_;
	g_return_val_if_fail (self != NULL, 0.0);
	bottomlat = (gdouble) (-59);
	toplat = (gdouble) 81;
	topper = toplat / 180.0;
	_tmp0_ = tan ((G_PI / 4.0) + (0.4 * ((latitude * G_PI) / 180)));
	_tmp1_ = log (_tmp0_);
	y = 1.25 * _tmp1_;
	fullrange = 4.6068250867599998;
	topoffset = fullrange * topper;
	_tmp2_ = tan ((G_PI / 4.0) + (0.4 * ((bottomlat * G_PI) / 180)));
	_tmp3_ = log (_tmp2_);
	_tmp4_ = fabs ((1.25 * _tmp3_) - topoffset);
	maprange = _tmp4_;
	_tmp5_ = fabs (y - topoffset);
	y = _tmp5_;
	y = y / maprange;
	y = y * mapheight;
	result = y;
	return result;
}


static gdouble exogenesis_tz_widget_ConvertLongitudeToX (ExogenesisTZWidget* self, gdouble longitude, gdouble mapwidth) {
	gdouble result = 0.0;
	gdouble xdegoffset;
	gdouble x;
	g_return_val_if_fail (self != NULL, 0.0);
	xdegoffset = (gdouble) (-6);
	x = ((mapwidth * (180.0 + longitude)) / 360.0) + ((mapwidth * xdegoffset) / 180.0);
	x = fmod (x, mapwidth);
	result = x;
	return result;
}


static ExogenesisColour* exogenesis_tz_widget_ConvertXYToOffset (ExogenesisTZWidget* self, gdouble X, gdouble Y) {
	ExogenesisColour* result = NULL;
	gint x = 0;
	gint y = 0;
	gint rs;
	guchar* px;
	gint px_length1;
	gint _px_size_;
	ExogenesisColour* _tmp0_ = NULL;
	ExogenesisColour* colour;
	g_return_val_if_fail (self != NULL, NULL);
	rs = self->priv->_VisibleMapRowStride;
	px = self->priv->_VisibleMapPixels;
	px_length1 = self->priv->_VisibleMapPixels_length1;
	_px_size_ = self->priv->_VisibleMapPixels_length1;
	_tmp0_ = exogenesis_colour_new ();
	colour = _tmp0_;
	x = (gint) X;
	y = (gint) Y;
	exogenesis_colour_set_DataA (colour, (gint) px[(rs * y) + (x * 4)]);
	exogenesis_colour_set_DataB (colour, (gint) px[((rs * y) + (x * 4)) + 1]);
	exogenesis_colour_set_DataC (colour, (gint) px[((rs * y) + (x * 4)) + 2]);
	exogenesis_colour_set_DataD (colour, (gint) px[((rs * y) + (x * 4)) + 3]);
	{
		GeeIterator* _tmp1_ = NULL;
		GeeIterator* _C_it;
		_tmp1_ = gee_iterable_iterator ((GeeIterable*) self->priv->_colourmap);
		_C_it = _tmp1_;
		while (TRUE) {
			gboolean _tmp2_;
			gpointer _tmp3_ = NULL;
			ExogenesisColour* C;
			gboolean _tmp4_;
			_tmp2_ = gee_iterator_next (_C_it);
			if (!_tmp2_) {
				break;
			}
			_tmp3_ = gee_iterator_get (_C_it);
			C = (ExogenesisColour*) _tmp3_;
			_tmp4_ = exogenesis_tz_widget_CompareColour (self, C, colour);
			if (_tmp4_) {
				result = C;
				_g_object_unref0 (_C_it);
				_exogenesis_colour_unref0 (colour);
				return result;
			}
			_exogenesis_colour_unref0 (C);
		}
		_g_object_unref0 (_C_it);
	}
	result = NULL;
	_exogenesis_colour_unref0 (colour);
	return result;
}


static gboolean exogenesis_tz_widget_CompareColour (ExogenesisTZWidget* self, ExogenesisColour* a, ExogenesisColour* b) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gint _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp3_ = exogenesis_colour_get_DataA (a);
	_tmp4_ = exogenesis_colour_get_DataA (b);
	if (_tmp3_ == _tmp4_) {
		gint _tmp5_;
		gint _tmp6_;
		_tmp5_ = exogenesis_colour_get_DataB (a);
		_tmp6_ = exogenesis_colour_get_DataB (b);
		_tmp2_ = _tmp5_ == _tmp6_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = exogenesis_colour_get_DataC (a);
		_tmp8_ = exogenesis_colour_get_DataC (b);
		_tmp1_ = _tmp7_ == _tmp8_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gint _tmp9_;
		gint _tmp10_;
		_tmp9_ = exogenesis_colour_get_DataD (a);
		_tmp10_ = exogenesis_colour_get_DataD (b);
		_tmp0_ = _tmp9_ == _tmp10_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static void exogenesis_tz_widget_real_get_preferred_width (GtkWidget* base, gint* minwidth, gint* natwidth) {
	ExogenesisTZWidget * self;
	gint _minwidth = 0;
	gint _natwidth = 0;
	self = (ExogenesisTZWidget*) base;
	_natwidth = 0;
	_minwidth = _natwidth;
	if (minwidth) {
		*minwidth = _minwidth;
	}
	if (natwidth) {
		*natwidth = _natwidth;
	}
}


static void exogenesis_tz_widget_real_get_preferred_height (GtkWidget* base, gint* minheight, gint* natheight) {
	ExogenesisTZWidget * self;
	gint _minheight = 0;
	gint _natheight = 0;
	self = (ExogenesisTZWidget*) base;
	_natheight = 0;
	_minheight = _natheight;
	if (minheight) {
		*minheight = _minheight;
	}
	if (natheight) {
		*natheight = _natheight;
	}
}


static void exogenesis_tz_widget_real_size_allocate (GtkWidget* base, GdkRectangle* rec) {
	ExogenesisTZWidget * self;
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_ = NULL;
	guint8* _tmp2_ = NULL;
	gint _tmp3_;
	self = (ExogenesisTZWidget*) base;
	fprintf (stdout, "Size changed\n");
	_tmp0_ = gdk_pixbuf_scale_simple (self->priv->_OrigBackground, (*rec).width, (*rec).height, GDK_INTERP_BILINEAR);
	_g_object_unref0 (self->priv->_Background);
	self->priv->_Background = _tmp0_;
	_tmp1_ = gdk_pixbuf_scale_simple (self->priv->_OrigColourMap, (*rec).width, (*rec).height, GDK_INTERP_BILINEAR);
	_g_object_unref0 (self->priv->_ColourMap);
	self->priv->_ColourMap = _tmp1_;
	_tmp2_ = gdk_pixbuf_get_pixels (self->priv->_ColourMap);
	self->priv->_VisibleMapPixels = (guint8*) _tmp2_;
	self->priv->_VisibleMapPixels_length1 = -1;
	self->priv->__VisibleMapPixels_size_ = -1;
	_tmp3_ = gdk_pixbuf_get_rowstride (self->priv->_ColourMap);
	self->priv->_VisibleMapRowStride = _tmp3_;
	GTK_WIDGET_CLASS (exogenesis_tz_widget_parent_class)->size_allocate (GTK_WIDGET (self), rec);
}


static void exogenesis_tz_widget_real_realize (GtkWidget* base) {
	ExogenesisTZWidget * self;
	GtkAllocation alloc = {0};
	GtkContainer* _tmp0_ = NULL;
	GtkAllocation _tmp1_ = {0};
	GdkWindowAttr wa = {0};
	gint _tmp2_;
	GdkWindow* _tmp3_ = NULL;
	GdkWindow* _tmp4_ = NULL;
	GdkWindow* _tmp5_;
	GdkWindow* _tmp6_ = NULL;
	GtkStyle* _tmp7_ = NULL;
	GdkWindow* _tmp8_ = NULL;
	GtkStyle* _tmp9_ = NULL;
	GdkWindow* _tmp10_ = NULL;
	GdkWindow* _tmp11_ = NULL;
	GdkWindow* _tmp12_ = NULL;
	GdkCursor* _tmp13_ = NULL;
	GdkCursor* _tmp14_;
	GdkWindow* _tmp15_ = NULL;
	GtkContainer* _tmp16_ = NULL;
	GtkAllocation _tmp17_ = {0};
	GdkWindow* _tmp18_ = NULL;
	self = (ExogenesisTZWidget*) base;
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	alloc = _tmp1_;
	memset (&wa, 0, sizeof (GdkWindowAttr));
	wa.window_type = GDK_WINDOW_CHILD;
	wa.wclass = GDK_INPUT_OUTPUT;
	_tmp2_ = gtk_widget_get_events ((GtkWidget*) self);
	wa.event_mask = (_tmp2_ | GDK_EXPOSURE_MASK) | GDK_BUTTON_PRESS_MASK;
	wa.height = alloc.height;
	wa.width = alloc.width;
	_tmp3_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	_tmp4_ = gdk_window_new (_tmp3_, &wa, 0);
	_tmp5_ = _tmp4_;
	gtk_widget_set_parent_window ((GtkWidget*) self, _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gdk_window_set_user_data (_tmp6_, self);
	_tmp7_ = gtk_widget_get_style ((GtkWidget*) self);
	_tmp8_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gtk_style_attach (_tmp7_, _tmp8_);
	_tmp9_ = gtk_widget_get_style ((GtkWidget*) self);
	_tmp10_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gtk_style_set_background (_tmp9_, _tmp10_, GTK_STATE_NORMAL);
	_tmp11_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gdk_window_show (_tmp11_);
	_tmp12_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	_tmp13_ = gdk_cursor_new (GDK_HAND2);
	_tmp14_ = _tmp13_;
	gdk_window_set_cursor (_tmp12_, _tmp14_);
	_g_object_unref0 (_tmp14_);
	_tmp15_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gdk_window_set_user_data (_tmp15_, self);
	_tmp16_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_get_allocation ((GtkWidget*) _tmp16_, &_tmp17_);
	alloc = _tmp17_;
	_tmp18_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	gdk_window_move_resize (_tmp18_, alloc.x, alloc.y, alloc.width, alloc.height);
	gtk_widget_set_realized ((GtkWidget*) self, TRUE);
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GRegex* _tmp2_ = NULL;
	GRegex* _tmp3_;
	GRegex* regex;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp0_ = g_regex_escape_string (old, -1);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_regex_new (_tmp1_, 0, 0, &_inner_error_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	regex = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch22_g_regex_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (regex);
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch22_g_regex_error;
		}
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _tmp5_;
	_g_regex_unref0 (regex);
	return result;
	_g_regex_unref0 (regex);
	goto __finally22;
	__catch22_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally22:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* g_time_format (struct tm *self, const gchar* format) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* buffer;
	gint buffer_length1;
	gint _buffer_size_;
	gchar* _tmp1_;
	g_return_val_if_fail (format != NULL, NULL);
	_tmp0_ = g_new0 (gchar, 64);
	buffer = _tmp0_;
	buffer_length1 = 64;
	_buffer_size_ = 64;
	strftime (buffer, buffer_length1, format, &(*self));
	_tmp1_ = g_strdup ((const gchar*) buffer);
	result = _tmp1_;
	buffer = (g_free (buffer), NULL);
	return result;
}


static gboolean exogenesis_tz_widget_real_draw (GtkWidget* base, cairo_t* cr) {
	ExogenesisTZWidget * self;
	gboolean result = FALSE;
	GdkPixbuf* pixbuf = NULL;
	gint height = 0;
	gint width = 0;
	gboolean onlydrawselected;
	gdouble pointx = 0.0;
	gdouble pointy = 0.0;
	gdouble newx = 0.0;
	gdouble newy = 0.0;
	struct tm now = {0};
	gchar* sTime = NULL;
	cairo_text_extents_t te = {0};
	GdkColor colour = {0};
	ExogenesisLocation* location = NULL;
	GtkAllocation alloc = {0};
	GtkContainer* _tmp0_ = NULL;
	GtkAllocation _tmp1_ = {0};
	gboolean _tmp13_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (ExogenesisTZWidget*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	onlydrawselected = FALSE;
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	alloc = _tmp1_;
	gdk_cairo_set_source_pixbuf (cr, self->priv->_Background, (gdouble) 0, (gdouble) 0);
	cairo_paint (cr);
	if (self->priv->_SelectedOffset != NULL) {
		gchar** _tmp2_;
		gchar** _tmp3_ = NULL;
		gchar** _tmp4_;
		gint _tmp4__length1;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		GdkPixbuf* _tmp7_ = NULL;
		GdkPixbuf* _tmp8_;
		GdkPixbuf* _tmp9_;
		GdkPixbuf* _tmp10_ = NULL;
		_tmp3_ = _tmp2_ = g_strsplit (self->priv->_SelectedOffset, "|", 0);
		_tmp4_ = _tmp3_;
		_tmp4__length1 = _vala_array_length (_tmp2_);
		_tmp5_ = g_strdup_printf ("%s/timezone/timezone_%s.png", exogenesis_AppPath, _tmp4_[0]);
		_tmp6_ = _tmp5_;
		_tmp7_ = gdk_pixbuf_new_from_file (_tmp6_, &_inner_error_);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
		_tmp9_ = _tmp8_;
		if (_inner_error_ != NULL) {
			goto __catch21_g_error;
		}
		_g_object_unref0 (pixbuf);
		pixbuf = _tmp9_;
		_tmp10_ = gdk_pixbuf_scale_simple (pixbuf, alloc.width, alloc.height, GDK_INTERP_BILINEAR);
		_g_object_unref0 (pixbuf);
		pixbuf = _tmp10_;
		gdk_cairo_set_source_pixbuf (cr, pixbuf, (gdouble) 0, (gdouble) 0);
		cairo_paint (cr);
		goto __finally21;
		__catch21_g_error:
		{
			GError * e;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp11_ = g_strdup_printf ("error setting time zone band highlight:%s", e->message);
			_tmp12_ = _tmp11_;
			exogenesis_general_functions_LogIt (_tmp12_);
			_g_free0 (_tmp12_);
			result = FALSE;
			_g_error_free0 (e);
			_exogenesis_location_unref0 (location);
			_g_free0 (sTime);
			_g_object_unref0 (pixbuf);
			return result;
		}
		__finally21:
		if (_inner_error_ != NULL) {
			_exogenesis_location_unref0 (location);
			_g_free0 (sTime);
			_g_object_unref0 (pixbuf);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	height = alloc.height;
	width = alloc.width;
	onlydrawselected = TRUE;
	if (self->priv->_SelectedCity != NULL) {
		_tmp13_ = g_strcmp0 (self->priv->_SelectedCity, "") != 0;
	} else {
		_tmp13_ = FALSE;
	}
	if (_tmp13_) {
		ExogenesisLocation* _tmp14_ = NULL;
		_tmp14_ = exogenesis_tz_db_GetLocationForCity (self->priv->_TZDb, self->priv->_SelectedCity);
		_exogenesis_location_unref0 (location);
		location = _tmp14_;
		if (location != NULL) {
			gdouble _tmp15_;
			gdouble _tmp16_;
			gdouble _tmp17_;
			gdouble _tmp18_;
			GdkColor _tmp19_ = {0};
			GdkColor _tmp20_ = {0};
			const gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			struct tm _tmp23_ = {0};
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_;
			gchar* _tmp26_ = NULL;
			gchar* _tmp27_;
			gchar* _tmp28_;
			cairo_text_extents_t _tmp29_ = {0};
			GdkColor _tmp30_ = {0};
			GdkColor _tmp31_ = {0};
			_tmp15_ = exogenesis_location_get_Longitude (location);
			_tmp16_ = exogenesis_tz_widget_ConvertLongitudeToX (self, _tmp15_, (gdouble) width);
			pointx = _tmp16_;
			_tmp17_ = exogenesis_location_get_Latitude (location);
			_tmp18_ = exogenesis_tz_widget_ConvertLatitudeToY (self, _tmp17_, (gdouble) height);
			pointy = _tmp18_;
			gdk_color_parse ("black", &_tmp19_);
			colour = _tmp19_;
			cairo_set_source_rgb (cr, (gdouble) ((guint) colour.red), (gdouble) ((guint) colour.green), (gdouble) ((guint) colour.blue));
			cairo_arc (cr, pointx, pointy, 2.5, (gdouble) 0, 2 * G_PI);
			cairo_fill_preserve (cr);
			cairo_set_line_width (cr, 1.5);
			cairo_stroke (cr);
			gdk_color_parse ("white", &_tmp20_);
			colour = _tmp20_;
			cairo_set_source_rgb (cr, (gdouble) ((guint) colour.red), (gdouble) ((guint) colour.green), (gdouble) ((guint) colour.blue));
			cairo_stroke (cr);
			_tmp21_ = exogenesis_location_get_CityName (location);
			_tmp22_ = string_replace (_tmp21_, "_", " ");
			_g_free0 (sTime);
			sTime = _tmp22_;
			exogenesis_location_get_LocalTime (location, &_tmp23_);
			_tmp24_ = g_time_format (&_tmp23_, "%X");
			_tmp25_ = _tmp24_;
			_tmp26_ = g_strdup_printf (" - %s", _tmp25_);
			_tmp27_ = _tmp26_;
			_tmp28_ = g_strconcat (sTime, _tmp27_, NULL);
			_g_free0 (sTime);
			sTime = _tmp28_;
			_g_free0 (_tmp27_);
			_g_free0 (_tmp25_);
			cairo_select_font_face (cr, "sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
			cairo_set_font_size (cr, (gdouble) 12);
			cairo_text_extents (cr, sTime, &_tmp29_);
			te = _tmp29_;
			newy = pointy - (te.y_bearing / 2);
			if (((pointx + te.width) + 10) > alloc.width) {
				newx = ((pointx - 12) - te.width) - 4;
			} else {
				newx = pointx + 12;
			}
			cairo_move_to (cr, newx, newy);
			gdk_color_parse ("black", &_tmp30_);
			colour = _tmp30_;
			cairo_set_source_rgb (cr, (gdouble) ((guint) colour.red), (gdouble) ((guint) colour.green), (gdouble) ((guint) colour.blue));
			exogenesis_tz_widget_RoundedRectangle (cr, newx - 5, (newy + te.y_bearing) - 6, te.width + 10, te.height + 12, te.height / 6, EXOGENESIS_CAIRO_CORNERS_All, FALSE);
			cairo_fill_preserve (cr);
			cairo_stroke (cr);
			gdk_color_parse ("white", &_tmp31_);
			colour = _tmp31_;
			cairo_set_source_rgb (cr, (gdouble) ((guint) colour.red), (gdouble) ((guint) colour.green), (gdouble) ((guint) colour.blue));
			cairo_move_to (cr, newx, newy);
			cairo_show_text (cr, sTime);
			cairo_stroke (cr);
		}
	}
	result = TRUE;
	_exogenesis_location_unref0 (location);
	_g_free0 (sTime);
	_g_object_unref0 (pixbuf);
	return result;
}


gboolean exogenesis_tz_widget_TimeOut (ExogenesisTZWidget* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_widget_queue_draw ((GtkWidget*) self);
	result = TRUE;
	return result;
}


static gboolean _exogenesis_tz_widget_TimeOut_gsource_func (gpointer self) {
	gboolean result;
	result = exogenesis_tz_widget_TimeOut (self);
	return result;
}


static guint* _uint_dup (guint* self) {
	guint* dup;
	dup = g_new0 (guint, 1);
	memcpy (dup, self, sizeof (guint));
	return dup;
}


static gpointer __uint_dup0 (gpointer self) {
	return self ? _uint_dup (self) : NULL;
}


void exogenesis_tz_widget_Mapped (ExogenesisTZWidget* self, GtkWidget* widget, GdkEvent* evt) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (evt != NULL);
	if (self->priv->_TimeoutID != NULL) {
		guint _tmp0_;
		guint* _tmp1_;
		_tmp0_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, _exogenesis_tz_widget_TimeOut_gsource_func, g_object_ref (self), g_object_unref);
		_tmp1_ = __uint_dup0 (&_tmp0_);
		_g_free0 (self->priv->_TimeoutID);
		self->priv->_TimeoutID = _tmp1_;
	}
}


void exogenesis_tz_widget_UnMapped (ExogenesisTZWidget* self, GtkWidget* widget, GdkEvent* evt) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (evt != NULL);
	if (self->priv->_TimeoutID != NULL) {
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean exogenesis_tz_widget_OnButtonPress (ExogenesisTZWidget* self, GdkEventButton* evt) {
	gboolean result = FALSE;
	gdouble x = 0.0;
	gdouble y = 0.0;
	ExogenesisColour* o = NULL;
	gdouble DistPos = 0.0;
	gdouble PointX = 0.0;
	gdouble PointY = 0.0;
	gchar* Zone = NULL;
	ExogenesisColour* _tmp0_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	x = (*evt).x;
	y = (*evt).y;
	_tmp0_ = exogenesis_tz_widget_ConvertXYToOffset (self, x, y);
	_exogenesis_colour_unref0 (o);
	o = _tmp0_;
	if (o == NULL) {
		result = FALSE;
		_g_free0 (Zone);
		_exogenesis_colour_unref0 (o);
		return result;
	} else {
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		_tmp1_ = exogenesis_colour_get_Offset (o);
		_tmp2_ = g_strdup (_tmp1_);
		_g_free0 (self->priv->_SelectedOffset);
		self->priv->_SelectedOffset = _tmp2_;
	}
	if (x == self->priv->_PrevClickX) {
		_tmp4_ = y == self->priv->_PrevClickY;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gint _tmp5_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) self->priv->_Distances);
		_tmp3_ = _tmp5_ > 0;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gint _tmp6_;
		gpointer _tmp7_ = NULL;
		ExogenesisTZDistance* _tmp8_;
		ExogenesisLocation* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		_tmp6_ = gee_collection_get_size ((GeeCollection*) self->priv->_Distances);
		self->priv->_DistPos = (self->priv->_DistPos + 1) % _tmp6_;
		_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_Distances, self->priv->_DistPos);
		_tmp8_ = (ExogenesisTZDistance*) _tmp7_;
		_tmp9_ = exogenesis_tz_distance_get_Loc (_tmp8_);
		_tmp10_ = exogenesis_location_get_Zone (_tmp9_);
		_tmp11_ = g_strdup (_tmp10_);
		_g_free0 (Zone);
		Zone = _tmp11_;
		_g_object_unref0 (_tmp8_);
	} else {
		gboolean SameContext = FALSE;
		gdouble dx = 0.0;
		gdouble dy = 0.0;
		gdouble dist = 0.0;
		gint _tmp12_;
		gdouble height;
		gint _tmp13_;
		gdouble width;
		ExogenesisColour* PointTo = NULL;
		const gchar* _tmp14_ = NULL;
		gboolean _tmp15_;
		gboolean HasContext;
		gpointer _tmp45_ = NULL;
		ExogenesisTZDistance* _tmp46_;
		ExogenesisLocation* _tmp47_ = NULL;
		const gchar* _tmp48_ = NULL;
		gchar* _tmp49_;
		gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->_Distances);
		_tmp12_ = gdk_pixbuf_get_height (self->priv->_Background);
		height = (gdouble) _tmp12_;
		_tmp13_ = gdk_pixbuf_get_width (self->priv->_Background);
		width = (gdouble) _tmp13_;
		_tmp14_ = exogenesis_colour_get_Offset (o);
		_tmp15_ = string_contains (_tmp14_, "|");
		HasContext = _tmp15_;
		{
			GeeArrayList* _tmp16_ = NULL;
			GeeArrayList* _tmp17_;
			GeeArrayList* _loc_list;
			gint _tmp18_;
			gint _loc_size;
			gint _loc_index;
			_tmp16_ = exogenesis_tz_db_get_Locations (self->priv->_TZDb);
			_tmp17_ = _g_object_ref0 (_tmp16_);
			_loc_list = _tmp17_;
			_tmp18_ = gee_collection_get_size ((GeeCollection*) _loc_list);
			_loc_size = _tmp18_;
			_loc_index = -1;
			while (TRUE) {
				gpointer _tmp19_ = NULL;
				ExogenesisLocation* loc;
				gint roffsetsecs = 0;
				gdouble roffsetdays = 0.0;
				gint _tmp20_;
				gint _tmp21_;
				gchar* _tmp22_ = NULL;
				gchar* offset;
				const gchar* _tmp23_ = NULL;
				gchar** _tmp24_;
				gchar** _tmp25_ = NULL;
				gchar** _tmp26_;
				gint _tmp26__length1;
				gboolean _tmp27_;
				gdouble _tmp28_;
				gdouble _tmp29_;
				gdouble _tmp30_;
				gdouble _tmp31_;
				ExogenesisTZDistance* _tmp34_ = NULL;
				ExogenesisTZDistance* _tmp35_;
				_loc_index = _loc_index + 1;
				if (!(_loc_index < _loc_size)) {
					break;
				}
				_tmp19_ = gee_abstract_list_get ((GeeAbstractList*) _loc_list, _loc_index);
				loc = (ExogenesisLocation*) _tmp19_;
				_tmp20_ = exogenesis_location_RawUTCOffsetDays (loc);
				roffsetdays = (gdouble) _tmp20_;
				_tmp21_ = exogenesis_location_RawUTCOffsetSeconds (loc);
				roffsetsecs = _tmp21_;
				_tmp22_ = exogenesis_tz_widget_TZFormatString (self, (roffsetdays * 24) + ((roffsetsecs / 60.0) / 60.0));
				offset = _tmp22_;
				_tmp23_ = string_to_string (offset);
				_tmp25_ = _tmp24_ = g_strsplit (self->priv->_SelectedOffset, "|", 0);
				_tmp26_ = _tmp25_;
				_tmp26__length1 = _vala_array_length (_tmp24_);
				_tmp27_ = g_strcmp0 (_tmp23_, _tmp26_[0]) != 0;
				_tmp26_ = (_vala_array_free (_tmp26_, _tmp26__length1, (GDestroyNotify) g_free), NULL);
				if (_tmp27_) {
					_g_free0 (offset);
					_exogenesis_location_unref0 (loc);
					continue;
				}
				_tmp28_ = exogenesis_location_get_Longitude (loc);
				_tmp29_ = exogenesis_tz_widget_ConvertLongitudeToX (self, _tmp28_, width);
				PointX = _tmp29_;
				_tmp30_ = exogenesis_location_get_Latitude (loc);
				_tmp31_ = exogenesis_tz_widget_ConvertLatitudeToY (self, _tmp30_, height);
				PointY = _tmp31_;
				if (HasContext) {
					ExogenesisColour* _tmp32_ = NULL;
					gboolean _tmp33_;
					_tmp32_ = exogenesis_tz_widget_ConvertXYToOffset (self, PointX, PointY);
					_exogenesis_colour_unref0 (PointTo);
					PointTo = _tmp32_;
					_tmp33_ = exogenesis_tz_widget_CompareColour (self, PointTo, o);
					SameContext = _tmp33_;
				} else {
					SameContext = TRUE;
				}
				dx = PointX - x;
				dy = PointY - y;
				dist = (dx * dx) + (dy * dy);
				_tmp34_ = exogenesis_tz_distance_new (dist, loc, SameContext);
				_tmp35_ = _tmp34_;
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_Distances, _tmp35_);
				_g_object_unref0 (_tmp35_);
				_g_free0 (offset);
				_exogenesis_location_unref0 (loc);
			}
			_g_object_unref0 (_loc_list);
		}
		gee_list_sort ((GeeList*) self->priv->_Distances, NULL);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp36_;
				_tmp36_ = TRUE;
				while (TRUE) {
					gint _tmp37_;
					gpointer _tmp38_ = NULL;
					ExogenesisTZDistance* _tmp39_;
					gboolean _tmp40_;
					gboolean _tmp41_;
					if (!_tmp36_) {
						i++;
					}
					_tmp36_ = FALSE;
					_tmp37_ = gee_collection_get_size ((GeeCollection*) self->priv->_Distances);
					if (!(i < _tmp37_)) {
						break;
					}
					_tmp38_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_Distances, i);
					_tmp39_ = (ExogenesisTZDistance*) _tmp38_;
					_tmp40_ = exogenesis_tz_distance_get_SameContext (_tmp39_);
					_tmp41_ = _tmp40_;
					_g_object_unref0 (_tmp39_);
					if (_tmp41_) {
						if (i > 0) {
							gpointer _tmp42_ = NULL;
							ExogenesisTZDistance* tzdist;
							gpointer _tmp43_ = NULL;
							ExogenesisTZDistance* _tmp44_;
							_tmp42_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_Distances, i);
							tzdist = (ExogenesisTZDistance*) _tmp42_;
							_tmp43_ = gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->_Distances, i);
							_tmp44_ = (ExogenesisTZDistance*) _tmp43_;
							_g_object_unref0 (_tmp44_);
							gee_abstract_list_insert ((GeeAbstractList*) self->priv->_Distances, 0, tzdist);
							_g_object_unref0 (tzdist);
						}
						break;
					}
				}
			}
		}
		_tmp45_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_Distances, 0);
		_tmp46_ = (ExogenesisTZDistance*) _tmp45_;
		_tmp47_ = exogenesis_tz_distance_get_Loc (_tmp46_);
		_tmp48_ = exogenesis_location_get_Zone (_tmp47_);
		_tmp49_ = g_strdup (_tmp48_);
		_g_free0 (Zone);
		Zone = _tmp49_;
		_g_object_unref0 (_tmp46_);
		self->priv->_DistPos = 0;
		self->priv->_PrevClickX = x;
		self->priv->_PrevClickY = y;
		_exogenesis_colour_unref0 (PointTo);
	}
	exogenesis_tz_widget_SelectCity (self, Zone);
	gtk_widget_queue_draw ((GtkWidget*) self);
	result = TRUE;
	_g_free0 (Zone);
	_exogenesis_colour_unref0 (o);
	return result;
}


static void exogenesis_tz_widget_real_SelectCity (ExogenesisTZWidget* self, const gchar* Zone) {
	ExogenesisLocation* _tmp0_ = NULL;
	ExogenesisLocation* loc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (Zone != NULL);
	_tmp0_ = exogenesis_tz_db_GetLocationFromZone (self->priv->_TZDb, Zone);
	loc = _tmp0_;
	if (loc != NULL) {
		gint _tmp1_;
		gdouble roffsetdays;
		gint _tmp2_;
		gint roffset;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		struct tm _tmp6_ = {0};
		_tmp1_ = exogenesis_location_RawUTCOffsetDays (loc);
		roffsetdays = (gdouble) _tmp1_;
		_tmp2_ = exogenesis_location_RawUTCOffsetSeconds (loc);
		roffset = _tmp2_;
		_tmp3_ = exogenesis_location_get_CityName (loc);
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (self->priv->_SelectedCity);
		self->priv->_SelectedCity = _tmp4_;
		_tmp5_ = exogenesis_tz_widget_TZFormatString (self, (roffsetdays * 24) + ((roffset / 60.0) / 60.0));
		_g_free0 (self->priv->_SelectedOffset);
		self->priv->_SelectedOffset = _tmp5_;
		exogenesis_location_get_LocalTime (loc, &_tmp6_);
		g_signal_emit_by_name (self, "time-zone-selected", Zone, &_tmp6_);
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
	_exogenesis_location_unref0 (loc);
}


void exogenesis_tz_widget_SelectCity (ExogenesisTZWidget* self, const gchar* Zone) {
	EXOGENESIS_TZ_WIDGET_GET_CLASS (self)->SelectCity (self, Zone);
}


void exogenesis_tz_widget_RoundedRectangle (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, ExogenesisCairoCorners corners, gboolean topBottomFallsThrough) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (cr != NULL);
	if (topBottomFallsThrough) {
		_tmp0_ = corners == EXOGENESIS_CAIRO_CORNERS_None;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		cairo_move_to (cr, x, y - r);
		cairo_line_to (cr, x, (y + h) + r);
		cairo_move_to (cr, x + w, y - r);
		cairo_line_to (cr, x + w, (y + h) + r);
		return;
	} else {
		gboolean _tmp1_ = FALSE;
		if (r < 0.0001) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = corners == EXOGENESIS_CAIRO_CORNERS_None;
		}
		if (_tmp1_) {
			cairo_rectangle (cr, x, y, w, h);
			return;
		}
	}
	if ((corners & (EXOGENESIS_CAIRO_CORNERS_TopLeft | EXOGENESIS_CAIRO_CORNERS_TopRight)) == 0) {
		_tmp2_ = topBottomFallsThrough;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		y = y - r;
		h = h + r;
		cairo_move_to (cr, x + w, y);
	} else {
		if ((corners & EXOGENESIS_CAIRO_CORNERS_TopLeft) != 0) {
			cairo_move_to (cr, x + r, y);
		} else {
			cairo_move_to (cr, x, y);
		}
		if ((corners & EXOGENESIS_CAIRO_CORNERS_TopRight) != 0) {
			cairo_arc (cr, (x + w) - r, y + r, r, G_PI * 1.5, G_PI * 2);
		} else {
			cairo_line_to (cr, x + w, y);
		}
	}
	if ((corners & (EXOGENESIS_CAIRO_CORNERS_BottomLeft | EXOGENESIS_CAIRO_CORNERS_BottomRight)) == 0) {
		_tmp3_ = topBottomFallsThrough;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		h = h + r;
		cairo_line_to (cr, x + w, y + h);
		cairo_move_to (cr, x, y + h);
		cairo_line_to (cr, x, y + r);
		cairo_arc (cr, x + r, y + r, r, G_PI, G_PI * 1.5);
	} else {
		if ((corners & EXOGENESIS_CAIRO_CORNERS_BottomRight) != 0) {
			cairo_arc (cr, (x + w) - r, (y + h) - r, r, (gdouble) 0, G_PI * 0.5);
		} else {
			cairo_line_to (cr, x + w, y + h);
		}
		if ((corners & EXOGENESIS_CAIRO_CORNERS_BottomLeft) != 0) {
			cairo_arc (cr, x + r, (y + h) - r, r, G_PI * 0.5, G_PI);
		} else {
			cairo_line_to (cr, x, y + h);
		}
		if ((corners & EXOGENESIS_CAIRO_CORNERS_TopLeft) != 0) {
			cairo_arc (cr, x + r, y + r, r, G_PI, G_PI * 1.5);
		} else {
			cairo_line_to (cr, x, y);
		}
	}
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


gchar* exogenesis_tz_widget_TZFormatString (ExogenesisTZWidget* self, gdouble tzdiff) {
	gchar* result = NULL;
	gdouble _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* pos;
	gchar* _tmp2_ = NULL;
	gchar* rmdr;
	gchar** _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gchar* _tmp6_;
	const gchar* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = floor (tzdiff);
	_tmp1_ = double_to_string (_tmp0_);
	pos = _tmp1_;
	_tmp2_ = double_to_string (fmod (tzdiff, 1));
	rmdr = _tmp2_;
	_tmp4_ = _tmp3_ = g_strsplit (rmdr, ".", 0);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _vala_array_length (_tmp3_);
	_tmp6_ = g_strdup (_tmp5_[1]);
	_g_free0 (rmdr);
	rmdr = _tmp6_;
	_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	if (g_strcmp0 (rmdr, "") == 0) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = rmdr == NULL;
	}
	if (_tmp8_) {
		_tmp7_ = "0";
	} else {
		_tmp7_ = rmdr;
	}
	_tmp9_ = g_strconcat (pos, ".", NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_strconcat (_tmp10_, _tmp7_, NULL);
	_tmp12_ = _tmp11_;
	_g_free0 (_tmp10_);
	result = _tmp12_;
	_g_free0 (rmdr);
	_g_free0 (pos);
	return result;
}


const gchar* exogenesis_tz_widget_get_BackGroundFile (ExogenesisTZWidget* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_BackGroundFile;
	return result;
}


void exogenesis_tz_widget_set_BackGroundFile (ExogenesisTZWidget* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_BackGroundFile);
	self->priv->_BackGroundFile = _tmp0_;
	g_object_notify ((GObject *) self, "BackGroundFile");
}


const gchar* exogenesis_tz_widget_get_ColourMapFile (ExogenesisTZWidget* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_ColourMapFile;
	return result;
}


void exogenesis_tz_widget_set_ColourMapFile (ExogenesisTZWidget* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_ColourMapFile);
	self->priv->_ColourMapFile = _tmp0_;
	g_object_notify ((GObject *) self, "ColourMapFile");
}


static void g_cclosure_user_marshal_VOID__STRING_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_POINTER) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_POINTER callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_POINTER) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_pointer (param_values + 2), data2);
}


static void exogenesis_tz_widget_class_init (ExogenesisTZWidgetClass * klass) {
	exogenesis_tz_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisTZWidgetPrivate));
	GTK_WIDGET_CLASS (klass)->get_preferred_width = exogenesis_tz_widget_real_get_preferred_width;
	GTK_WIDGET_CLASS (klass)->get_preferred_height = exogenesis_tz_widget_real_get_preferred_height;
	GTK_WIDGET_CLASS (klass)->size_allocate = exogenesis_tz_widget_real_size_allocate;
	GTK_WIDGET_CLASS (klass)->realize = exogenesis_tz_widget_real_realize;
	GTK_WIDGET_CLASS (klass)->draw = exogenesis_tz_widget_real_draw;
	EXOGENESIS_TZ_WIDGET_CLASS (klass)->SelectCity = exogenesis_tz_widget_real_SelectCity;
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_tz_widget_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_tz_widget_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_tz_widget_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_TZ_WIDGET_BACK_GROUND_FILE, g_param_spec_string ("BackGroundFile", "BackGroundFile", "BackGroundFile", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_TZ_WIDGET_COLOUR_MAP_FILE, g_param_spec_string ("ColourMapFile", "ColourMapFile", "ColourMapFile", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("time_zone_selected", EXOGENESIS_TYPE_TZ_WIDGET, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_POINTER, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_POINTER);
}


static void exogenesis_tz_widget_instance_init (ExogenesisTZWidget * self) {
	ExogenesisColourMap* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	ExogenesisTZDb* _tmp2_ = NULL;
	self->priv = EXOGENESIS_TZ_WIDGET_GET_PRIVATE (self);
	_tmp0_ = exogenesis_colour_map_new ();
	self->priv->_colourmap = _tmp0_;
	_tmp1_ = gee_array_list_new (EXOGENESIS_TYPE_TZ_DISTANCE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->_Distances = _tmp1_;
	_tmp2_ = exogenesis_tz_db_new ();
	self->priv->_TZDb = _tmp2_;
	self->priv->_PrevClickX = (gdouble) (-1);
	self->priv->_PrevClickY = (gdouble) (-1);
	self->priv->_DistPos = 0;
}


static void exogenesis_tz_widget_finalize (GObject* obj) {
	ExogenesisTZWidget * self;
	self = EXOGENESIS_TZ_WIDGET (obj);
	_g_object_unref0 (self->priv->_colourmap);
	_g_object_unref0 (self->priv->_Distances);
	_exogenesis_tz_db_unref0 (self->priv->_TZDb);
	_g_free0 (self->priv->_ImagePath);
	_g_object_unref0 (self->priv->_OrigBackground);
	_g_object_unref0 (self->priv->_OrigColourMap);
	_g_object_unref0 (self->priv->_Background);
	_g_object_unref0 (self->priv->_ColourMap);
	_g_free0 (self->priv->_SelectedOffset);
	_g_free0 (self->priv->_SelectedCity);
	_g_free0 (self->priv->_TimeoutID);
	_g_free0 (self->priv->_BackGroundFile);
	_g_free0 (self->priv->_ColourMapFile);
	G_OBJECT_CLASS (exogenesis_tz_widget_parent_class)->finalize (obj);
}


GType exogenesis_tz_widget_get_type (void) {
	static volatile gsize exogenesis_tz_widget_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_tz_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisTZWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_tz_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisTZWidget), 0, (GInstanceInitFunc) exogenesis_tz_widget_instance_init, NULL };
		GType exogenesis_tz_widget_type_id;
		exogenesis_tz_widget_type_id = g_type_register_static (GTK_TYPE_WIDGET, "ExogenesisTZWidget", &g_define_type_info, 0);
		g_once_init_leave (&exogenesis_tz_widget_type_id__volatile, exogenesis_tz_widget_type_id);
	}
	return exogenesis_tz_widget_type_id__volatile;
}


static void _vala_exogenesis_tz_widget_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisTZWidget * self;
	self = EXOGENESIS_TZ_WIDGET (object);
	switch (property_id) {
		case EXOGENESIS_TZ_WIDGET_BACK_GROUND_FILE:
		g_value_set_string (value, exogenesis_tz_widget_get_BackGroundFile (self));
		break;
		case EXOGENESIS_TZ_WIDGET_COLOUR_MAP_FILE:
		g_value_set_string (value, exogenesis_tz_widget_get_ColourMapFile (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_tz_widget_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisTZWidget * self;
	self = EXOGENESIS_TZ_WIDGET (object);
	switch (property_id) {
		case EXOGENESIS_TZ_WIDGET_BACK_GROUND_FILE:
		exogenesis_tz_widget_set_BackGroundFile (self, g_value_get_string (value));
		break;
		case EXOGENESIS_TZ_WIDGET_COLOUR_MAP_FILE:
		exogenesis_tz_widget_set_ColourMapFile (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisTZDb* exogenesis_tz_db_construct (GType object_type) {
	ExogenesisTZDb* self = NULL;
	self = (ExogenesisTZDb*) g_type_create_instance (object_type);
	exogenesis_tz_db_ReadTZFile (self);
	return self;
}


ExogenesisTZDb* exogenesis_tz_db_new (void) {
	return exogenesis_tz_db_construct (EXOGENESIS_TYPE_TZ_DB);
}


ExogenesisLocation* exogenesis_tz_db_GetLocationForCity (ExogenesisTZDb* self, const gchar* city) {
	ExogenesisLocation* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (city != NULL, NULL);
	if (city != NULL) {
		{
			GeeArrayList* _tmp0_;
			GeeArrayList* _loc_list;
			gint _tmp1_;
			gint _loc_size;
			gint _loc_index;
			_tmp0_ = _g_object_ref0 (self->priv->_Locations);
			_loc_list = _tmp0_;
			_tmp1_ = gee_collection_get_size ((GeeCollection*) _loc_list);
			_loc_size = _tmp1_;
			_loc_index = -1;
			while (TRUE) {
				gpointer _tmp2_ = NULL;
				ExogenesisLocation* loc;
				const gchar* _tmp3_ = NULL;
				_loc_index = _loc_index + 1;
				if (!(_loc_index < _loc_size)) {
					break;
				}
				_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _loc_list, _loc_index);
				loc = (ExogenesisLocation*) _tmp2_;
				_tmp3_ = exogenesis_location_get_CityName (loc);
				if (g_strcmp0 (_tmp3_, city) == 0) {
					result = loc;
					_g_object_unref0 (_loc_list);
					return result;
				}
				_exogenesis_location_unref0 (loc);
			}
			_g_object_unref0 (_loc_list);
		}
		result = NULL;
		return result;
	} else {
		result = NULL;
		return result;
	}
}


ExogenesisLocation* exogenesis_tz_db_GetLocationFromZone (ExogenesisTZDb* self, const gchar* Zone) {
	ExogenesisLocation* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (Zone != NULL, NULL);
	if (Zone != NULL) {
		_tmp0_ = g_strcmp0 (Zone, "") != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		{
			GeeArrayList* _tmp1_;
			GeeArrayList* _loc_list;
			gint _tmp2_;
			gint _loc_size;
			gint _loc_index;
			_tmp1_ = _g_object_ref0 (self->priv->_Locations);
			_loc_list = _tmp1_;
			_tmp2_ = gee_collection_get_size ((GeeCollection*) _loc_list);
			_loc_size = _tmp2_;
			_loc_index = -1;
			while (TRUE) {
				gpointer _tmp3_ = NULL;
				ExogenesisLocation* loc;
				const gchar* _tmp4_ = NULL;
				_loc_index = _loc_index + 1;
				if (!(_loc_index < _loc_size)) {
					break;
				}
				_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _loc_list, _loc_index);
				loc = (ExogenesisLocation*) _tmp3_;
				_tmp4_ = exogenesis_location_get_Zone (loc);
				if (g_strcmp0 (_tmp4_, Zone) == 0) {
					result = loc;
					_g_object_unref0 (_loc_list);
					return result;
				}
				_exogenesis_location_unref0 (loc);
			}
			_g_object_unref0 (_loc_list);
		}
	}
	result = NULL;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_ = NULL;
	gchar* end;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	if (end == NULL) {
		result = maxlen;
		return result;
	} else {
		result = (glong) (end - str);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= 0) {
		_tmp0_ = len >= 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp1_;
		_tmp1_ = string_strnlen ((gchar*) self, offset + len);
		string_length = _tmp1_;
	} else {
		gint _tmp2_;
		_tmp2_ = strlen (self);
		string_length = (glong) _tmp2_;
	}
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}


static void exogenesis_tz_db_ReadTZFile (ExogenesisTZDb* self) {
	gchar* _tmp0_ = NULL;
	gchar* datain;
	ExogenesisLocation* location = NULL;
	gchar** country = NULL;
	gint country_length1 = 0;
	gint _country_size_ = 0;
	gchar* _tmp1_;
	gchar* lng;
	gchar* _tmp2_;
	gchar* lat;
	gint _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = exogenesis_general_functions_ReadTextFile (exogenesis_gGenFunc, self->priv->_TZDataFile);
	datain = _tmp0_;
	_tmp1_ = g_strdup ("");
	lng = _tmp1_;
	_tmp2_ = g_strdup ("");
	lat = _tmp2_;
	_tmp3_ = strlen (datain);
	if (_tmp3_ > 0) {
		gchar** _tmp4_;
		gchar** _tmp5_ = NULL;
		_tmp5_ = _tmp4_ = g_strsplit (datain, "\n", 0);
		country = (_vala_array_free (country, country_length1, (GDestroyNotify) g_free), NULL);
		country = _tmp5_;
		country_length1 = _vala_array_length (_tmp4_);
		_country_size_ = _vala_array_length (_tmp4_);
		{
			gchar** c_collection;
			int c_collection_length1;
			int c_it;
			c_collection = country;
			c_collection_length1 = country_length1;
			for (c_it = 0; c_it < country_length1; c_it = c_it + 1) {
				gchar* _tmp6_;
				gchar* c;
				_tmp6_ = g_strdup (c_collection[c_it]);
				c = _tmp6_;
				{
					gboolean _tmp7_ = FALSE;
					gchar* _tmp8_ = NULL;
					gchar* _tmp9_;
					gboolean _tmp10_;
					_tmp8_ = string_substring (c, (glong) 0, (glong) 1);
					_tmp9_ = _tmp8_;
					_tmp10_ = g_strcmp0 (_tmp9_, "#") != 0;
					_g_free0 (_tmp9_);
					if (_tmp10_) {
						_tmp7_ = g_strcmp0 (c, "") != 0;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						ExogenesisLocation* _tmp11_ = NULL;
						gchar** _tmp12_;
						gchar** _tmp13_ = NULL;
						gchar** data;
						gint data_length1;
						gint _data_size_;
						gchar* _tmp14_;
						gchar* coord;
						gint _tmp15_;
						gint pos;
						gchar** _tmp21_;
						gchar** _tmp22_ = NULL;
						gchar** _tmp23_;
						gint _tmp23__length1;
						const gchar* _tmp24_ = NULL;
						gdouble _tmp25_;
						gdouble _tmp26_;
						_tmp11_ = exogenesis_location_new ();
						_exogenesis_location_unref0 (location);
						location = _tmp11_;
						_tmp13_ = _tmp12_ = g_strsplit (c, "\t", 6);
						data = _tmp13_;
						data_length1 = _vala_array_length (_tmp12_);
						_data_size_ = _vala_array_length (_tmp12_);
						_tmp14_ = g_strdup (data[1]);
						coord = _tmp14_;
						_tmp15_ = exogenesis_tz_db_StringFind (self, coord, "-", 1);
						pos = _tmp15_;
						if (pos == (-1)) {
							gint _tmp16_;
							_tmp16_ = exogenesis_tz_db_StringFind (self, coord, "+", 1);
							pos = _tmp16_;
						}
						if (pos != (-1)) {
							gchar* _tmp17_ = NULL;
							gchar* _tmp18_ = NULL;
							_tmp17_ = string_substring (coord, (glong) 0, (glong) pos);
							_g_free0 (lat);
							lat = _tmp17_;
							_tmp18_ = string_substring (coord, (glong) pos, (glong) (-1));
							_g_free0 (lng);
							lng = _tmp18_;
						} else {
							gchar* _tmp19_;
							gchar* _tmp20_;
							_tmp19_ = g_strdup (coord);
							_g_free0 (lat);
							lat = _tmp19_;
							_tmp20_ = g_strdup ("+0");
							_g_free0 (lng);
							lng = _tmp20_;
						}
						exogenesis_location_set_CountryCode (location, data[0]);
						exogenesis_location_set_CountryName (location, data[2]);
						exogenesis_location_set_Zone (location, data[2]);
						_tmp22_ = _tmp21_ = g_strsplit (data[2], "/", 0);
						_tmp23_ = _tmp22_;
						_tmp23__length1 = _vala_array_length (_tmp21_);
						exogenesis_location_set_CityName (location, _tmp23_[1]);
						_tmp23_ = (_vala_array_free (_tmp23_, _tmp23__length1, (GDestroyNotify) g_free), NULL);
						if (data[3] != NULL) {
							_tmp24_ = data[3];
						} else {
							_tmp24_ = "";
						}
						exogenesis_location_set_Comment (location, _tmp24_);
						_tmp25_ = exogenesis_tz_db_ParsePosition (self, lat, 2);
						exogenesis_location_set_Latitude (location, _tmp25_);
						_tmp26_ = exogenesis_tz_db_ParsePosition (self, lng, 3);
						exogenesis_location_set_Longitude (location, _tmp26_);
						gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_Locations, location);
						_g_free0 (coord);
						data = (_vala_array_free (data, data_length1, (GDestroyNotify) g_free), NULL);
					}
					_g_free0 (c);
				}
			}
		}
	}
	goto __finally23;
	__catch23_g_error:
	{
		GError * e;
		gchar* _tmp27_ = NULL;
		gchar* _tmp28_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = g_strdup_printf ("%s\n", e->message);
		_tmp28_ = _tmp27_;
		exogenesis_general_functions_LogIt (_tmp28_);
		_g_free0 (_tmp28_);
		_g_error_free0 (e);
	}
	__finally23:
	if (_inner_error_ != NULL) {
		_g_free0 (lat);
		_g_free0 (lng);
		country = (_vala_array_free (country, country_length1, (GDestroyNotify) g_free), NULL);
		_exogenesis_location_unref0 (location);
		_g_free0 (datain);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (lat);
	_g_free0 (lng);
	country = (_vala_array_free (country, country_length1, (GDestroyNotify) g_free), NULL);
	_exogenesis_location_unref0 (location);
	_g_free0 (datain);
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = g_ascii_strtod (str, NULL);
	result = _tmp0_;
	return result;
}


static gdouble exogenesis_tz_db_ParsePosition (ExogenesisTZDb* self, const gchar* position, gint wholedigits) {
	gdouble result = 0.0;
	gchar* ws = NULL;
	gchar* fs = NULL;
	gdouble w = 0.0;
	gdouble f = 0.0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gdouble _tmp5_;
	gdouble _tmp6_;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (position != NULL, 0.0);
	if (g_strcmp0 (position, "") == 0) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = strlen (position);
		_tmp1_ = _tmp2_ < 4;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = wholedigits > 9;
	}
	if (_tmp0_) {
		result = 0.0;
		_g_free0 (fs);
		_g_free0 (ws);
		return result;
	}
	_tmp3_ = string_substring (position, (glong) 0, (glong) (wholedigits + 1));
	_g_free0 (ws);
	ws = _tmp3_;
	_tmp4_ = string_substring (position, (glong) (wholedigits + 1), (glong) (-1));
	_g_free0 (fs);
	fs = _tmp4_;
	_tmp5_ = double_parse (ws);
	w = _tmp5_;
	_tmp6_ = double_parse (fs);
	f = _tmp6_;
	if (w >= 0.0) {
		gint _tmp7_;
		gdouble _tmp8_;
		_tmp7_ = strlen (fs);
		_tmp8_ = pow (10.0, (gdouble) _tmp7_);
		result = w + (f / _tmp8_);
		_g_free0 (fs);
		_g_free0 (ws);
		return result;
	} else {
		gint _tmp9_;
		gdouble _tmp10_;
		_tmp9_ = strlen (fs);
		_tmp10_ = pow (10.0, (gdouble) _tmp9_);
		result = w - (f / _tmp10_);
		_g_free0 (fs);
		_g_free0 (ws);
		return result;
	}
	_g_free0 (fs);
	_g_free0 (ws);
}


static gint exogenesis_tz_db_StringFind (ExogenesisTZDb* self, const gchar* st, const gchar* chr, gint start) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (st != NULL, 0);
	g_return_val_if_fail (chr != NULL, 0);
	{
		gint i;
		i = start;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp1_;
				gchar* _tmp2_ = NULL;
				gchar* s;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				_tmp1_ = strlen (st);
				if (!(i < _tmp1_)) {
					break;
				}
				_tmp2_ = string_substring (st, (glong) i, (glong) 1);
				s = _tmp2_;
				if (g_strcmp0 (s, chr) == 0) {
					result = i;
					_g_free0 (s);
					return result;
				}
				_g_free0 (s);
			}
		}
	}
	result = -1;
	return result;
}


const gchar* exogenesis_tz_db_get_TZDataFile (ExogenesisTZDb* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_TZDataFile;
	return result;
}


void exogenesis_tz_db_set_TZDataFile (ExogenesisTZDb* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_TZDataFile);
	self->priv->_TZDataFile = _tmp0_;
}


const gchar* exogenesis_tz_db_get_ISO3166File (ExogenesisTZDb* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_ISO3166File;
	return result;
}


void exogenesis_tz_db_set_ISO3166File (ExogenesisTZDb* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_ISO3166File);
	self->priv->_ISO3166File = _tmp0_;
}


GeeArrayList* exogenesis_tz_db_get_Locations (ExogenesisTZDb* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Locations;
	return result;
}


static void exogenesis_value_tz_db_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_tz_db_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_tz_db_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_tz_db_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_tz_db_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_tz_db_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_tz_db_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisTZDb* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_tz_db_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_tz_db_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisTZDb** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_tz_db_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_tz_db (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecTZDb* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_TZ_DB), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_tz_db (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_TZ_DB), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_tz_db (GValue* value, gpointer v_object) {
	ExogenesisTZDb* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_TZ_DB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_TZ_DB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_tz_db_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_tz_db_unref (old);
	}
}


void exogenesis_value_take_tz_db (GValue* value, gpointer v_object) {
	ExogenesisTZDb* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_TZ_DB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_TZ_DB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_tz_db_unref (old);
	}
}


static void exogenesis_tz_db_class_init (ExogenesisTZDbClass * klass) {
	exogenesis_tz_db_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_TZ_DB_CLASS (klass)->finalize = exogenesis_tz_db_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisTZDbPrivate));
}


static void exogenesis_tz_db_instance_init (ExogenesisTZDb * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	GeeArrayList* _tmp2_ = NULL;
	self->priv = EXOGENESIS_TZ_DB_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("/usr/share/zoneinfo/zone.tab");
	self->priv->_TZDataFile = _tmp0_;
	_tmp1_ = g_strdup ("/usr/share/xml/iso-codes/iso_3166.xml");
	self->priv->_ISO3166File = _tmp1_;
	_tmp2_ = gee_array_list_new (EXOGENESIS_TYPE_LOCATION, (GBoxedCopyFunc) exogenesis_location_ref, exogenesis_location_unref, NULL);
	self->priv->_Locations = _tmp2_;
	self->ref_count = 1;
}


static void exogenesis_tz_db_finalize (ExogenesisTZDb* obj) {
	ExogenesisTZDb * self;
	self = EXOGENESIS_TZ_DB (obj);
	_g_free0 (self->priv->_TZDataFile);
	_g_free0 (self->priv->_ISO3166File);
	_g_object_unref0 (self->priv->_Locations);
}


GType exogenesis_tz_db_get_type (void) {
	static volatile gsize exogenesis_tz_db_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_tz_db_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_tz_db_init, exogenesis_value_tz_db_free_value, exogenesis_value_tz_db_copy_value, exogenesis_value_tz_db_peek_pointer, "p", exogenesis_value_tz_db_collect_value, "p", exogenesis_value_tz_db_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisTZDbClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_tz_db_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisTZDb), 0, (GInstanceInitFunc) exogenesis_tz_db_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_tz_db_type_id;
		exogenesis_tz_db_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisTZDb", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_tz_db_type_id__volatile, exogenesis_tz_db_type_id);
	}
	return exogenesis_tz_db_type_id__volatile;
}


gpointer exogenesis_tz_db_ref (gpointer instance) {
	ExogenesisTZDb* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_tz_db_unref (gpointer instance) {
	ExogenesisTZDb* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_TZ_DB_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static void g_time_gm (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	gmtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


gdouble exogenesis_location_UtcOffset (ExogenesisLocation* self) {
	gdouble result = 0.0;
	gint yr;
	gint mnth;
	gint day;
	gint hr;
	gint min;
	gint sec;
	GTimeVal tv = {0};
	struct tm _tmp0_ = {0};
	struct tm _tmp1_ = {0};
	struct tm local;
	struct tm _tmp2_ = {0};
	struct tm _tmp3_ = {0};
	time_t _tmp4_;
	glong gmt;
	time_t _tmp5_;
	glong lcl;
	gdouble offset;
	g_return_val_if_fail (self != NULL, 0.0);
	g_setenv ("TZ", self->priv->_Zone, TRUE);
	yr = 0;
	mnth = 0;
	day = 0;
	hr = 0;
	min = 0;
	sec = 0;
	oobs_time_config_get_time (self->priv->_tc, yr, mnth, day, hr, min, sec);
	g_get_current_time (&tv);
	g_get_current_time (&tv);
	g_time_local ((time_t) tv.tv_sec, &_tmp0_);
	_tmp1_ = _tmp0_;
	local = _tmp1_;
	exogenesis_location_set_LocalTime (self, &local);
	g_time_gm ((time_t) tv.tv_sec, &_tmp2_);
	_tmp3_ = _tmp2_;
	_tmp4_ = mktime (&_tmp3_);
	gmt = (glong) _tmp4_;
	_tmp5_ = mktime (&self->priv->_LocalTime);
	lcl = (glong) _tmp5_;
	offset = (((gdouble) (lcl - gmt)) / 60) / 60;
	result = offset;
	return result;
}


gint exogenesis_location_RawUTCOffsetDays (ExogenesisLocation* self) {
	gint result = 0;
	gdouble _tmp0_;
	gdouble offsethrs;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = exogenesis_location_UtcOffset (self);
	offsethrs = _tmp0_;
	result = (gint) (offsethrs / 24);
	return result;
}


gint exogenesis_location_RawUTCOffsetMinutes (ExogenesisLocation* self) {
	gint result = 0;
	gdouble _tmp0_;
	gdouble offsetsecs;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = exogenesis_location_UtcOffset (self);
	offsetsecs = _tmp0_;
	result = (gint) (offsetsecs * 60);
	return result;
}


gint exogenesis_location_RawUTCOffsetSeconds (ExogenesisLocation* self) {
	gint result = 0;
	gdouble _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = exogenesis_location_UtcOffset (self);
	result = (gint) ((_tmp0_ * 60) * 60);
	return result;
}


void exogenesis_location_Location (ExogenesisLocation* self) {
	g_return_if_fail (self != NULL);
}


ExogenesisLocation* exogenesis_location_construct (GType object_type) {
	ExogenesisLocation* self = NULL;
	self = (ExogenesisLocation*) g_type_create_instance (object_type);
	return self;
}


ExogenesisLocation* exogenesis_location_new (void) {
	return exogenesis_location_construct (EXOGENESIS_TYPE_LOCATION);
}


gdouble exogenesis_location_get_Longitude (ExogenesisLocation* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = self->priv->_Longitude;
	return result;
}


void exogenesis_location_set_Longitude (ExogenesisLocation* self, gdouble value) {
	g_return_if_fail (self != NULL);
	self->priv->_Longitude = value;
}


gdouble exogenesis_location_get_Latitude (ExogenesisLocation* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = self->priv->_Latitude;
	return result;
}


void exogenesis_location_set_Latitude (ExogenesisLocation* self, gdouble value) {
	g_return_if_fail (self != NULL);
	self->priv->_Latitude = value;
}


const gchar* exogenesis_location_get_CountryCode (ExogenesisLocation* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_CountryCode;
	return result;
}


void exogenesis_location_set_CountryCode (ExogenesisLocation* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_CountryCode);
	self->priv->_CountryCode = _tmp0_;
}


const gchar* exogenesis_location_get_CountryName (ExogenesisLocation* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_CountryName;
	return result;
}


void exogenesis_location_set_CountryName (ExogenesisLocation* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_CountryName);
	self->priv->_CountryName = _tmp0_;
}


const gchar* exogenesis_location_get_CityName (ExogenesisLocation* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_CityName;
	return result;
}


void exogenesis_location_set_CityName (ExogenesisLocation* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_CityName);
	self->priv->_CityName = _tmp0_;
}


const gchar* exogenesis_location_get_Comment (ExogenesisLocation* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Comment;
	return result;
}


void exogenesis_location_set_Comment (ExogenesisLocation* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Comment);
	self->priv->_Comment = _tmp0_;
}


const gchar* exogenesis_location_get_Zone (ExogenesisLocation* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Zone;
	return result;
}


void exogenesis_location_set_Zone (ExogenesisLocation* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Zone);
	self->priv->_Zone = _tmp0_;
}


void exogenesis_location_get_LocalTime (ExogenesisLocation* self, struct tm* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_LocalTime;
	return;
}


void exogenesis_location_set_LocalTime (ExogenesisLocation* self, struct tm* value) {
	g_return_if_fail (self != NULL);
	self->priv->_LocalTime = *value;
}


static void exogenesis_value_location_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_location_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_location_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_location_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_location_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_location_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_location_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisLocation* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_location_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_location_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisLocation** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_location_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_location (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecLocation* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_LOCATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_location (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_LOCATION), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_location (GValue* value, gpointer v_object) {
	ExogenesisLocation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_LOCATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_LOCATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_location_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_location_unref (old);
	}
}


void exogenesis_value_take_location (GValue* value, gpointer v_object) {
	ExogenesisLocation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_LOCATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_LOCATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_location_unref (old);
	}
}


static void exogenesis_location_class_init (ExogenesisLocationClass * klass) {
	exogenesis_location_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_LOCATION_CLASS (klass)->finalize = exogenesis_location_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisLocationPrivate));
}


static void exogenesis_location_instance_init (ExogenesisLocation * self) {
	OobsObject* _tmp0_ = NULL;
	OobsTimeConfig* _tmp1_;
	self->priv = EXOGENESIS_LOCATION_GET_PRIVATE (self);
	_tmp0_ = oobs_time_config_get ();
	_tmp1_ = _g_object_ref0 (OOBS_TIME_CONFIG (_tmp0_));
	self->priv->_tc = _tmp1_;
	self->ref_count = 1;
}


static void exogenesis_location_finalize (ExogenesisLocation* obj) {
	ExogenesisLocation * self;
	self = EXOGENESIS_LOCATION (obj);
	_g_object_unref0 (self->priv->_tc);
	_g_free0 (self->priv->_CountryCode);
	_g_free0 (self->priv->_CountryName);
	_g_free0 (self->priv->_CityName);
	_g_free0 (self->priv->_Comment);
	_g_free0 (self->priv->_Zone);
}


GType exogenesis_location_get_type (void) {
	static volatile gsize exogenesis_location_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_location_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_location_init, exogenesis_value_location_free_value, exogenesis_value_location_copy_value, exogenesis_value_location_peek_pointer, "p", exogenesis_value_location_collect_value, "p", exogenesis_value_location_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisLocationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_location_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisLocation), 0, (GInstanceInitFunc) exogenesis_location_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_location_type_id;
		exogenesis_location_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisLocation", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_location_type_id__volatile, exogenesis_location_type_id);
	}
	return exogenesis_location_type_id__volatile;
}


gpointer exogenesis_location_ref (gpointer instance) {
	ExogenesisLocation* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_location_unref (gpointer instance) {
	ExogenesisLocation* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_LOCATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisColourMap* exogenesis_colour_map_construct_WithDetail (GType object_type, const gchar* offset, gint a, gint b, gint c, gint d) {
	ExogenesisColourMap * self = NULL;
	g_return_val_if_fail (offset != NULL, NULL);
	self = (ExogenesisColourMap*) g_object_new (object_type, NULL);
	exogenesis_colour_map_AddColourMap (self, offset, a, b, c, d);
	return self;
}


ExogenesisColourMap* exogenesis_colour_map_new_WithDetail (const gchar* offset, gint a, gint b, gint c, gint d) {
	return exogenesis_colour_map_construct_WithDetail (EXOGENESIS_TYPE_COLOUR_MAP, offset, a, b, c, d);
}


void exogenesis_colour_map_AddColourMap (ExogenesisColourMap* self, const gchar* offset, gint a, gint b, gint c, gint d) {
	ExogenesisColour* _tmp0_ = NULL;
	ExogenesisColour* colour;
	g_return_if_fail (self != NULL);
	g_return_if_fail (offset != NULL);
	_tmp0_ = exogenesis_colour_new ();
	colour = _tmp0_;
	exogenesis_colour_set_Offset (colour, offset);
	exogenesis_colour_set_DataA (colour, a);
	exogenesis_colour_set_DataB (colour, b);
	exogenesis_colour_set_DataC (colour, c);
	exogenesis_colour_set_DataD (colour, d);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_colours, colour);
	_exogenesis_colour_unref0 (colour);
}


ExogenesisColour* exogenesis_colour_map_GetOffsetColour (ExogenesisColourMap* self, const gchar* offset) {
	ExogenesisColour* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (offset != NULL, NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _c_list;
		gint _tmp1_;
		gint _c_size;
		gint _c_index;
		_tmp0_ = _g_object_ref0 (self->priv->_colours);
		_c_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _c_list);
		_c_size = _tmp1_;
		_c_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			ExogenesisColour* c;
			const gchar* _tmp3_ = NULL;
			_c_index = _c_index + 1;
			if (!(_c_index < _c_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _c_list, _c_index);
			c = (ExogenesisColour*) _tmp2_;
			_tmp3_ = exogenesis_colour_get_Offset (c);
			if (g_strcmp0 (_tmp3_, offset) == 0) {
				result = c;
				_g_object_unref0 (_c_list);
				return result;
			}
			_exogenesis_colour_unref0 (c);
		}
		_g_object_unref0 (_c_list);
	}
	result = NULL;
	return result;
}


static GeeIterator* exogenesis_colour_map_real_iterator (GeeIterable* base) {
	ExogenesisColourMap * self;
	GeeIterator* result = NULL;
	GeeIterator* _tmp0_ = NULL;
	self = (ExogenesisColourMap*) base;
	_tmp0_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->_colours);
	result = _tmp0_;
	return result;
}


ExogenesisColourMap* exogenesis_colour_map_construct (GType object_type) {
	ExogenesisColourMap * self = NULL;
	self = (ExogenesisColourMap*) g_object_new (object_type, NULL);
	return self;
}


ExogenesisColourMap* exogenesis_colour_map_new (void) {
	return exogenesis_colour_map_construct (EXOGENESIS_TYPE_COLOUR_MAP);
}


static GType exogenesis_colour_map_real_get_element_type (GeeIterable* base) {
	GType result;
	ExogenesisColourMap* self;
	self = (ExogenesisColourMap*) base;
	result = EXOGENESIS_TYPE_COLOUR;
	return result;
}


static void exogenesis_colour_map_class_init (ExogenesisColourMapClass * klass) {
	exogenesis_colour_map_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisColourMapPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_colour_map_get_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_colour_map_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), EXOGENESIS_COLOUR_MAP_ELEMENT_TYPE, "element-type");
}


static void exogenesis_colour_map_gee_iterable_interface_init (GeeIterableIface * iface) {
	exogenesis_colour_map_gee_iterable_parent_iface = g_type_interface_peek_parent (iface);
	iface->iterator = (GeeIterator* (*)(GeeIterable*)) exogenesis_colour_map_real_iterator;
	iface->get_element_type = exogenesis_colour_map_real_get_element_type;
}


static void exogenesis_colour_map_instance_init (ExogenesisColourMap * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = EXOGENESIS_COLOUR_MAP_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (EXOGENESIS_TYPE_COLOUR, (GBoxedCopyFunc) exogenesis_colour_ref, exogenesis_colour_unref, NULL);
	self->priv->_colours = _tmp0_;
}


static void exogenesis_colour_map_finalize (GObject* obj) {
	ExogenesisColourMap * self;
	self = EXOGENESIS_COLOUR_MAP (obj);
	_g_object_unref0 (self->priv->_colours);
	G_OBJECT_CLASS (exogenesis_colour_map_parent_class)->finalize (obj);
}


GType exogenesis_colour_map_get_type (void) {
	static volatile gsize exogenesis_colour_map_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_colour_map_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisColourMapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_colour_map_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisColourMap), 0, (GInstanceInitFunc) exogenesis_colour_map_instance_init, NULL };
		static const GInterfaceInfo gee_iterable_info = { (GInterfaceInitFunc) exogenesis_colour_map_gee_iterable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_colour_map_type_id;
		exogenesis_colour_map_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisColourMap", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_colour_map_type_id, GEE_TYPE_ITERABLE, &gee_iterable_info);
		g_once_init_leave (&exogenesis_colour_map_type_id__volatile, exogenesis_colour_map_type_id);
	}
	return exogenesis_colour_map_type_id__volatile;
}


static void _vala_exogenesis_colour_map_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisColourMap * self;
	self = EXOGENESIS_COLOUR_MAP (object);
	switch (property_id) {
		case EXOGENESIS_COLOUR_MAP_ELEMENT_TYPE:
		g_value_set_gtype (value, gee_iterable_get_element_type ((GeeIterable*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


ExogenesisColour* exogenesis_colour_construct (GType object_type) {
	ExogenesisColour* self = NULL;
	self = (ExogenesisColour*) g_type_create_instance (object_type);
	return self;
}


ExogenesisColour* exogenesis_colour_new (void) {
	return exogenesis_colour_construct (EXOGENESIS_TYPE_COLOUR);
}


ExogenesisColour* exogenesis_colour_construct_WithValues (GType object_type, const gchar* offset, gint a, gint b, gint c, gint d) {
	ExogenesisColour* self = NULL;
	g_return_val_if_fail (offset != NULL, NULL);
	self = (ExogenesisColour*) g_type_create_instance (object_type);
	exogenesis_colour_set_Offset (self, offset);
	exogenesis_colour_set_DataA (self, a);
	exogenesis_colour_set_DataB (self, b);
	exogenesis_colour_set_DataC (self, c);
	exogenesis_colour_set_DataD (self, d);
	return self;
}


ExogenesisColour* exogenesis_colour_new_WithValues (const gchar* offset, gint a, gint b, gint c, gint d) {
	return exogenesis_colour_construct_WithValues (EXOGENESIS_TYPE_COLOUR, offset, a, b, c, d);
}


const gchar* exogenesis_colour_get_Offset (ExogenesisColour* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Offset;
	return result;
}


void exogenesis_colour_set_Offset (ExogenesisColour* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Offset);
	self->priv->_Offset = _tmp0_;
}


gint exogenesis_colour_get_DataA (ExogenesisColour* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_DataA;
	return result;
}


void exogenesis_colour_set_DataA (ExogenesisColour* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_DataA = value;
}


gint exogenesis_colour_get_DataB (ExogenesisColour* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_DataB;
	return result;
}


void exogenesis_colour_set_DataB (ExogenesisColour* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_DataB = value;
}


gint exogenesis_colour_get_DataC (ExogenesisColour* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_DataC;
	return result;
}


void exogenesis_colour_set_DataC (ExogenesisColour* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_DataC = value;
}


gint exogenesis_colour_get_DataD (ExogenesisColour* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_DataD;
	return result;
}


void exogenesis_colour_set_DataD (ExogenesisColour* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_DataD = value;
}


static void exogenesis_value_colour_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void exogenesis_value_colour_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		exogenesis_colour_unref (value->data[0].v_pointer);
	}
}


static void exogenesis_value_colour_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = exogenesis_colour_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer exogenesis_value_colour_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* exogenesis_value_colour_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ExogenesisColour* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = exogenesis_colour_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* exogenesis_value_colour_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ExogenesisColour** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = exogenesis_colour_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* exogenesis_param_spec_colour (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ExogenesisParamSpecColour* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EXOGENESIS_TYPE_COLOUR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer exogenesis_value_get_colour (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_COLOUR), NULL);
	return value->data[0].v_pointer;
}


void exogenesis_value_set_colour (GValue* value, gpointer v_object) {
	ExogenesisColour* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_COLOUR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_COLOUR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		exogenesis_colour_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_colour_unref (old);
	}
}


void exogenesis_value_take_colour (GValue* value, gpointer v_object) {
	ExogenesisColour* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EXOGENESIS_TYPE_COLOUR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EXOGENESIS_TYPE_COLOUR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		exogenesis_colour_unref (old);
	}
}


static void exogenesis_colour_class_init (ExogenesisColourClass * klass) {
	exogenesis_colour_parent_class = g_type_class_peek_parent (klass);
	EXOGENESIS_COLOUR_CLASS (klass)->finalize = exogenesis_colour_finalize;
	g_type_class_add_private (klass, sizeof (ExogenesisColourPrivate));
}


static void exogenesis_colour_instance_init (ExogenesisColour * self) {
	self->priv = EXOGENESIS_COLOUR_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void exogenesis_colour_finalize (ExogenesisColour* obj) {
	ExogenesisColour * self;
	self = EXOGENESIS_COLOUR (obj);
	_g_free0 (self->priv->_Offset);
}


GType exogenesis_colour_get_type (void) {
	static volatile gsize exogenesis_colour_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_colour_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { exogenesis_value_colour_init, exogenesis_value_colour_free_value, exogenesis_value_colour_copy_value, exogenesis_value_colour_peek_pointer, "p", exogenesis_value_colour_collect_value, "p", exogenesis_value_colour_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisColourClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_colour_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisColour), 0, (GInstanceInitFunc) exogenesis_colour_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType exogenesis_colour_type_id;
		exogenesis_colour_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExogenesisColour", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&exogenesis_colour_type_id__volatile, exogenesis_colour_type_id);
	}
	return exogenesis_colour_type_id__volatile;
}


gpointer exogenesis_colour_ref (gpointer instance) {
	ExogenesisColour* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void exogenesis_colour_unref (gpointer instance) {
	ExogenesisColour* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EXOGENESIS_COLOUR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ExogenesisTZDistance* exogenesis_tz_distance_construct (GType object_type, gdouble Dist, ExogenesisLocation* loc, gboolean samecontext) {
	ExogenesisTZDistance * self = NULL;
	g_return_val_if_fail (loc != NULL, NULL);
	self = (ExogenesisTZDistance*) g_object_new (object_type, NULL);
	exogenesis_tz_distance_set_Distance (self, Dist);
	exogenesis_tz_distance_set_Loc (self, loc);
	exogenesis_tz_distance_set_SameContext (self, samecontext);
	return self;
}


ExogenesisTZDistance* exogenesis_tz_distance_new (gdouble Dist, ExogenesisLocation* loc, gboolean samecontext) {
	return exogenesis_tz_distance_construct (EXOGENESIS_TYPE_TZ_DISTANCE, Dist, loc, samecontext);
}


static gint exogenesis_tz_distance_real_compare_to (GeeComparable* base, ExogenesisTZDistance* comp) {
	ExogenesisTZDistance * self;
	gint result = 0;
	self = (ExogenesisTZDistance*) base;
	g_return_val_if_fail (comp != NULL, 0);
	if (self->priv->_Distance < comp->priv->_Distance) {
		result = -1;
		return result;
	}
	if (self->priv->_Distance > comp->priv->_Distance) {
		result = 1;
		return result;
	}
	result = 0;
	return result;
}


gdouble exogenesis_tz_distance_get_Distance (ExogenesisTZDistance* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = self->priv->_Distance;
	return result;
}


void exogenesis_tz_distance_set_Distance (ExogenesisTZDistance* self, gdouble value) {
	g_return_if_fail (self != NULL);
	self->priv->_Distance = value;
	g_object_notify ((GObject *) self, "Distance");
}


ExogenesisLocation* exogenesis_tz_distance_get_Loc (ExogenesisTZDistance* self) {
	ExogenesisLocation* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Loc;
	return result;
}


static gpointer _exogenesis_location_ref0 (gpointer self) {
	return self ? exogenesis_location_ref (self) : NULL;
}


void exogenesis_tz_distance_set_Loc (ExogenesisTZDistance* self, ExogenesisLocation* value) {
	ExogenesisLocation* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _exogenesis_location_ref0 (value);
	_exogenesis_location_unref0 (self->priv->_Loc);
	self->priv->_Loc = _tmp0_;
	g_object_notify ((GObject *) self, "Loc");
}


gboolean exogenesis_tz_distance_get_SameContext (ExogenesisTZDistance* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_SameContext;
	return result;
}


void exogenesis_tz_distance_set_SameContext (ExogenesisTZDistance* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_SameContext = value;
	g_object_notify ((GObject *) self, "SameContext");
}


static void exogenesis_tz_distance_class_init (ExogenesisTZDistanceClass * klass) {
	exogenesis_tz_distance_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ExogenesisTZDistancePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_exogenesis_tz_distance_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_exogenesis_tz_distance_set_property;
	G_OBJECT_CLASS (klass)->finalize = exogenesis_tz_distance_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_TZ_DISTANCE_DISTANCE, g_param_spec_double ("Distance", "Distance", "Distance", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_TZ_DISTANCE_LOC, exogenesis_param_spec_location ("Loc", "Loc", "Loc", EXOGENESIS_TYPE_LOCATION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), EXOGENESIS_TZ_DISTANCE_SAME_CONTEXT, g_param_spec_boolean ("SameContext", "SameContext", "SameContext", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void exogenesis_tz_distance_gee_comparable_interface_init (GeeComparableIface * iface) {
	exogenesis_tz_distance_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable* ,gconstpointer)) exogenesis_tz_distance_real_compare_to;
}


static void exogenesis_tz_distance_instance_init (ExogenesisTZDistance * self) {
	self->priv = EXOGENESIS_TZ_DISTANCE_GET_PRIVATE (self);
}


static void exogenesis_tz_distance_finalize (GObject* obj) {
	ExogenesisTZDistance * self;
	self = EXOGENESIS_TZ_DISTANCE (obj);
	_exogenesis_location_unref0 (self->priv->_Loc);
	G_OBJECT_CLASS (exogenesis_tz_distance_parent_class)->finalize (obj);
}


GType exogenesis_tz_distance_get_type (void) {
	static volatile gsize exogenesis_tz_distance_type_id__volatile = 0;
	if (g_once_init_enter (&exogenesis_tz_distance_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ExogenesisTZDistanceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) exogenesis_tz_distance_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExogenesisTZDistance), 0, (GInstanceInitFunc) exogenesis_tz_distance_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) exogenesis_tz_distance_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType exogenesis_tz_distance_type_id;
		exogenesis_tz_distance_type_id = g_type_register_static (G_TYPE_OBJECT, "ExogenesisTZDistance", &g_define_type_info, 0);
		g_type_add_interface_static (exogenesis_tz_distance_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&exogenesis_tz_distance_type_id__volatile, exogenesis_tz_distance_type_id);
	}
	return exogenesis_tz_distance_type_id__volatile;
}


static void _vala_exogenesis_tz_distance_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ExogenesisTZDistance * self;
	self = EXOGENESIS_TZ_DISTANCE (object);
	switch (property_id) {
		case EXOGENESIS_TZ_DISTANCE_DISTANCE:
		g_value_set_double (value, exogenesis_tz_distance_get_Distance (self));
		break;
		case EXOGENESIS_TZ_DISTANCE_LOC:
		exogenesis_value_set_location (value, exogenesis_tz_distance_get_Loc (self));
		break;
		case EXOGENESIS_TZ_DISTANCE_SAME_CONTEXT:
		g_value_set_boolean (value, exogenesis_tz_distance_get_SameContext (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_exogenesis_tz_distance_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ExogenesisTZDistance * self;
	self = EXOGENESIS_TZ_DISTANCE (object);
	switch (property_id) {
		case EXOGENESIS_TZ_DISTANCE_DISTANCE:
		exogenesis_tz_distance_set_Distance (self, g_value_get_double (value));
		break;
		case EXOGENESIS_TZ_DISTANCE_LOC:
		exogenesis_tz_distance_set_Loc (self, exogenesis_value_get_location (value));
		break;
		case EXOGENESIS_TZ_DISTANCE_SAME_CONTEXT:
		exogenesis_tz_distance_set_SameContext (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



