/* segmentedbar.c generated by valac 0.12.1, the Vala compiler
 * generated from segmentedbar.vala, do not modify */

/**/
/* segmentedbar.vala*/
/**/
/* Author:*/
/**/
/*  Steve Wood <steve.wood@inixsys.com> (eeebuntu)*/
/*  */
/*  Based on SegmentedBar.cs by Aaron Bockover <abockover@novell.com>*/
/**/
/* Copyright (C) 2010 Inixsys Ltd ( developed for eeebuntu installer )*/
/* Copyright (C) 2008 Novell, Inc.*/
/* */
/**/
/* Permission is hereby granted, free of charge, to any person obtaining*/
/* a copy of this software and associated documentation files (the*/
/* "Software"), to deal in the Software without restriction, including*/
/* without limitation the rights to use, copy, modify, merge, publish,*/
/* distribute, sublicense, and/or sell copies of the Software, and to*/
/* permit persons to whom the Software is furnished to do so, subject to*/
/* the following conditions:*/
/**/
/* The above copyright notice and this permission notice shall be*/
/* included in all copies or substantial portions of the Software.*/
/**/
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,*/
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF*/
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND*/
/* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE*/
/* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION*/
/* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION*/
/* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <pango/pango.h>
#include <cairo.h>
#include <pango/pangocairo.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SEGMENTED_BAR (segmented_bar_get_type ())
#define SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SEGMENTED_BAR, SegmentedBar))
#define SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SEGMENTED_BAR, SegmentedBarClass))
#define IS_SEGMENTED_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SEGMENTED_BAR))
#define IS_SEGMENTED_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SEGMENTED_BAR))
#define SEGMENTED_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SEGMENTED_BAR, SegmentedBarClass))

typedef struct _SegmentedBar SegmentedBar;
typedef struct _SegmentedBarClass SegmentedBarClass;
typedef struct _SegmentedBarPrivate SegmentedBarPrivate;

#define SEGMENTED_BAR_TYPE_SEGMENT (segmented_bar_segment_get_type ())
#define SEGMENTED_BAR_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEGMENTED_BAR_TYPE_SEGMENT, SegmentedBarSegment))
#define SEGMENTED_BAR_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEGMENTED_BAR_TYPE_SEGMENT, SegmentedBarSegmentClass))
#define SEGMENTED_BAR_IS_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEGMENTED_BAR_TYPE_SEGMENT))
#define SEGMENTED_BAR_IS_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEGMENTED_BAR_TYPE_SEGMENT))
#define SEGMENTED_BAR_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEGMENTED_BAR_TYPE_SEGMENT, SegmentedBarSegmentClass))

typedef struct _SegmentedBarSegment SegmentedBarSegment;
typedef struct _SegmentedBarSegmentClass SegmentedBarSegmentClass;

#define SEGMENTED_BAR_TYPE_BAR_COLOUR (segmented_bar_bar_colour_get_type ())
typedef struct _SegmentedBarBarColour SegmentedBarBarColour;

#define SEGMENTED_BAR_TYPE_CAIRO_CORNERS (segmented_bar_cairo_corners_get_type ())
#define __g_list_free__segmented_bar_segment_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__segmented_bar_segment_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _SegmentedBarSegmentPrivate SegmentedBarSegmentPrivate;
#define _segmented_bar_segment_unref0(var) ((var == NULL) ? NULL : (var = (segmented_bar_segment_unref (var), NULL)))
#define _cairo_pattern_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_pattern_destroy (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
typedef struct _SegmentedBarParamSpecSegment SegmentedBarParamSpecSegment;

struct _SegmentedBar {
	GtkWidget parent_instance;
	SegmentedBarPrivate * priv;
	gboolean show_labels;
	gboolean reflect;
};

struct _SegmentedBarClass {
	GtkWidgetClass parent_class;
};

struct _SegmentedBarBarColour {
	gdouble _R;
	gdouble _G;
	gdouble _B;
	gdouble _A;
};

typedef gchar* (*SegmentedBarBarValueFormatHandler) (SegmentedBarSegment* segment, void* user_data);
struct _SegmentedBarPrivate {
	gint pango_size_normal;
	GList* segments;
	GStaticRecMutex __lock_segments;
	gint layout_width;
	gint layout_height;
	gint bar_height;
	gint bar_label_spacing;
	gint segment_label_spacing;
	gint segment_box_size;
	gint segment_box_spacing;
	gint h_padding;
	SegmentedBarBarColour remainder_color;
	SegmentedBarBarValueFormatHandler format_handler;
	gpointer format_handler_target;
	GDestroyNotify format_handler_target_destroy_notify;
};

typedef enum  {
	SEGMENTED_BAR_CAIRO_CORNERS_None = 0,
	SEGMENTED_BAR_CAIRO_CORNERS_TopLeft = 1,
	SEGMENTED_BAR_CAIRO_CORNERS_TopRight = 2,
	SEGMENTED_BAR_CAIRO_CORNERS_BottomLeft = 4,
	SEGMENTED_BAR_CAIRO_CORNERS_BottomRight = 8,
	SEGMENTED_BAR_CAIRO_CORNERS_All = 15
} SegmentedBarCairoCorners;

struct _SegmentedBarSegment {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SegmentedBarSegmentPrivate * priv;
	gint LayoutWidth;
	gint LayoutHeight;
};

struct _SegmentedBarSegmentClass {
	GTypeClass parent_class;
	void (*finalize) (SegmentedBarSegment *self);
};

struct _SegmentedBarSegmentPrivate {
	gchar* _Title;
	gint _Percent;
	SegmentedBarBarColour _Color;
	gboolean _ShowInBar;
};

struct _SegmentedBarParamSpecSegment {
	GParamSpec parent_instance;
};


static gpointer segmented_bar_parent_class = NULL;
static gpointer segmented_bar_segment_parent_class = NULL;

GType segmented_bar_get_type (void) G_GNUC_CONST;
gpointer segmented_bar_segment_ref (gpointer instance);
void segmented_bar_segment_unref (gpointer instance);
GParamSpec* segmented_bar_param_spec_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void segmented_bar_value_set_segment (GValue* value, gpointer v_object);
void segmented_bar_value_take_segment (GValue* value, gpointer v_object);
gpointer segmented_bar_value_get_segment (const GValue* value);
GType segmented_bar_segment_get_type (void) G_GNUC_CONST;
GType segmented_bar_bar_colour_get_type (void) G_GNUC_CONST;
SegmentedBarBarColour* segmented_bar_bar_colour_dup (const SegmentedBarBarColour* self);
void segmented_bar_bar_colour_free (SegmentedBarBarColour* self);
#define SEGMENTED_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SEGMENTED_BAR, SegmentedBarPrivate))
enum  {
	SEGMENTED_BAR_DUMMY_PROPERTY,
	SEGMENTED_BAR_REMAINDER,
	SEGMENTED_BAR_REMAINDER_COLOR,
	SEGMENTED_BAR_BAR_HEIGHT,
	SEGMENTED_BAR_SHOW_REFLECTION,
	SEGMENTED_BAR_SHOW_LABELS,
	SEGMENTED_BAR_SEGMENT_LABEL_SPACING,
	SEGMENTED_BAR_SEGMENT_BOX_SIZE,
	SEGMENTED_BAR_SEGMENT_BOX_SPACING,
	SEGMENTED_BAR_BAR_LABEL_SPACING,
	SEGMENTED_BAR_HORIZONTAL_PADDING
};
GType segmented_bar_cairo_corners_get_type (void) G_GNUC_CONST;
static void _segmented_bar_segment_unref0_ (gpointer var);
static void _g_list_free__segmented_bar_segment_unref0_ (GList* self);
void segmented_bar_RgbToColor (guint rgbColor, SegmentedBarBarColour* result);
SegmentedBar* segmented_bar_new (void);
SegmentedBar* segmented_bar_construct (GType object_type);
static void segmented_bar_real_realize (GtkWidget* base);
static void segmented_bar_real_get_preferred_width (GtkWidget* base, gint* minwidth, gint* natwidth);
static void segmented_bar_real_get_preferred_height (GtkWidget* base, gint* minheight, gint* natheight);
static void segmented_bar_real_size_allocate (GtkWidget* base, GdkRectangle* allocation);
static void segmented_bar_ComputeLayoutSize (SegmentedBar* self);
static PangoLayout* segmented_bar_CreateAdaptLayout (SegmentedBar* self, PangoLayout* layout, gboolean small, gboolean bold);
static gchar* segmented_bar_FormatSegmentText (SegmentedBar* self, SegmentedBarSegment* segment);
const gchar* segmented_bar_segment_get_Title (SegmentedBarSegment* self);
static gchar* segmented_bar_FormatSegmentValue (SegmentedBar* self, SegmentedBarSegment* segment);
void segmented_bar_AddSegmentRgba (SegmentedBar* self, const gchar* title, gint percent, guint rgbaColor);
void segmented_bar_AddSegmentB (SegmentedBar* self, const gchar* title, gint percent, SegmentedBarBarColour* color);
void segmented_bar_RgbaToColor (guint rgbaColor, SegmentedBarBarColour* result);
void segmented_bar_AddSegmentRgb (SegmentedBar* self, const gchar* title, gint percent, guint rgbColor);
void segmented_bar_AddSegment (SegmentedBar* self, SegmentedBarSegment* segment);
SegmentedBarSegment* segmented_bar_segment_new (const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar);
SegmentedBarSegment* segmented_bar_segment_construct (GType object_type, const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar);
void segmented_bar_AddSegmentA (SegmentedBar* self, const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar);
void segmented_bar_UpdateSegment (SegmentedBar* self, gint index, gint percent);
void segmented_bar_segment_set_Percent (SegmentedBarSegment* self, gint value);
void segmented_bar_RemoveAllSegments (SegmentedBar* self);
static gboolean segmented_bar_real_draw (GtkWidget* base, cairo_t* cr);
static cairo_pattern_t* segmented_bar_RenderBar (SegmentedBar* self, gint w, gint h);
static void segmented_bar_RenderLabelsA (SegmentedBar* self, cairo_t* cr);
static void segmented_bar_RenderBarA (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r);
static void segmented_bar_RenderBarSegments (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r);
static void segmented_bar_RenderBarStrokes (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r);
gint segmented_bar_segment_get_Percent (SegmentedBarSegment* self);
void segmented_bar_segment_get_Color (SegmentedBarSegment* self, SegmentedBarBarColour* result);
gdouble segmented_bar_bar_colour_get_R (SegmentedBarBarColour* self);
gdouble segmented_bar_bar_colour_get_G (SegmentedBarBarColour* self);
gdouble segmented_bar_bar_colour_get_B (SegmentedBarBarColour* self);
gdouble segmented_bar_bar_colour_get_A (SegmentedBarBarColour* self);
void segmented_bar_RoundedRectangleA (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r);
static cairo_pattern_t* segmented_bar_MakeSegmentGradient (SegmentedBar* self, gint h, SegmentedBarBarColour* color);
static cairo_pattern_t* segmented_bar_MakeSegmentGradientA (SegmentedBar* self, gint h, SegmentedBarBarColour* color, gboolean diag);
void segmented_bar_ColorShade (SegmentedBarBarColour* col, gdouble ratio, SegmentedBarBarColour* result);
void segmented_bar_GdkColorToCairoColorA (GdkColor* color, SegmentedBarBarColour* result);
void segmented_bar_bar_colour_set_A (SegmentedBarBarColour* self, gdouble value);
static void segmented_bar_RenderLabels (SegmentedBar* self, cairo_t* cr);
PangoLayout* segmented_bar_CreateLayout (GtkWidget* widget, cairo_t* cairo_context);
void segmented_bar_AlphaBlend (SegmentedBarBarColour* ca, SegmentedBarBarColour* cb, gdouble alpha, SegmentedBarBarColour* result);
void segmented_bar_bar_colour_init (SegmentedBarBarColour *self, gdouble red, gdouble green, gdouble blue, gdouble alpha);
void segmented_bar_GdkColorToCairoColor (GdkColor* color, gdouble alpha, SegmentedBarBarColour* result);
gboolean segmented_bar_ColorIsDark (SegmentedBarBarColour* color);
void segmented_bar_HsbFromColor (SegmentedBarBarColour* color, gdouble* hue, gdouble* saturation, gdouble* brightness);
static gdouble segmented_bar_Modula (gdouble number, gdouble divisor);
void segmented_bar_ColorFromHsb (gdouble hue, gdouble saturation, gdouble brightness, SegmentedBarBarColour* result);
void segmented_bar_ColorAdjustBrightness (SegmentedBarBarColour* col, gdouble br, SegmentedBarBarColour* result);
gchar* segmented_bar_ColorGetHex (SegmentedBarBarColour* color, gboolean withAlpha);
void segmented_bar_RoundedRectangle (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, SegmentedBarCairoCorners corners, gboolean topBottomFallsThrough);
void segmented_bar_RoundedRectangleB (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, SegmentedBarCairoCorners corners);
gint segmented_bar_get_Remainder (SegmentedBar* self);
SegmentedBarBarValueFormatHandler segmented_bar_get_ValueFormatter (SegmentedBar* self, gpointer* result_target);
void segmented_bar_set_ValueFormatter (SegmentedBar* self, SegmentedBarBarValueFormatHandler value, gpointer value_target);
void segmented_bar_get_RemainderColor (SegmentedBar* self, SegmentedBarBarColour* result);
void segmented_bar_set_RemainderColor (SegmentedBar* self, SegmentedBarBarColour* value);
gint segmented_bar_get_BarHeight (SegmentedBar* self);
void segmented_bar_set_BarHeight (SegmentedBar* self, gint value);
gboolean segmented_bar_get_ShowReflection (SegmentedBar* self);
void segmented_bar_set_ShowReflection (SegmentedBar* self, gboolean value);
gboolean segmented_bar_get_ShowLabels (SegmentedBar* self);
void segmented_bar_set_ShowLabels (SegmentedBar* self, gboolean value);
gint segmented_bar_get_SegmentLabelSpacing (SegmentedBar* self);
void segmented_bar_set_SegmentLabelSpacing (SegmentedBar* self, gint value);
gint segmented_bar_get_SegmentBoxSize (SegmentedBar* self);
void segmented_bar_set_SegmentBoxSize (SegmentedBar* self, gint value);
gint segmented_bar_get_SegmentBoxSpacing (SegmentedBar* self);
void segmented_bar_set_SegmentBoxSpacing (SegmentedBar* self, gint value);
gint segmented_bar_get_BarLabelSpacing (SegmentedBar* self);
void segmented_bar_set_BarLabelSpacing (SegmentedBar* self, gint value);
gint segmented_bar_get_HorizontalPadding (SegmentedBar* self);
void segmented_bar_set_HorizontalPadding (SegmentedBar* self, gint value);
#define SEGMENTED_BAR_SEGMENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SEGMENTED_BAR_TYPE_SEGMENT, SegmentedBarSegmentPrivate))
enum  {
	SEGMENTED_BAR_SEGMENT_DUMMY_PROPERTY
};
void segmented_bar_segment_set_Title (SegmentedBarSegment* self, const gchar* value);
void segmented_bar_segment_set_Color (SegmentedBarSegment* self, SegmentedBarBarColour* value);
void segmented_bar_segment_set_ShowInBar (SegmentedBarSegment* self, gboolean value);
gboolean segmented_bar_segment_get_ShowInBar (SegmentedBarSegment* self);
static void segmented_bar_segment_finalize (SegmentedBarSegment* obj);
void segmented_bar_bar_colour_set_R (SegmentedBarBarColour* self, gdouble value);
void segmented_bar_bar_colour_set_G (SegmentedBarBarColour* self, gdouble value);
void segmented_bar_bar_colour_set_B (SegmentedBarBarColour* self, gdouble value);
static void segmented_bar_finalize (GObject* obj);
static void _vala_segmented_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_segmented_bar_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


GType segmented_bar_cairo_corners_get_type (void) {
	static volatile gsize segmented_bar_cairo_corners_type_id__volatile = 0;
	if (g_once_init_enter (&segmented_bar_cairo_corners_type_id__volatile)) {
		static const GEnumValue values[] = {{SEGMENTED_BAR_CAIRO_CORNERS_None, "SEGMENTED_BAR_CAIRO_CORNERS_None", "none"}, {SEGMENTED_BAR_CAIRO_CORNERS_TopLeft, "SEGMENTED_BAR_CAIRO_CORNERS_TopLeft", "topleft"}, {SEGMENTED_BAR_CAIRO_CORNERS_TopRight, "SEGMENTED_BAR_CAIRO_CORNERS_TopRight", "topright"}, {SEGMENTED_BAR_CAIRO_CORNERS_BottomLeft, "SEGMENTED_BAR_CAIRO_CORNERS_BottomLeft", "bottomleft"}, {SEGMENTED_BAR_CAIRO_CORNERS_BottomRight, "SEGMENTED_BAR_CAIRO_CORNERS_BottomRight", "bottomright"}, {SEGMENTED_BAR_CAIRO_CORNERS_All, "SEGMENTED_BAR_CAIRO_CORNERS_All", "all"}, {0, NULL, NULL}};
		GType segmented_bar_cairo_corners_type_id;
		segmented_bar_cairo_corners_type_id = g_enum_register_static ("SegmentedBarCairoCorners", values);
		g_once_init_leave (&segmented_bar_cairo_corners_type_id__volatile, segmented_bar_cairo_corners_type_id);
	}
	return segmented_bar_cairo_corners_type_id__volatile;
}


static void _segmented_bar_segment_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (segmented_bar_segment_unref (var), NULL));
}


static void _g_list_free__segmented_bar_segment_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _segmented_bar_segment_unref0_, NULL);
	g_list_free (self);
}


SegmentedBar* segmented_bar_construct (GType object_type) {
	SegmentedBar * self = NULL;
	GtkAllocation alloc = {0};
	GtkContainer* _tmp0_ = NULL;
	GtkAllocation _tmp1_ = {0};
	self = (SegmentedBar*) gtk_widget_new (object_type, NULL);
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	alloc = _tmp1_;
	gtk_widget_set_has_window ((GtkWidget*) self, FALSE);
	g_object_set ((GtkWidget*) self, "width-request", alloc.width, NULL);
	g_object_set ((GtkWidget*) self, "height-request", alloc.height, NULL);
	return self;
}


SegmentedBar* segmented_bar_new (void) {
	return segmented_bar_construct (TYPE_SEGMENTED_BAR);
}


static void segmented_bar_real_realize (GtkWidget* base) {
	SegmentedBar * self;
	GtkContainer* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	self = (SegmentedBar*) base;
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	_tmp1_ = gtk_widget_get_parent_window ((GtkWidget*) _tmp0_);
	gtk_widget_set_parent_window ((GtkWidget*) self, _tmp1_);
	GTK_WIDGET_CLASS (segmented_bar_parent_class)->realize (GTK_WIDGET (self));
}


static void segmented_bar_real_get_preferred_width (GtkWidget* base, gint* minwidth, gint* natwidth) {
	SegmentedBar * self;
	gint _minwidth = 0;
	gint _natwidth = 0;
	self = (SegmentedBar*) base;
	_natwidth = 0;
	_minwidth = _natwidth;
	if (minwidth) {
		*minwidth = _minwidth;
	}
	if (natwidth) {
		*natwidth = _natwidth;
	}
}


static void segmented_bar_real_get_preferred_height (GtkWidget* base, gint* minheight, gint* natheight) {
	SegmentedBar * self;
	gint _minheight = 0;
	gint _natheight = 0;
	self = (SegmentedBar*) base;
	_natheight = 0;
	_minheight = _natheight;
	if (minheight) {
		*minheight = _minheight;
	}
	if (natheight) {
		*natheight = _natheight;
	}
}


static void segmented_bar_real_size_allocate (GtkWidget* base, GdkRectangle* allocation) {
	SegmentedBar * self;
	gint x = 0;
	gint y = 0;
	gint w = 0;
	gint h = 0;
	gint _tmp0_ = 0;
	gint _bar_height;
	self = (SegmentedBar*) base;
	x = (*allocation).x;
	y = (*allocation).y;
	w = (*allocation).width;
	h = (*allocation).height;
	if (self->reflect) {
		gdouble _tmp1_;
		_tmp1_ = ceil (self->priv->bar_height * 1.75);
		_tmp0_ = (gint) _tmp1_;
	} else {
		_tmp0_ = self->priv->bar_height;
	}
	_bar_height = _tmp0_;
	if (self->show_labels) {
		gint _tmp2_;
		segmented_bar_ComputeLayoutSize (self);
		_tmp2_ = MAX ((self->priv->bar_height + self->priv->bar_label_spacing) + self->priv->layout_height, _bar_height);
		g_object_set ((GtkWidget*) self, "height-request", _tmp2_, NULL);
		g_object_set ((GtkWidget*) self, "width-request", self->priv->layout_width + (2 * self->priv->h_padding), NULL);
	} else {
		g_object_set ((GtkWidget*) self, "height-request", _bar_height, NULL);
		g_object_set ((GtkWidget*) self, "width-request", self->priv->bar_height + (2 * self->priv->h_padding), NULL);
	}
	GTK_WIDGET_CLASS (segmented_bar_parent_class)->size_allocate (GTK_WIDGET (self), allocation);
}


static gpointer _segmented_bar_segment_ref0 (gpointer self) {
	return self ? segmented_bar_segment_ref (self) : NULL;
}


static void segmented_bar_ComputeLayoutSize (SegmentedBar* self) {
	PangoLayout* layout;
	g_return_if_fail (self != NULL);
	if (self->priv->segments == NULL) {
		return;
	}
	layout = NULL;
	self->priv->layout_height = 0;
	self->priv->layout_width = self->priv->layout_height;
	{
		GList* seg_collection;
		GList* seg_it;
		seg_collection = self->priv->segments;
		for (seg_it = seg_collection; seg_it != NULL; seg_it = seg_it->next) {
			SegmentedBarSegment* _tmp0_;
			SegmentedBarSegment* seg;
			_tmp0_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) seg_it->data);
			seg = _tmp0_;
			{
				gint aw = 0;
				gint ah = 0;
				gint bw = 0;
				gint bh = 0;
				PangoLayout* _tmp1_ = NULL;
				gchar* _tmp2_ = NULL;
				gchar* _tmp3_;
				const gchar* _tmp4_ = NULL;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				PangoLayout* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_;
				const gchar* _tmp11_ = NULL;
				gint _tmp12_;
				gint _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				gint w;
				gint h;
				gint _tmp16_;
				gint _tmp17_;
				_tmp1_ = segmented_bar_CreateAdaptLayout (self, layout, FALSE, TRUE);
				_g_object_unref0 (layout);
				layout = _tmp1_;
				_tmp2_ = segmented_bar_FormatSegmentText (self, seg);
				_tmp3_ = _tmp2_;
				_tmp4_ = segmented_bar_segment_get_Title (seg);
				_tmp5_ = strlen (_tmp4_);
				pango_layout_set_text (layout, _tmp3_, (gint) _tmp5_);
				_g_free0 (_tmp3_);
				pango_layout_get_pixel_size (layout, &_tmp6_, &_tmp7_);
				aw = _tmp6_;
				ah = _tmp7_;
				_tmp8_ = segmented_bar_CreateAdaptLayout (self, layout, TRUE, FALSE);
				_g_object_unref0 (layout);
				layout = _tmp8_;
				_tmp9_ = segmented_bar_FormatSegmentValue (self, seg);
				_tmp10_ = _tmp9_;
				_tmp11_ = segmented_bar_segment_get_Title (seg);
				_tmp12_ = strlen (_tmp11_);
				pango_layout_set_text (layout, _tmp10_, (gint) _tmp12_);
				_g_free0 (_tmp10_);
				pango_layout_get_pixel_size (layout, &_tmp13_, &_tmp14_);
				bw = _tmp13_;
				bh = _tmp14_;
				_tmp15_ = MAX (aw, bw);
				w = _tmp15_;
				h = ah + bh;
				seg->LayoutWidth = w;
				_tmp16_ = MAX (h, self->priv->segment_box_size * 2);
				seg->LayoutHeight = _tmp16_;
				self->priv->layout_width = self->priv->layout_width + (((seg->LayoutWidth + self->priv->segment_box_size) + self->priv->segment_box_spacing) + self->priv->segment_label_spacing);
				_tmp17_ = MAX (self->priv->layout_height, seg->LayoutHeight);
				self->priv->layout_height = _tmp17_;
				_segmented_bar_segment_unref0 (seg);
			}
		}
	}
	g_object_run_dispose ((GObject*) layout);
	_g_object_unref0 (layout);
}


void segmented_bar_AddSegmentRgba (SegmentedBar* self, const gchar* title, gint percent, guint rgbaColor) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (title != NULL);
	segmented_bar_RgbaToColor (rgbaColor, &_tmp0_);
	_tmp1_ = _tmp0_;
	segmented_bar_AddSegmentB (self, title, percent, &_tmp1_);
}


void segmented_bar_AddSegmentRgb (SegmentedBar* self, const gchar* title, gint percent, guint rgbColor) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (title != NULL);
	segmented_bar_RgbToColor (rgbColor, &_tmp0_);
	_tmp1_ = _tmp0_;
	segmented_bar_AddSegmentB (self, title, percent, &_tmp1_);
}


void segmented_bar_AddSegmentB (SegmentedBar* self, const gchar* title, gint percent, SegmentedBarBarColour* color) {
	SegmentedBarSegment* _tmp0_ = NULL;
	SegmentedBarSegment* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (title != NULL);
	_tmp0_ = segmented_bar_segment_new (title, percent, color, TRUE);
	_tmp1_ = _tmp0_;
	segmented_bar_AddSegment (self, _tmp1_);
	_segmented_bar_segment_unref0 (_tmp1_);
}


void segmented_bar_AddSegmentA (SegmentedBar* self, const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar) {
	SegmentedBarSegment* _tmp0_ = NULL;
	SegmentedBarSegment* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (title != NULL);
	_tmp0_ = segmented_bar_segment_new (title, percent, color, showInBar);
	_tmp1_ = _tmp0_;
	segmented_bar_AddSegment (self, _tmp1_);
	_segmented_bar_segment_unref0 (_tmp1_);
}


void segmented_bar_AddSegment (SegmentedBar* self, SegmentedBarSegment* segment) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (segment != NULL);
	{
		SegmentedBarSegment* _tmp0_;
		g_static_rec_mutex_lock (&self->priv->__lock_segments);
		_tmp0_ = _segmented_bar_segment_ref0 (segment);
		self->priv->segments = g_list_append (self->priv->segments, _tmp0_);
		gtk_widget_queue_draw ((GtkWidget*) self);
		__finally26:
		g_static_rec_mutex_unlock (&self->priv->__lock_segments);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


void segmented_bar_UpdateSegment (SegmentedBar* self, gint index, gint percent) {
	gint i;
	g_return_if_fail (self != NULL);
	i = 0;
	{
		GList* seg_collection;
		GList* seg_it;
		seg_collection = self->priv->segments;
		for (seg_it = seg_collection; seg_it != NULL; seg_it = seg_it->next) {
			SegmentedBarSegment* _tmp0_;
			SegmentedBarSegment* seg;
			_tmp0_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) seg_it->data);
			seg = _tmp0_;
			{
				i++;
				if (i == index) {
					segmented_bar_segment_set_Percent (seg, percent);
					gtk_widget_queue_draw ((GtkWidget*) self);
					_segmented_bar_segment_unref0 (seg);
					break;
				}
				_segmented_bar_segment_unref0 (seg);
			}
		}
	}
}


void segmented_bar_RemoveAllSegments (SegmentedBar* self) {
	g_return_if_fail (self != NULL);
	self->priv->segment_label_spacing = 16;
	__g_list_free__segmented_bar_segment_unref0_0 (self->priv->segments);
	self->priv->segments = NULL;
	__g_list_free__segmented_bar_segment_unref0_0 (self->priv->segments);
	self->priv->segments = NULL;
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static gboolean segmented_bar_real_draw (GtkWidget* base, cairo_t* cr) {
	SegmentedBar * self;
	gboolean result = FALSE;
	gint allocx = 0;
	gint allocy = 0;
	gint allocw = 0;
	gint alloch = 0;
	GtkAllocation allocation = {0};
	GtkAllocation _tmp0_ = {0};
	gint _tmp1_;
	cairo_pattern_t* _tmp2_ = NULL;
	cairo_pattern_t* bar;
	self = (SegmentedBar*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	allocation = _tmp0_;
	allocx = allocation.x;
	allocy = allocation.y;
	allocw = allocation.width;
	alloch = allocation.height;
	if (self->reflect) {
		cairo_push_group (cr);
	}
	cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
	cairo_translate (cr, (gdouble) (0 + self->priv->h_padding), (gdouble) 0);
	_tmp1_ = MAX (2 * self->priv->bar_height, (self->priv->bar_height + self->priv->bar_label_spacing) + self->priv->layout_height);
	cairo_rectangle (cr, (gdouble) 0, (gdouble) 0, (gdouble) (allocw - self->priv->h_padding), (gdouble) _tmp1_);
	cairo_clip (cr);
	_tmp2_ = segmented_bar_RenderBar (self, allocw - (2 * self->priv->h_padding), self->priv->bar_height);
	bar = _tmp2_;
	cairo_save (cr);
	cairo_set_source (cr, bar);
	cairo_paint (cr);
	cairo_restore (cr);
	if (self->reflect) {
		cairo_matrix_t matrix = {0};
		cairo_pattern_t* _tmp3_ = NULL;
		cairo_pattern_t* mask;
		cairo_save (cr);
		cairo_rectangle (cr, (gdouble) 0, (gdouble) self->priv->bar_height, (gdouble) (allocw - self->priv->h_padding), (gdouble) self->priv->bar_height);
		cairo_clip (cr);
		cairo_matrix_init (&matrix, (gdouble) 1, (gdouble) 0, (gdouble) 0, (gdouble) 1, (gdouble) 0, (gdouble) 0);
		cairo_matrix_scale (&matrix, (gdouble) 1, (gdouble) (-1));
		cairo_matrix_translate (&matrix, (gdouble) 0, (gdouble) ((-(2 * self->priv->bar_height)) + 1));
		cairo_transform (cr, &matrix);
		cairo_set_source (cr, bar);
		_tmp3_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) self->priv->bar_height);
		mask = _tmp3_;
		cairo_pattern_add_color_stop_rgba (mask, 0.25, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0);
		cairo_pattern_add_color_stop_rgba (mask, 0.5, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.125);
		cairo_pattern_add_color_stop_rgba (mask, 0.75, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.4);
		cairo_pattern_add_color_stop_rgba (mask, 1.0, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.7);
		cairo_mask (cr, mask);
		_cairo_pattern_destroy0 (mask);
		mask = NULL;
		cairo_restore (cr);
		cairo_pop_group_to_source (cr);
		cairo_paint (cr);
		_cairo_pattern_destroy0 (mask);
	}
	if (self->show_labels) {
		GdkWindow* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp4_ = gtk_widget_get_parent_window ((GtkWidget*) self);
		gtk_cairo_transform_to_window (cr, (GtkWidget*) self, _tmp4_);
		if (self->reflect) {
			_tmp5_ = allocx;
		} else {
			_tmp5_ = -self->priv->h_padding;
		}
		if (self->reflect) {
			_tmp6_ = allocy;
		} else {
			_tmp6_ = 0;
		}
		cairo_translate (cr, (gdouble) (_tmp5_ + ((allocw - self->priv->layout_width) / 2)), (gdouble) ((_tmp6_ + self->priv->bar_height) + self->priv->bar_label_spacing));
		segmented_bar_RenderLabelsA (self, cr);
	}
	result = TRUE;
	_cairo_pattern_destroy0 (bar);
	return result;
}


static cairo_pattern_t* segmented_bar_RenderBar (SegmentedBar* self, gint w, gint h) {
	cairo_pattern_t* result = NULL;
	cairo_surface_t* _tmp0_ = NULL;
	cairo_surface_t* s;
	cairo_t* _tmp1_ = NULL;
	cairo_t* cr;
	cairo_pattern_t* _tmp2_ = NULL;
	cairo_pattern_t* pattern;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, w, h);
	s = _tmp0_;
	_tmp1_ = cairo_create (s);
	cr = _tmp1_;
	segmented_bar_RenderBarA (self, cr, w, h, h / 2);
	_tmp2_ = cairo_pattern_create_for_surface (s);
	pattern = _tmp2_;
	_cairo_destroy0 (cr);
	cr = NULL;
	_cairo_surface_destroy0 (s);
	s = NULL;
	result = pattern;
	_cairo_destroy0 (cr);
	_cairo_surface_destroy0 (s);
	return result;
}


static void segmented_bar_RenderBarA (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	segmented_bar_RenderBarSegments (self, cr, w, h, r);
	segmented_bar_RenderBarStrokes (self, cr, w, h, r);
}


static void segmented_bar_RenderBarSegments (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r) {
	cairo_pattern_t* _tmp0_ = NULL;
	cairo_pattern_t* grad;
	gdouble last;
	gint segTotal;
	gdouble segPercent;
	cairo_pattern_t* _tmp39_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, (gdouble) w, (gdouble) 0);
	grad = _tmp0_;
	last = 0.0;
	segTotal = 0;
	segPercent = 0.0;
	{
		GList* segment_collection;
		GList* segment_it;
		segment_collection = self->priv->segments;
		for (segment_it = segment_collection; segment_it != NULL; segment_it = segment_it->next) {
			SegmentedBarSegment* _tmp1_;
			SegmentedBarSegment* segment;
			_tmp1_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) segment_it->data);
			segment = _tmp1_;
			{
				gint _tmp2_;
				_tmp2_ = segmented_bar_segment_get_Percent (segment);
				if (_tmp2_ > 0) {
					gint _tmp3_;
					SegmentedBarBarColour _tmp4_ = {0};
					gdouble _tmp5_;
					SegmentedBarBarColour _tmp6_ = {0};
					gdouble _tmp7_;
					SegmentedBarBarColour _tmp8_ = {0};
					gdouble _tmp9_;
					SegmentedBarBarColour _tmp10_ = {0};
					gdouble _tmp11_;
					SegmentedBarBarColour _tmp12_ = {0};
					gdouble _tmp13_;
					SegmentedBarBarColour _tmp14_ = {0};
					gdouble _tmp15_;
					SegmentedBarBarColour _tmp16_ = {0};
					gdouble _tmp17_;
					SegmentedBarBarColour _tmp18_ = {0};
					gdouble _tmp19_;
					gint _tmp20_;
					_tmp3_ = segmented_bar_segment_get_Percent (segment);
					segPercent = ((gdouble) _tmp3_) / 100;
					segmented_bar_segment_get_Color (segment, &_tmp4_);
					_tmp5_ = segmented_bar_bar_colour_get_R (&_tmp4_);
					segmented_bar_segment_get_Color (segment, &_tmp6_);
					_tmp7_ = segmented_bar_bar_colour_get_G (&_tmp6_);
					segmented_bar_segment_get_Color (segment, &_tmp8_);
					_tmp9_ = segmented_bar_bar_colour_get_B (&_tmp8_);
					segmented_bar_segment_get_Color (segment, &_tmp10_);
					_tmp11_ = segmented_bar_bar_colour_get_A (&_tmp10_);
					cairo_pattern_add_color_stop_rgba (grad, last, _tmp5_, _tmp7_, _tmp9_, _tmp11_);
					last = last + segPercent;
					segmented_bar_segment_get_Color (segment, &_tmp12_);
					_tmp13_ = segmented_bar_bar_colour_get_R (&_tmp12_);
					segmented_bar_segment_get_Color (segment, &_tmp14_);
					_tmp15_ = segmented_bar_bar_colour_get_G (&_tmp14_);
					segmented_bar_segment_get_Color (segment, &_tmp16_);
					_tmp17_ = segmented_bar_bar_colour_get_B (&_tmp16_);
					segmented_bar_segment_get_Color (segment, &_tmp18_);
					_tmp19_ = segmented_bar_bar_colour_get_A (&_tmp18_);
					cairo_pattern_add_color_stop_rgba (grad, last, _tmp13_, _tmp15_, _tmp17_, _tmp19_);
					_tmp20_ = segmented_bar_segment_get_Percent (segment);
					segTotal = segTotal + _tmp20_;
				}
				_segmented_bar_segment_unref0 (segment);
			}
		}
	}
	if (segTotal < 100) {
		SegmentedBarSegment* _tmp21_ = NULL;
		SegmentedBarSegment* seg;
		gint _tmp22_;
		SegmentedBarBarColour _tmp23_ = {0};
		gdouble _tmp24_;
		SegmentedBarBarColour _tmp25_ = {0};
		gdouble _tmp26_;
		SegmentedBarBarColour _tmp27_ = {0};
		gdouble _tmp28_;
		SegmentedBarBarColour _tmp29_ = {0};
		gdouble _tmp30_;
		SegmentedBarBarColour _tmp31_ = {0};
		gdouble _tmp32_;
		SegmentedBarBarColour _tmp33_ = {0};
		gdouble _tmp34_;
		SegmentedBarBarColour _tmp35_ = {0};
		gdouble _tmp36_;
		SegmentedBarBarColour _tmp37_ = {0};
		gdouble _tmp38_;
		_tmp21_ = segmented_bar_segment_new ("", 100 - segTotal, &self->priv->remainder_color, TRUE);
		seg = _tmp21_;
		_tmp22_ = segmented_bar_segment_get_Percent (seg);
		segPercent = ((gdouble) _tmp22_) / 100;
		segmented_bar_segment_get_Color (seg, &_tmp23_);
		_tmp24_ = segmented_bar_bar_colour_get_R (&_tmp23_);
		segmented_bar_segment_get_Color (seg, &_tmp25_);
		_tmp26_ = segmented_bar_bar_colour_get_G (&_tmp25_);
		segmented_bar_segment_get_Color (seg, &_tmp27_);
		_tmp28_ = segmented_bar_bar_colour_get_B (&_tmp27_);
		segmented_bar_segment_get_Color (seg, &_tmp29_);
		_tmp30_ = segmented_bar_bar_colour_get_A (&_tmp29_);
		cairo_pattern_add_color_stop_rgba (grad, last, _tmp24_, _tmp26_, _tmp28_, _tmp30_);
		last = last + segPercent;
		segmented_bar_segment_get_Color (seg, &_tmp31_);
		_tmp32_ = segmented_bar_bar_colour_get_R (&_tmp31_);
		segmented_bar_segment_get_Color (seg, &_tmp33_);
		_tmp34_ = segmented_bar_bar_colour_get_G (&_tmp33_);
		segmented_bar_segment_get_Color (seg, &_tmp35_);
		_tmp36_ = segmented_bar_bar_colour_get_B (&_tmp35_);
		segmented_bar_segment_get_Color (seg, &_tmp37_);
		_tmp38_ = segmented_bar_bar_colour_get_A (&_tmp37_);
		cairo_pattern_add_color_stop_rgba (grad, last, _tmp32_, _tmp34_, _tmp36_, _tmp38_);
		_segmented_bar_segment_unref0 (seg);
	}
	segmented_bar_RoundedRectangleA (cr, (gdouble) 0, (gdouble) 0, (gdouble) w, (gdouble) h, (gdouble) r);
	cairo_set_source (cr, grad);
	cairo_fill_preserve (cr);
	_cairo_pattern_destroy0 (grad);
	grad = NULL;
	_tmp39_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) h);
	_cairo_pattern_destroy0 (grad);
	grad = _tmp39_;
	cairo_pattern_add_color_stop_rgba (grad, 0.0, (gdouble) 1, (gdouble) 1, (gdouble) 1, 0.125);
	cairo_pattern_add_color_stop_rgba (grad, 0.35, (gdouble) 1, (gdouble) 1, (gdouble) 1, 0.255);
	cairo_pattern_add_color_stop_rgba (grad, (gdouble) 1, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.4);
	cairo_set_source (cr, grad);
	cairo_fill (cr);
	_cairo_pattern_destroy0 (grad);
	grad = NULL;
	_cairo_pattern_destroy0 (grad);
}


static void segmented_bar_RenderBarStrokes (SegmentedBar* self, cairo_t* cr, gint w, gint h, gint r) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	cairo_pattern_t* _tmp2_ = NULL;
	cairo_pattern_t* stroke;
	SegmentedBarBarColour _tmp3_ = {0};
	SegmentedBarBarColour _tmp4_ = {0};
	cairo_pattern_t* _tmp5_ = NULL;
	cairo_pattern_t* seg_sep_light;
	SegmentedBarBarColour _tmp6_ = {0};
	SegmentedBarBarColour _tmp7_ = {0};
	cairo_pattern_t* _tmp8_ = NULL;
	cairo_pattern_t* seg_sep_dark;
	gdouble seg_w;
	gdouble _tmp9_ = 0.0;
	gdouble x;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	segmented_bar_RgbaToColor ((guint) 0x00000040, &_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = segmented_bar_MakeSegmentGradient (self, h, &_tmp1_);
	stroke = _tmp2_;
	segmented_bar_RgbaToColor ((guint) 0xffffff20LL, &_tmp3_);
	_tmp4_ = _tmp3_;
	_tmp5_ = segmented_bar_MakeSegmentGradient (self, h, &_tmp4_);
	seg_sep_light = _tmp5_;
	segmented_bar_RgbaToColor ((guint) 0x00000020, &_tmp6_);
	_tmp7_ = _tmp6_;
	_tmp8_ = segmented_bar_MakeSegmentGradient (self, h, &_tmp7_);
	seg_sep_dark = _tmp8_;
	cairo_set_line_width (cr, (gdouble) 1);
	seg_w = (gdouble) 20;
	if (seg_w > r) {
		_tmp9_ = seg_w;
	} else {
		_tmp9_ = (gdouble) r;
	}
	x = _tmp9_;
	while (TRUE) {
		if (!(x <= (w - r))) {
			break;
		}
		cairo_move_to (cr, x - 0.5, (gdouble) 1);
		cairo_line_to (cr, x - 0.5, (gdouble) (h - 1));
		cairo_set_source (cr, seg_sep_light);
		cairo_stroke (cr);
		cairo_move_to (cr, x + 0.5, (gdouble) 1);
		cairo_line_to (cr, x + 0.5, (gdouble) (h - 1));
		cairo_set_source (cr, seg_sep_dark);
		cairo_stroke (cr);
		x = x + seg_w;
	}
	segmented_bar_RoundedRectangleA (cr, 0.5, 0.5, (gdouble) (w - 1), (gdouble) (h - 1), (gdouble) r);
	cairo_set_source (cr, stroke);
	cairo_stroke (cr);
	_cairo_pattern_destroy0 (seg_sep_light);
	seg_sep_light = NULL;
	_cairo_pattern_destroy0 (seg_sep_dark);
	seg_sep_dark = NULL;
	_cairo_pattern_destroy0 (seg_sep_dark);
	_cairo_pattern_destroy0 (seg_sep_light);
	_cairo_pattern_destroy0 (stroke);
}


static cairo_pattern_t* segmented_bar_MakeSegmentGradient (SegmentedBar* self, gint h, SegmentedBarBarColour* color) {
	cairo_pattern_t* result = NULL;
	cairo_pattern_t* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = segmented_bar_MakeSegmentGradientA (self, h, color, FALSE);
	result = _tmp0_;
	return result;
}


static cairo_pattern_t* segmented_bar_MakeSegmentGradientA (SegmentedBar* self, gint h, SegmentedBarBarColour* color, gboolean diag) {
	cairo_pattern_t* result = NULL;
	cairo_pattern_t* _tmp0_ = NULL;
	cairo_pattern_t* grad;
	SegmentedBarBarColour _tmp1_ = {0};
	SegmentedBarBarColour _tmp2_ = {0};
	SegmentedBarBarColour col;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	SegmentedBarBarColour _tmp7_ = {0};
	SegmentedBarBarColour _tmp8_ = {0};
	gdouble _tmp9_;
	gdouble _tmp10_;
	gdouble _tmp11_;
	gdouble _tmp12_;
	SegmentedBarBarColour _tmp13_ = {0};
	SegmentedBarBarColour _tmp14_ = {0};
	gdouble _tmp15_;
	gdouble _tmp16_;
	gdouble _tmp17_;
	gdouble _tmp18_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) h);
	grad = _tmp0_;
	segmented_bar_ColorShade (color, 1.1, &_tmp1_);
	_tmp2_ = _tmp1_;
	col = _tmp2_;
	_tmp3_ = segmented_bar_bar_colour_get_R (&col);
	_tmp4_ = segmented_bar_bar_colour_get_G (&col);
	_tmp5_ = segmented_bar_bar_colour_get_B (&col);
	_tmp6_ = segmented_bar_bar_colour_get_A (&col);
	cairo_pattern_add_color_stop_rgba (grad, (gdouble) 0, _tmp3_, _tmp4_, _tmp5_, _tmp6_);
	segmented_bar_ColorShade (color, 1.2, &_tmp7_);
	_tmp8_ = _tmp7_;
	col = _tmp8_;
	_tmp9_ = segmented_bar_bar_colour_get_R (&col);
	_tmp10_ = segmented_bar_bar_colour_get_G (&col);
	_tmp11_ = segmented_bar_bar_colour_get_B (&col);
	_tmp12_ = segmented_bar_bar_colour_get_A (&col);
	cairo_pattern_add_color_stop_rgba (grad, (gdouble) 0, _tmp9_, _tmp10_, _tmp11_, _tmp12_);
	segmented_bar_ColorShade (color, 0.8, &_tmp13_);
	_tmp14_ = _tmp13_;
	col = _tmp14_;
	_tmp15_ = segmented_bar_bar_colour_get_R (&col);
	_tmp16_ = segmented_bar_bar_colour_get_G (&col);
	_tmp17_ = segmented_bar_bar_colour_get_B (&col);
	_tmp18_ = segmented_bar_bar_colour_get_A (&col);
	cairo_pattern_add_color_stop_rgba (grad, (gdouble) 1, _tmp15_, _tmp16_, _tmp17_, _tmp18_);
	result = grad;
	return result;
}


static void segmented_bar_RenderLabelsA (SegmentedBar* self, cairo_t* cr) {
	gint allocx = 0;
	gint allocy = 0;
	GtkAllocation alloc = {0};
	GtkAllocation _tmp0_ = {0};
	PangoLayout* layout;
	GtkStyle* _tmp1_ = NULL;
	GdkColor _tmp2_;
	SegmentedBarBarColour _tmp3_ = {0};
	SegmentedBarBarColour _tmp4_ = {0};
	SegmentedBarBarColour text_color;
	gint x;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	alloc = _tmp0_;
	allocx = alloc.x;
	allocy = alloc.y;
	if (self->priv->segments == NULL) {
		return;
	}
	layout = NULL;
	_tmp1_ = gtk_widget_get_style ((GtkWidget*) self);
	segmented_bar_GdkColorToCairoColorA (&_tmp2_, &_tmp3_);
	_tmp4_ = _tmp3_;
	text_color = _tmp4_;
	x = 1;
	{
		GList* segment_collection;
		GList* segment_it;
		segment_collection = self->priv->segments;
		for (segment_it = segment_collection; segment_it != NULL; segment_it = segment_it->next) {
			SegmentedBarSegment* _tmp5_;
			SegmentedBarSegment* segment;
			_tmp5_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) segment_it->data);
			segment = _tmp5_;
			{
				cairo_pattern_t* _tmp6_ = NULL;
				cairo_pattern_t* grad;
				SegmentedBarBarColour _tmp7_ = {0};
				gdouble _tmp8_;
				SegmentedBarBarColour _tmp9_ = {0};
				gdouble _tmp10_;
				SegmentedBarBarColour _tmp11_ = {0};
				gdouble _tmp12_;
				SegmentedBarBarColour _tmp13_ = {0};
				gdouble _tmp14_;
				gint lw = 0;
				gint lh = 0;
				PangoLayout* _tmp15_ = NULL;
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_;
				const gchar* _tmp18_ = NULL;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gdouble _tmp22_;
				gdouble _tmp23_;
				gdouble _tmp24_;
				gdouble _tmp25_;
				PangoLayout* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_;
				const gchar* _tmp29_ = NULL;
				gint _tmp30_;
				gdouble _tmp31_;
				gdouble _tmp32_;
				gdouble _tmp33_;
				gdouble _tmp34_;
				cairo_set_line_width (cr, (gdouble) 1);
				cairo_rectangle (cr, x + 0.5, 2 + 0.5, (gdouble) (self->priv->segment_box_size - 1), (gdouble) (self->priv->segment_box_size - 1));
				_tmp6_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, 2.5, (gdouble) 0);
				grad = _tmp6_;
				segmented_bar_segment_get_Color (segment, &_tmp7_);
				_tmp8_ = segmented_bar_bar_colour_get_R (&_tmp7_);
				segmented_bar_segment_get_Color (segment, &_tmp9_);
				_tmp10_ = segmented_bar_bar_colour_get_G (&_tmp9_);
				segmented_bar_segment_get_Color (segment, &_tmp11_);
				_tmp12_ = segmented_bar_bar_colour_get_B (&_tmp11_);
				segmented_bar_segment_get_Color (segment, &_tmp13_);
				_tmp14_ = segmented_bar_bar_colour_get_A (&_tmp13_);
				cairo_pattern_add_color_stop_rgba (grad, (gdouble) 0, _tmp8_, _tmp10_, _tmp12_, _tmp14_);
				cairo_set_source (cr, grad);
				cairo_fill_preserve (cr);
				cairo_set_source_rgba (cr, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.6);
				cairo_stroke (cr);
				_cairo_pattern_destroy0 (grad);
				grad = NULL;
				x = x + (self->priv->segment_box_size + self->priv->segment_box_spacing);
				_tmp15_ = segmented_bar_CreateAdaptLayout (self, layout, FALSE, TRUE);
				_g_object_unref0 (layout);
				layout = _tmp15_;
				_tmp16_ = segmented_bar_FormatSegmentText (self, segment);
				_tmp17_ = _tmp16_;
				_tmp18_ = segmented_bar_segment_get_Title (segment);
				_tmp19_ = strlen (_tmp18_);
				pango_layout_set_text (layout, _tmp17_, (gint) _tmp19_);
				_g_free0 (_tmp17_);
				pango_layout_get_pixel_size (layout, &_tmp20_, &_tmp21_);
				lw = _tmp20_;
				lh = _tmp21_;
				cairo_move_to (cr, (gdouble) x, (gdouble) 0);
				segmented_bar_bar_colour_set_A (&text_color, 0.9);
				_tmp22_ = segmented_bar_bar_colour_get_R (&text_color);
				_tmp23_ = segmented_bar_bar_colour_get_G (&text_color);
				_tmp24_ = segmented_bar_bar_colour_get_B (&text_color);
				_tmp25_ = segmented_bar_bar_colour_get_A (&text_color);
				cairo_set_source_rgba (cr, _tmp22_, _tmp23_, _tmp24_, _tmp25_);
				pango_cairo_show_layout (cr, layout);
				cairo_fill (cr);
				_tmp26_ = segmented_bar_CreateAdaptLayout (self, layout, TRUE, FALSE);
				_g_object_unref0 (layout);
				layout = _tmp26_;
				_tmp27_ = segmented_bar_FormatSegmentValue (self, segment);
				_tmp28_ = _tmp27_;
				_tmp29_ = segmented_bar_segment_get_Title (segment);
				_tmp30_ = strlen (_tmp29_);
				pango_layout_set_text (layout, _tmp28_, (gint) _tmp30_);
				_g_free0 (_tmp28_);
				cairo_move_to (cr, (gdouble) x, (gdouble) lh);
				segmented_bar_bar_colour_set_A (&text_color, 0.75);
				_tmp31_ = segmented_bar_bar_colour_get_R (&text_color);
				_tmp32_ = segmented_bar_bar_colour_get_G (&text_color);
				_tmp33_ = segmented_bar_bar_colour_get_B (&text_color);
				_tmp34_ = segmented_bar_bar_colour_get_A (&text_color);
				cairo_set_source_rgba (cr, _tmp31_, _tmp32_, _tmp33_, _tmp34_);
				pango_cairo_show_layout (cr, layout);
				cairo_fill (cr);
				x = x + (segment->LayoutWidth + self->priv->segment_label_spacing);
				_cairo_pattern_destroy0 (grad);
				_segmented_bar_segment_unref0 (segment);
			}
		}
	}
	g_object_run_dispose ((GObject*) layout);
	_g_object_unref0 (layout);
}


static void segmented_bar_RenderLabels (SegmentedBar* self, cairo_t* cr) {
	PangoLayout* layout;
	GtkStyle* _tmp0_ = NULL;
	GdkColor _tmp1_;
	SegmentedBarBarColour _tmp2_ = {0};
	SegmentedBarBarColour _tmp3_ = {0};
	SegmentedBarBarColour text_color;
	gint x;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	if (self->priv->segments == NULL) {
		return;
	}
	layout = NULL;
	_tmp0_ = gtk_widget_get_style ((GtkWidget*) self);
	segmented_bar_GdkColorToCairoColorA (&_tmp1_, &_tmp2_);
	_tmp3_ = _tmp2_;
	text_color = _tmp3_;
	x = 0;
	{
		GList* segment_collection;
		GList* segment_it;
		segment_collection = self->priv->segments;
		for (segment_it = segment_collection; segment_it != NULL; segment_it = segment_it->next) {
			SegmentedBarSegment* _tmp4_;
			SegmentedBarSegment* segment;
			_tmp4_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) segment_it->data);
			segment = _tmp4_;
			{
				SegmentedBarBarColour _tmp5_ = {0};
				cairo_pattern_t* _tmp6_ = NULL;
				cairo_pattern_t* grad;
				gint lw = 0;
				gint lh = 0;
				PangoLayout* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_;
				const gchar* _tmp10_ = NULL;
				gint _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				gdouble _tmp14_;
				gdouble _tmp15_;
				gdouble _tmp16_;
				gdouble _tmp17_;
				PangoLayout* _tmp18_ = NULL;
				gchar* _tmp19_ = NULL;
				gchar* _tmp20_;
				const gchar* _tmp21_ = NULL;
				gint _tmp22_;
				gdouble _tmp23_;
				gdouble _tmp24_;
				gdouble _tmp25_;
				gdouble _tmp26_;
				cairo_set_line_width (cr, (gdouble) 1);
				cairo_rectangle (cr, x + 0.5, 2 + 0.5, (gdouble) (self->priv->segment_box_size - 1), (gdouble) (self->priv->segment_box_size - 1));
				segmented_bar_segment_get_Color (segment, &_tmp5_);
				_tmp6_ = segmented_bar_MakeSegmentGradientA (self, self->priv->segment_box_size, &_tmp5_, TRUE);
				grad = _tmp6_;
				cairo_set_source (cr, grad);
				cairo_fill_preserve (cr);
				cairo_set_source_rgba (cr, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.6);
				cairo_stroke (cr);
				_cairo_pattern_destroy0 (grad);
				grad = NULL;
				x = x + (self->priv->segment_box_size + self->priv->segment_box_spacing);
				_tmp7_ = segmented_bar_CreateAdaptLayout (self, layout, FALSE, TRUE);
				_g_object_unref0 (layout);
				layout = _tmp7_;
				_tmp8_ = segmented_bar_FormatSegmentText (self, segment);
				_tmp9_ = _tmp8_;
				_tmp10_ = segmented_bar_segment_get_Title (segment);
				_tmp11_ = strlen (_tmp10_);
				pango_layout_set_text (layout, _tmp9_, (gint) _tmp11_);
				_g_free0 (_tmp9_);
				pango_layout_get_pixel_size (layout, &_tmp12_, &_tmp13_);
				lw = _tmp12_;
				lh = _tmp13_;
				cairo_move_to (cr, (gdouble) x, (gdouble) 0);
				segmented_bar_bar_colour_set_A (&text_color, 0.9);
				_tmp14_ = segmented_bar_bar_colour_get_R (&text_color);
				_tmp15_ = segmented_bar_bar_colour_get_G (&text_color);
				_tmp16_ = segmented_bar_bar_colour_get_B (&text_color);
				_tmp17_ = segmented_bar_bar_colour_get_A (&text_color);
				cairo_set_source_rgba (cr, _tmp14_, _tmp15_, _tmp16_, _tmp17_);
				pango_cairo_show_layout (cr, layout);
				cairo_fill (cr);
				_tmp18_ = segmented_bar_CreateAdaptLayout (self, layout, TRUE, FALSE);
				_g_object_unref0 (layout);
				layout = _tmp18_;
				_tmp19_ = segmented_bar_FormatSegmentValue (self, segment);
				_tmp20_ = _tmp19_;
				_tmp21_ = segmented_bar_segment_get_Title (segment);
				_tmp22_ = strlen (_tmp21_);
				pango_layout_set_text (layout, _tmp20_, (gint) _tmp22_);
				_g_free0 (_tmp20_);
				cairo_move_to (cr, (gdouble) x, (gdouble) lh);
				segmented_bar_bar_colour_set_A (&text_color, 0.75);
				_tmp23_ = segmented_bar_bar_colour_get_R (&text_color);
				_tmp24_ = segmented_bar_bar_colour_get_G (&text_color);
				_tmp25_ = segmented_bar_bar_colour_get_B (&text_color);
				_tmp26_ = segmented_bar_bar_colour_get_A (&text_color);
				cairo_set_source_rgba (cr, _tmp23_, _tmp24_, _tmp25_, _tmp26_);
				pango_cairo_show_layout (cr, layout);
				cairo_fill (cr);
				x = x + (segment->LayoutWidth + self->priv->segment_label_spacing);
				_cairo_pattern_destroy0 (grad);
				_segmented_bar_segment_unref0 (segment);
			}
		}
	}
	g_object_run_dispose ((GObject*) layout);
	_g_object_unref0 (layout);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _pango_font_description_copy0 (gpointer self) {
	return self ? pango_font_description_copy (self) : NULL;
}


static PangoLayout* segmented_bar_CreateAdaptLayout (SegmentedBar* self, PangoLayout* layout, gboolean small, gboolean bold) {
	PangoLayout* result = NULL;
	PangoFontDescription* fd = NULL;
	PangoContext* context = NULL;
	PangoContext* _tmp2_ = NULL;
	PangoContext* _tmp3_;
	const PangoFontDescription* _tmp4_ = NULL;
	PangoFontDescription* _tmp5_;
	gint _tmp6_;
	PangoLayout* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	if (layout == NULL) {
		PangoContext* _tmp0_ = NULL;
		PangoLayout* _tmp1_ = NULL;
		_tmp0_ = gtk_widget_create_pango_context ((GtkWidget*) self);
		_g_object_unref0 (context);
		context = _tmp0_;
		_tmp1_ = gtk_widget_create_pango_layout ((GtkWidget*) self, "widget");
		layout = _tmp1_;
	}
	_tmp2_ = gtk_widget_get_pango_context ((GtkWidget*) self);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (context);
	context = _tmp3_;
	_tmp4_ = pango_context_get_font_description (context);
	_tmp5_ = _pango_font_description_copy0 (_tmp4_);
	_pango_font_description_free0 (fd);
	fd = _tmp5_;
	_tmp6_ = pango_font_description_get_size (fd);
	self->priv->pango_size_normal = _tmp6_;
	if (small) {
		gint _tmp7_;
		_tmp7_ = pango_font_description_get_size (fd);
		pango_font_description_set_size (fd, (gint) (_tmp7_ * PANGO_SCALE_SMALL));
	} else {
		pango_font_description_set_size (fd, self->priv->pango_size_normal);
	}
	if (bold) {
		pango_font_description_set_weight (fd, PANGO_WEIGHT_BOLD);
	} else {
		pango_font_description_set_weight (fd, PANGO_WEIGHT_NORMAL);
	}
	_tmp8_ = _g_object_ref0 (layout);
	result = _tmp8_;
	_g_object_unref0 (context);
	_pango_font_description_free0 (fd);
	return result;
}


static gchar* segmented_bar_FormatSegmentText (SegmentedBar* self, SegmentedBarSegment* segment) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (segment != NULL, NULL);
	_tmp0_ = segmented_bar_segment_get_Title (segment);
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static gchar* segmented_bar_FormatSegmentValue (SegmentedBar* self, SegmentedBarSegment* segment) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (segment != NULL, NULL);
	if (self->priv->format_handler == NULL) {
		gint _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp1_ = segmented_bar_segment_get_Percent (segment);
		_tmp2_ = g_strdup_printf ("%i", _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_strconcat (_tmp3_, "%", NULL);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp4_;
		_g_free0 (_tmp3_);
	} else {
		gchar* _tmp5_ = NULL;
		_tmp5_ = self->priv->format_handler (segment, self->priv->format_handler_target);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp5_;
	}
	result = _tmp0_;
	return result;
}


PangoLayout* segmented_bar_CreateLayout (GtkWidget* widget, cairo_t* cairo_context) {
	PangoLayout* result = NULL;
	PangoLayout* _tmp0_ = NULL;
	PangoLayout* layout;
	PangoContext* _tmp1_ = NULL;
	const PangoFontDescription* _tmp2_ = NULL;
	GdkScreen* _tmp3_ = NULL;
	gdouble _tmp4_;
	gdouble resolution;
	g_return_val_if_fail (widget != NULL, NULL);
	g_return_val_if_fail (cairo_context != NULL, NULL);
	_tmp0_ = pango_cairo_create_layout (cairo_context);
	layout = _tmp0_;
	_tmp1_ = gtk_widget_get_pango_context (widget);
	_tmp2_ = pango_context_get_font_description (_tmp1_);
	pango_layout_set_font_description (layout, _tmp2_);
	_tmp3_ = gtk_widget_get_screen (widget);
	_tmp4_ = gdk_screen_get_resolution (_tmp3_);
	resolution = _tmp4_;
	if (resolution != (-1)) {
		PangoContext* _tmp5_ = NULL;
		PangoContext* _tmp6_;
		PangoContext* context;
		_tmp5_ = pango_layout_get_context (layout);
		_tmp6_ = _g_object_ref0 (_tmp5_);
		context = _tmp6_;
		pango_cairo_context_set_resolution (context, resolution);
		_g_object_unref0 (context);
	}
	result = layout;
	return result;
}


void segmented_bar_AlphaBlend (SegmentedBarBarColour* ca, SegmentedBarBarColour* cb, gdouble alpha, SegmentedBarBarColour* result) {
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	SegmentedBarBarColour _tmp6_ = {0};
	SegmentedBarBarColour _tmp7_ = {0};
	_tmp0_ = segmented_bar_bar_colour_get_R (ca);
	_tmp1_ = segmented_bar_bar_colour_get_R (cb);
	_tmp2_ = segmented_bar_bar_colour_get_G (ca);
	_tmp3_ = segmented_bar_bar_colour_get_G (cb);
	_tmp4_ = segmented_bar_bar_colour_get_B (ca);
	_tmp5_ = segmented_bar_bar_colour_get_B (cb);
	segmented_bar_bar_colour_init (&_tmp6_, ((1.0 - alpha) * _tmp0_) + (alpha * _tmp1_), ((1.0 - alpha) * _tmp2_) + (alpha * _tmp3_), ((1.0 - alpha) * _tmp4_) + (alpha * _tmp5_), alpha);
	_tmp7_ = _tmp6_;
	*result = _tmp7_;
	return;
}


void segmented_bar_GdkColorToCairoColorA (GdkColor* color, SegmentedBarBarColour* result) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	segmented_bar_GdkColorToCairoColor (color, 1.0, &_tmp0_);
	_tmp1_ = _tmp0_;
	*result = _tmp1_;
	return;
}


void segmented_bar_GdkColorToCairoColor (GdkColor* color, gdouble alpha, SegmentedBarBarColour* result) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	segmented_bar_bar_colour_init (&_tmp0_, ((gdouble) ((*color).red >> 8)) / 255.0, ((gdouble) ((*color).green >> 8)) / 255.0, ((gdouble) ((*color).blue >> 8)) / 255.0, alpha);
	_tmp1_ = _tmp0_;
	*result = _tmp1_;
	return;
}


void segmented_bar_RgbToColor (guint rgbColor, SegmentedBarBarColour* result) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	segmented_bar_RgbaToColor ((rgbColor << 8) | 0x000000ff, &_tmp0_);
	_tmp1_ = _tmp0_;
	*result = _tmp1_;
	return;
}


void segmented_bar_RgbaToColor (guint rgbaColor, SegmentedBarBarColour* result) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	segmented_bar_bar_colour_init (&_tmp0_, ((guint) ((rgbaColor >> 24) & 0xFF)) / 255.0, ((guint) ((rgbaColor >> 16) & 0xFF)) / 255.0, ((guint) ((rgbaColor >> 8) & 0xFF)) / 255.0, ((guint) ((rgbaColor & 0x000000ff) & 0xFF)) / 255.0);
	_tmp1_ = _tmp0_;
	*result = _tmp1_;
	return;
}


gboolean segmented_bar_ColorIsDark (SegmentedBarBarColour* color) {
	gboolean result = FALSE;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble b = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	segmented_bar_HsbFromColor (color, &_tmp0_, &_tmp1_, &_tmp2_);
	h = _tmp0_;
	s = _tmp1_;
	b = _tmp2_;
	result = b < 0.5;
	return result;
}


void segmented_bar_HsbFromColor (SegmentedBarBarColour* color, gdouble* hue, gdouble* saturation, gdouble* brightness) {
	gdouble _hue = 0.0;
	gdouble _saturation = 0.0;
	gdouble _brightness = 0.0;
	gdouble min = 0.0;
	gdouble max = 0.0;
	gdouble delta = 0.0;
	gdouble _tmp0_;
	gdouble red;
	gdouble _tmp1_;
	gdouble green;
	gdouble _tmp2_;
	gdouble blue;
	gdouble _tmp7_;
	_tmp0_ = segmented_bar_bar_colour_get_R (color);
	red = _tmp0_;
	_tmp1_ = segmented_bar_bar_colour_get_G (color);
	green = _tmp1_;
	_tmp2_ = segmented_bar_bar_colour_get_B (color);
	blue = _tmp2_;
	_hue = (gdouble) 0;
	_saturation = (gdouble) 0;
	_brightness = (gdouble) 0;
	if (red > green) {
		gdouble _tmp3_;
		gdouble _tmp4_;
		_tmp3_ = MAX (red, blue);
		max = _tmp3_;
		_tmp4_ = MIN (green, blue);
		min = _tmp4_;
	} else {
		gdouble _tmp5_;
		gdouble _tmp6_;
		_tmp5_ = MAX (green, blue);
		max = _tmp5_;
		_tmp6_ = MIN (red, blue);
		min = _tmp6_;
	}
	_brightness = (max + min) / 2;
	_tmp7_ = fabs (max - min);
	if (_tmp7_ < 0.0001) {
		_hue = (gdouble) 0;
		_saturation = (gdouble) 0;
	} else {
		gdouble _tmp8_ = 0.0;
		if (_brightness <= 0.5) {
			_tmp8_ = (max - min) / (max + min);
		} else {
			_tmp8_ = (max - min) / ((2 - max) - min);
		}
		_saturation = _tmp8_;
		delta = max - min;
		if (red == max) {
			_hue = (green - blue) / delta;
		} else {
			if (green == max) {
				_hue = 2 + ((blue - red) / delta);
			} else {
				if (blue == max) {
					_hue = 4 + ((red - green) / delta);
				}
			}
		}
		_hue = _hue * ((gdouble) 60);
		if (_hue < 0) {
			_hue = _hue + ((gdouble) 360);
		}
	}
	if (hue) {
		*hue = _hue;
	}
	if (saturation) {
		*saturation = _saturation;
	}
	if (brightness) {
		*brightness = _brightness;
	}
}


static gdouble segmented_bar_Modula (gdouble number, gdouble divisor) {
	gdouble result = 0.0;
	result = (((gint) number) % ((gint) divisor)) + (number - ((gint) number));
	return result;
}


void segmented_bar_ColorFromHsb (gdouble hue, gdouble saturation, gdouble brightness, SegmentedBarBarColour* result) {
	gint i = 0;
	gdouble* _tmp0_ = NULL;
	gdouble* hue_shift;
	gint hue_shift_length1;
	gint _hue_shift_size_;
	gdouble* _tmp1_ = NULL;
	gdouble* color_shift;
	gint color_shift_length1;
	gint _color_shift_size_;
	gdouble m1 = 0.0;
	gdouble m2 = 0.0;
	gdouble m3 = 0.0;
	gdouble _tmp2_ = 0.0;
	gint _tmp3_ = 0;
	SegmentedBarBarColour _tmp8_ = {0};
	SegmentedBarBarColour _tmp9_ = {0};
	_tmp0_ = g_new0 (gdouble, 3);
	_tmp0_[0] = (gdouble) 0;
	_tmp0_[1] = (gdouble) 0;
	_tmp0_[2] = (gdouble) 0;
	hue_shift = _tmp0_;
	hue_shift_length1 = 3;
	_hue_shift_size_ = 3;
	_tmp1_ = g_new0 (gdouble, 3);
	_tmp1_[0] = (gdouble) 0;
	_tmp1_[1] = (gdouble) 0;
	_tmp1_[2] = (gdouble) 0;
	color_shift = _tmp1_;
	color_shift_length1 = 3;
	_color_shift_size_ = 3;
	if (brightness <= 0.5) {
		_tmp2_ = brightness * (1 + saturation);
	} else {
		_tmp2_ = (brightness + saturation) - (brightness * saturation);
	}
	m2 = _tmp2_;
	m1 = (2 * brightness) - m2;
	hue_shift[0] = hue + 120;
	hue_shift[1] = hue;
	hue_shift[2] = hue - 120;
	color_shift[2] = brightness;
	color_shift[1] = color_shift[2];
	color_shift[0] = color_shift[1];
	if (saturation == 0) {
		_tmp3_ = 3;
	} else {
		_tmp3_ = 0;
	}
	i = _tmp3_;
	{
		gboolean _tmp4_;
		_tmp4_ = TRUE;
		while (TRUE) {
			if (!_tmp4_) {
				i++;
			}
			_tmp4_ = FALSE;
			if (!(i < 3)) {
				break;
			}
			m3 = hue_shift[i];
			if (m3 > 360) {
				gdouble _tmp5_;
				_tmp5_ = segmented_bar_Modula (m3, (gdouble) 360);
				m3 = _tmp5_;
			} else {
				if (m3 < 0) {
					gdouble _tmp6_;
					gdouble _tmp7_;
					_tmp6_ = fabs (m3);
					_tmp7_ = segmented_bar_Modula (_tmp6_, (gdouble) 360);
					m3 = 360 - _tmp7_;
				}
			}
			if (m3 < 60) {
				color_shift[i] = m1 + (((m2 - m1) * m3) / 60);
			} else {
				if (m3 < 180) {
					color_shift[i] = m2;
				} else {
					if (m3 < 240) {
						color_shift[i] = m1 + (((m2 - m1) * (240 - m3)) / 60);
					} else {
						color_shift[i] = m1;
					}
				}
			}
		}
	}
	segmented_bar_bar_colour_init (&_tmp8_, color_shift[0], color_shift[1], color_shift[2], (gdouble) 0);
	_tmp9_ = _tmp8_;
	*result = _tmp9_;
	color_shift = (g_free (color_shift), NULL);
	hue_shift = (g_free (hue_shift), NULL);
	return;
}


void segmented_bar_ColorShade (SegmentedBarBarColour* col, gdouble ratio, SegmentedBarBarColour* result) {
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble b = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	SegmentedBarBarColour _tmp7_ = {0};
	SegmentedBarBarColour _tmp8_ = {0};
	SegmentedBarBarColour color;
	gdouble _tmp9_;
	segmented_bar_HsbFromColor (col, &_tmp0_, &_tmp1_, &_tmp2_);
	h = _tmp0_;
	s = _tmp1_;
	b = _tmp2_;
	_tmp3_ = MIN (b * ratio, (gdouble) 1);
	_tmp4_ = MAX (_tmp3_, (gdouble) 0);
	b = _tmp4_;
	_tmp5_ = MIN (s * ratio, (gdouble) 1);
	_tmp6_ = MAX (_tmp5_, (gdouble) 0);
	s = _tmp6_;
	segmented_bar_ColorFromHsb (h, s, b, &_tmp7_);
	_tmp8_ = _tmp7_;
	color = _tmp8_;
	_tmp9_ = segmented_bar_bar_colour_get_A (col);
	segmented_bar_bar_colour_set_A (&color, _tmp9_);
	*result = color;
	return;
}


void segmented_bar_ColorAdjustBrightness (SegmentedBarBarColour* col, gdouble br, SegmentedBarBarColour* result) {
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble b = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	SegmentedBarBarColour _tmp5_ = {0};
	SegmentedBarBarColour _tmp6_ = {0};
	segmented_bar_HsbFromColor (col, &_tmp0_, &_tmp1_, &_tmp2_);
	h = _tmp0_;
	s = _tmp1_;
	b = _tmp2_;
	_tmp3_ = MIN (br, (gdouble) 1);
	_tmp4_ = MAX (_tmp3_, (gdouble) 0);
	b = _tmp4_;
	segmented_bar_ColorFromHsb (h, s, b, &_tmp5_);
	_tmp6_ = _tmp5_;
	*result = _tmp6_;
	return;
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


gchar* segmented_bar_ColorGetHex (SegmentedBarBarColour* color, gboolean withAlpha) {
	gchar* result = NULL;
	gdouble r = 0.0;
	gdouble g = 0.0;
	gdouble b = 0.0;
	gdouble a = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	_tmp0_ = segmented_bar_bar_colour_get_R (color);
	r = _tmp0_ * 255;
	_tmp1_ = segmented_bar_bar_colour_get_G (color);
	g = _tmp1_ * 255;
	_tmp2_ = segmented_bar_bar_colour_get_B (color);
	b = _tmp2_ * 255;
	_tmp3_ = segmented_bar_bar_colour_get_A (color);
	a = _tmp3_ * 255;
	if (withAlpha) {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_;
		gchar* _tmp16_;
		gchar* _tmp17_;
		_tmp4_ = double_to_string (r);
		_tmp5_ = _tmp4_;
		_tmp6_ = double_to_string (g);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp5_, _tmp7_, NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = double_to_string (b);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp9_, _tmp11_, NULL);
		_tmp13_ = _tmp12_;
		_tmp14_ = double_to_string (a);
		_tmp15_ = _tmp14_;
		_tmp16_ = g_strconcat (_tmp13_, _tmp15_, NULL);
		_tmp17_ = _tmp16_;
		_g_free0 (_tmp15_);
		_g_free0 (_tmp13_);
		_g_free0 (_tmp11_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		result = _tmp17_;
		return result;
	} else {
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_;
		gchar* _tmp26_;
		gchar* _tmp27_;
		_tmp18_ = double_to_string (r);
		_tmp19_ = _tmp18_;
		_tmp20_ = double_to_string (g);
		_tmp21_ = _tmp20_;
		_tmp22_ = g_strconcat (_tmp19_, _tmp21_, NULL);
		_tmp23_ = _tmp22_;
		_tmp24_ = double_to_string (b);
		_tmp25_ = _tmp24_;
		_tmp26_ = g_strconcat (_tmp23_, _tmp25_, NULL);
		_tmp27_ = _tmp26_;
		_g_free0 (_tmp25_);
		_g_free0 (_tmp23_);
		_g_free0 (_tmp21_);
		_g_free0 (_tmp19_);
		result = _tmp27_;
		return result;
	}
}


void segmented_bar_RoundedRectangleA (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r) {
	g_return_if_fail (cr != NULL);
	segmented_bar_RoundedRectangle (cr, x, y, w, h, r, SEGMENTED_BAR_CAIRO_CORNERS_All, FALSE);
}


void segmented_bar_RoundedRectangleB (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, SegmentedBarCairoCorners corners) {
	g_return_if_fail (cr != NULL);
	segmented_bar_RoundedRectangle (cr, x, y, w, h, r, corners, FALSE);
}


void segmented_bar_RoundedRectangle (cairo_t* cr, gdouble x, gdouble y, gdouble w, gdouble h, gdouble r, SegmentedBarCairoCorners corners, gboolean topBottomFallsThrough) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (cr != NULL);
	if (topBottomFallsThrough) {
		_tmp0_ = corners == SEGMENTED_BAR_CAIRO_CORNERS_None;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		cairo_move_to (cr, x, y - r);
		cairo_line_to (cr, x, (y + h) + r);
		cairo_move_to (cr, x + w, y - r);
		cairo_line_to (cr, x + w, (y + h) + r);
		return;
	} else {
		gboolean _tmp1_ = FALSE;
		if (r < 0.0001) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = corners == SEGMENTED_BAR_CAIRO_CORNERS_None;
		}
		if (_tmp1_) {
			cairo_rectangle (cr, x, y, w, h);
			return;
		}
	}
	if ((corners & (SEGMENTED_BAR_CAIRO_CORNERS_TopLeft | SEGMENTED_BAR_CAIRO_CORNERS_TopRight)) == 0) {
		_tmp2_ = topBottomFallsThrough;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		y = y - r;
		h = h + r;
		cairo_move_to (cr, x + w, y);
	} else {
		if ((corners & SEGMENTED_BAR_CAIRO_CORNERS_TopLeft) != 0) {
			cairo_move_to (cr, x + r, y);
		} else {
			cairo_move_to (cr, x, y);
		}
		if ((corners & SEGMENTED_BAR_CAIRO_CORNERS_TopRight) != 0) {
			cairo_arc (cr, (x + w) - r, y + r, r, G_PI * 1.5, G_PI * 2);
		} else {
			cairo_line_to (cr, x + w, y);
		}
	}
	if ((corners & (SEGMENTED_BAR_CAIRO_CORNERS_BottomLeft | SEGMENTED_BAR_CAIRO_CORNERS_BottomRight)) == 0) {
		_tmp3_ = topBottomFallsThrough;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		h = h + r;
		cairo_line_to (cr, x + w, y + h);
		cairo_move_to (cr, x, y + h);
		cairo_line_to (cr, x, y + r);
		cairo_arc (cr, x + r, y + r, r, G_PI, G_PI * 1.5);
	} else {
		if ((corners & SEGMENTED_BAR_CAIRO_CORNERS_BottomRight) != 0) {
			cairo_arc (cr, (x + w) - r, (y + h) - r, r, (gdouble) 0, G_PI * 0.5);
		} else {
			cairo_line_to (cr, x + w, y + h);
		}
		if ((corners & SEGMENTED_BAR_CAIRO_CORNERS_BottomLeft) != 0) {
			cairo_arc (cr, x + r, (y + h) - r, r, G_PI * 0.5, G_PI);
		} else {
			cairo_line_to (cr, x, y + h);
		}
		if ((corners & SEGMENTED_BAR_CAIRO_CORNERS_TopLeft) != 0) {
			cairo_arc (cr, x + r, y + r, r, G_PI, G_PI * 1.5);
		} else {
			cairo_line_to (cr, x, y);
		}
	}
}


gint segmented_bar_get_Remainder (SegmentedBar* self) {
	gint result;
	gint total;
	g_return_val_if_fail (self != NULL, 0);
	total = 0;
	{
		GList* seg_collection;
		GList* seg_it;
		seg_collection = self->priv->segments;
		for (seg_it = seg_collection; seg_it != NULL; seg_it = seg_it->next) {
			SegmentedBarSegment* _tmp0_;
			SegmentedBarSegment* seg;
			_tmp0_ = _segmented_bar_segment_ref0 ((SegmentedBarSegment*) seg_it->data);
			seg = _tmp0_;
			{
				gint _tmp1_;
				_tmp1_ = segmented_bar_segment_get_Percent (seg);
				total = total + _tmp1_;
				_segmented_bar_segment_unref0 (seg);
			}
		}
	}
	result = 100 - total;
	return result;
}


SegmentedBarBarValueFormatHandler segmented_bar_get_ValueFormatter (SegmentedBar* self, gpointer* result_target) {
	SegmentedBarBarValueFormatHandler result;
	SegmentedBarBarValueFormatHandler _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->format_handler;
	*result_target = self->priv->format_handler_target;
	result = _tmp0_;
	return result;
}


void segmented_bar_set_ValueFormatter (SegmentedBar* self, SegmentedBarBarValueFormatHandler value, gpointer value_target) {
	SegmentedBarBarValueFormatHandler _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	(self->priv->format_handler_target_destroy_notify == NULL) ? NULL : (self->priv->format_handler_target_destroy_notify (self->priv->format_handler_target), NULL);
	self->priv->format_handler = NULL;
	self->priv->format_handler_target = NULL;
	self->priv->format_handler_target_destroy_notify = NULL;
	self->priv->format_handler = _tmp0_;
	self->priv->format_handler_target = value_target;
	self->priv->format_handler_target_destroy_notify = NULL;
}


void segmented_bar_get_RemainderColor (SegmentedBar* self, SegmentedBarBarColour* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->remainder_color;
	return;
}


void segmented_bar_set_RemainderColor (SegmentedBar* self, SegmentedBarBarColour* value) {
	g_return_if_fail (self != NULL);
	self->priv->remainder_color = *value;
	gtk_widget_queue_draw ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "RemainderColor");
}


gint segmented_bar_get_BarHeight (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->bar_height;
	return result;
}


void segmented_bar_set_BarHeight (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->bar_height != value) {
		self->priv->bar_height = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "BarHeight");
}


gboolean segmented_bar_get_ShowReflection (SegmentedBar* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->reflect;
	return result;
}


void segmented_bar_set_ShowReflection (SegmentedBar* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->reflect != value) {
		self->reflect = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "ShowReflection");
}


gboolean segmented_bar_get_ShowLabels (SegmentedBar* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->show_labels;
	return result;
}


void segmented_bar_set_ShowLabels (SegmentedBar* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->show_labels != value) {
		self->show_labels = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "ShowLabels");
}


gint segmented_bar_get_SegmentLabelSpacing (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->segment_label_spacing;
	return result;
}


void segmented_bar_set_SegmentLabelSpacing (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->segment_label_spacing != value) {
		self->priv->segment_label_spacing = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "SegmentLabelSpacing");
}


gint segmented_bar_get_SegmentBoxSize (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->segment_box_size;
	return result;
}


void segmented_bar_set_SegmentBoxSize (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->segment_box_size != value) {
		self->priv->segment_box_size = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "SegmentBoxSize");
}


gint segmented_bar_get_SegmentBoxSpacing (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->segment_box_spacing;
	return result;
}


void segmented_bar_set_SegmentBoxSpacing (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->segment_box_spacing != value) {
		self->priv->segment_box_spacing = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "SegmentBoxSpacing");
}


gint segmented_bar_get_BarLabelSpacing (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->bar_label_spacing;
	return result;
}


void segmented_bar_set_BarLabelSpacing (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->bar_label_spacing != value) {
		self->priv->bar_label_spacing = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "BarLabelSpacing");
}


gint segmented_bar_get_HorizontalPadding (SegmentedBar* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->h_padding;
	return result;
}


void segmented_bar_set_HorizontalPadding (SegmentedBar* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->h_padding != value) {
		self->priv->h_padding = value;
		gtk_widget_queue_resize ((GtkWidget*) self);
	}
	g_object_notify ((GObject *) self, "HorizontalPadding");
}


SegmentedBarSegment* segmented_bar_segment_construct (GType object_type, const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar) {
	SegmentedBarSegment* self = NULL;
	g_return_val_if_fail (title != NULL, NULL);
	self = (SegmentedBarSegment*) g_type_create_instance (object_type);
	segmented_bar_segment_set_Title (self, title);
	segmented_bar_segment_set_Percent (self, percent);
	segmented_bar_segment_set_Color (self, color);
	segmented_bar_segment_set_ShowInBar (self, showInBar);
	return self;
}


SegmentedBarSegment* segmented_bar_segment_new (const gchar* title, gint percent, SegmentedBarBarColour* color, gboolean showInBar) {
	return segmented_bar_segment_construct (SEGMENTED_BAR_TYPE_SEGMENT, title, percent, color, showInBar);
}


const gchar* segmented_bar_segment_get_Title (SegmentedBarSegment* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Title;
	return result;
}


void segmented_bar_segment_set_Title (SegmentedBarSegment* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Title);
	self->priv->_Title = _tmp0_;
}


gint segmented_bar_segment_get_Percent (SegmentedBarSegment* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_Percent;
	return result;
}


void segmented_bar_segment_set_Percent (SegmentedBarSegment* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_Percent = value;
}


void segmented_bar_segment_get_Color (SegmentedBarSegment* self, SegmentedBarBarColour* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_Color;
	return;
}


void segmented_bar_segment_set_Color (SegmentedBarSegment* self, SegmentedBarBarColour* value) {
	g_return_if_fail (self != NULL);
	self->priv->_Color = *value;
}


gboolean segmented_bar_segment_get_ShowInBar (SegmentedBarSegment* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_ShowInBar;
	return result;
}


void segmented_bar_segment_set_ShowInBar (SegmentedBarSegment* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_ShowInBar = value;
}


static void segmented_bar_value_segment_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void segmented_bar_value_segment_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		segmented_bar_segment_unref (value->data[0].v_pointer);
	}
}


static void segmented_bar_value_segment_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = segmented_bar_segment_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer segmented_bar_value_segment_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* segmented_bar_value_segment_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SegmentedBarSegment* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = segmented_bar_segment_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* segmented_bar_value_segment_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SegmentedBarSegment** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = segmented_bar_segment_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* segmented_bar_param_spec_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SegmentedBarParamSpecSegment* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SEGMENTED_BAR_TYPE_SEGMENT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer segmented_bar_value_get_segment (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SEGMENTED_BAR_TYPE_SEGMENT), NULL);
	return value->data[0].v_pointer;
}


void segmented_bar_value_set_segment (GValue* value, gpointer v_object) {
	SegmentedBarSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SEGMENTED_BAR_TYPE_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SEGMENTED_BAR_TYPE_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		segmented_bar_segment_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		segmented_bar_segment_unref (old);
	}
}


void segmented_bar_value_take_segment (GValue* value, gpointer v_object) {
	SegmentedBarSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SEGMENTED_BAR_TYPE_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SEGMENTED_BAR_TYPE_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		segmented_bar_segment_unref (old);
	}
}


static void segmented_bar_segment_class_init (SegmentedBarSegmentClass * klass) {
	segmented_bar_segment_parent_class = g_type_class_peek_parent (klass);
	SEGMENTED_BAR_SEGMENT_CLASS (klass)->finalize = segmented_bar_segment_finalize;
	g_type_class_add_private (klass, sizeof (SegmentedBarSegmentPrivate));
}


static void segmented_bar_segment_instance_init (SegmentedBarSegment * self) {
	self->priv = SEGMENTED_BAR_SEGMENT_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void segmented_bar_segment_finalize (SegmentedBarSegment* obj) {
	SegmentedBarSegment * self;
	self = SEGMENTED_BAR_SEGMENT (obj);
	_g_free0 (self->priv->_Title);
}


GType segmented_bar_segment_get_type (void) {
	static volatile gsize segmented_bar_segment_type_id__volatile = 0;
	if (g_once_init_enter (&segmented_bar_segment_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { segmented_bar_value_segment_init, segmented_bar_value_segment_free_value, segmented_bar_value_segment_copy_value, segmented_bar_value_segment_peek_pointer, "p", segmented_bar_value_segment_collect_value, "p", segmented_bar_value_segment_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SegmentedBarSegmentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) segmented_bar_segment_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SegmentedBarSegment), 0, (GInstanceInitFunc) segmented_bar_segment_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType segmented_bar_segment_type_id;
		segmented_bar_segment_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SegmentedBarSegment", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&segmented_bar_segment_type_id__volatile, segmented_bar_segment_type_id);
	}
	return segmented_bar_segment_type_id__volatile;
}


gpointer segmented_bar_segment_ref (gpointer instance) {
	SegmentedBarSegment* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void segmented_bar_segment_unref (gpointer instance) {
	SegmentedBarSegment* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SEGMENTED_BAR_SEGMENT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void segmented_bar_bar_colour_init (SegmentedBarBarColour *self, gdouble red, gdouble green, gdouble blue, gdouble alpha) {
	memset (self, 0, sizeof (SegmentedBarBarColour));
	segmented_bar_bar_colour_set_R (&(*self), red);
	segmented_bar_bar_colour_set_G (&(*self), green);
	segmented_bar_bar_colour_set_B (&(*self), blue);
	segmented_bar_bar_colour_set_A (&(*self), alpha);
}


gdouble segmented_bar_bar_colour_get_R (SegmentedBarBarColour* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = (*self)._R;
	return result;
}


void segmented_bar_bar_colour_set_R (SegmentedBarBarColour* self, gdouble value) {
	g_return_if_fail (self != NULL);
	(*self)._R = value;
}


gdouble segmented_bar_bar_colour_get_G (SegmentedBarBarColour* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = (*self)._G;
	return result;
}


void segmented_bar_bar_colour_set_G (SegmentedBarBarColour* self, gdouble value) {
	g_return_if_fail (self != NULL);
	(*self)._G = value;
}


gdouble segmented_bar_bar_colour_get_B (SegmentedBarBarColour* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = (*self)._B;
	return result;
}


void segmented_bar_bar_colour_set_B (SegmentedBarBarColour* self, gdouble value) {
	g_return_if_fail (self != NULL);
	(*self)._B = value;
}


gdouble segmented_bar_bar_colour_get_A (SegmentedBarBarColour* self) {
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = (*self)._A;
	return result;
}


void segmented_bar_bar_colour_set_A (SegmentedBarBarColour* self, gdouble value) {
	g_return_if_fail (self != NULL);
	(*self)._A = value;
}


SegmentedBarBarColour* segmented_bar_bar_colour_dup (const SegmentedBarBarColour* self) {
	SegmentedBarBarColour* dup;
	dup = g_new0 (SegmentedBarBarColour, 1);
	memcpy (dup, self, sizeof (SegmentedBarBarColour));
	return dup;
}


void segmented_bar_bar_colour_free (SegmentedBarBarColour* self) {
	g_free (self);
}


GType segmented_bar_bar_colour_get_type (void) {
	static volatile gsize segmented_bar_bar_colour_type_id__volatile = 0;
	if (g_once_init_enter (&segmented_bar_bar_colour_type_id__volatile)) {
		GType segmented_bar_bar_colour_type_id;
		segmented_bar_bar_colour_type_id = g_boxed_type_register_static ("SegmentedBarBarColour", (GBoxedCopyFunc) segmented_bar_bar_colour_dup, (GBoxedFreeFunc) segmented_bar_bar_colour_free);
		g_once_init_leave (&segmented_bar_bar_colour_type_id__volatile, segmented_bar_bar_colour_type_id);
	}
	return segmented_bar_bar_colour_type_id__volatile;
}


static void segmented_bar_class_init (SegmentedBarClass * klass) {
	segmented_bar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SegmentedBarPrivate));
	GTK_WIDGET_CLASS (klass)->realize = segmented_bar_real_realize;
	GTK_WIDGET_CLASS (klass)->get_preferred_width = segmented_bar_real_get_preferred_width;
	GTK_WIDGET_CLASS (klass)->get_preferred_height = segmented_bar_real_get_preferred_height;
	GTK_WIDGET_CLASS (klass)->size_allocate = segmented_bar_real_size_allocate;
	GTK_WIDGET_CLASS (klass)->draw = segmented_bar_real_draw;
	G_OBJECT_CLASS (klass)->get_property = _vala_segmented_bar_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_segmented_bar_set_property;
	G_OBJECT_CLASS (klass)->finalize = segmented_bar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_REMAINDER, g_param_spec_int ("Remainder", "Remainder", "Remainder", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_REMAINDER_COLOR, g_param_spec_boxed ("RemainderColor", "RemainderColor", "RemainderColor", SEGMENTED_BAR_TYPE_BAR_COLOUR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_BAR_HEIGHT, g_param_spec_int ("BarHeight", "BarHeight", "BarHeight", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_SHOW_REFLECTION, g_param_spec_boolean ("ShowReflection", "ShowReflection", "ShowReflection", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_SHOW_LABELS, g_param_spec_boolean ("ShowLabels", "ShowLabels", "ShowLabels", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_SEGMENT_LABEL_SPACING, g_param_spec_int ("SegmentLabelSpacing", "SegmentLabelSpacing", "SegmentLabelSpacing", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_SEGMENT_BOX_SIZE, g_param_spec_int ("SegmentBoxSize", "SegmentBoxSize", "SegmentBoxSize", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_SEGMENT_BOX_SPACING, g_param_spec_int ("SegmentBoxSpacing", "SegmentBoxSpacing", "SegmentBoxSpacing", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_BAR_LABEL_SPACING, g_param_spec_int ("BarLabelSpacing", "BarLabelSpacing", "BarLabelSpacing", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEGMENTED_BAR_HORIZONTAL_PADDING, g_param_spec_int ("HorizontalPadding", "HorizontalPadding", "HorizontalPadding", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void segmented_bar_instance_init (SegmentedBar * self) {
	SegmentedBarBarColour _tmp0_ = {0};
	SegmentedBarBarColour _tmp1_ = {0};
	self->priv = SEGMENTED_BAR_GET_PRIVATE (self);
	g_static_rec_mutex_init (&self->priv->__lock_segments);
	self->priv->segments = NULL;
	self->priv->bar_height = 26;
	self->priv->bar_label_spacing = 8;
	self->priv->segment_label_spacing = 16;
	self->priv->segment_box_size = 12;
	self->priv->segment_box_spacing = 6;
	self->priv->h_padding = 0;
	self->show_labels = TRUE;
	self->reflect = TRUE;
	segmented_bar_RgbToColor ((guint) 0xeeeeee, &_tmp0_);
	_tmp1_ = _tmp0_;
	self->priv->remainder_color = _tmp1_;
}


static void segmented_bar_finalize (GObject* obj) {
	SegmentedBar * self;
	self = SEGMENTED_BAR (obj);
	g_static_rec_mutex_free (&self->priv->__lock_segments);
	__g_list_free__segmented_bar_segment_unref0_0 (self->priv->segments);
	(self->priv->format_handler_target_destroy_notify == NULL) ? NULL : (self->priv->format_handler_target_destroy_notify (self->priv->format_handler_target), NULL);
	self->priv->format_handler = NULL;
	self->priv->format_handler_target = NULL;
	self->priv->format_handler_target_destroy_notify = NULL;
	G_OBJECT_CLASS (segmented_bar_parent_class)->finalize (obj);
}


GType segmented_bar_get_type (void) {
	static volatile gsize segmented_bar_type_id__volatile = 0;
	if (g_once_init_enter (&segmented_bar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SegmentedBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) segmented_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SegmentedBar), 0, (GInstanceInitFunc) segmented_bar_instance_init, NULL };
		GType segmented_bar_type_id;
		segmented_bar_type_id = g_type_register_static (GTK_TYPE_WIDGET, "SegmentedBar", &g_define_type_info, 0);
		g_once_init_leave (&segmented_bar_type_id__volatile, segmented_bar_type_id);
	}
	return segmented_bar_type_id__volatile;
}


static void _vala_segmented_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SegmentedBar * self;
	SegmentedBarBarColour boxed0;
	self = SEGMENTED_BAR (object);
	switch (property_id) {
		case SEGMENTED_BAR_REMAINDER:
		g_value_set_int (value, segmented_bar_get_Remainder (self));
		break;
		case SEGMENTED_BAR_REMAINDER_COLOR:
		segmented_bar_get_RemainderColor (self, &boxed0);
		g_value_set_boxed (value, &boxed0);
		break;
		case SEGMENTED_BAR_BAR_HEIGHT:
		g_value_set_int (value, segmented_bar_get_BarHeight (self));
		break;
		case SEGMENTED_BAR_SHOW_REFLECTION:
		g_value_set_boolean (value, segmented_bar_get_ShowReflection (self));
		break;
		case SEGMENTED_BAR_SHOW_LABELS:
		g_value_set_boolean (value, segmented_bar_get_ShowLabels (self));
		break;
		case SEGMENTED_BAR_SEGMENT_LABEL_SPACING:
		g_value_set_int (value, segmented_bar_get_SegmentLabelSpacing (self));
		break;
		case SEGMENTED_BAR_SEGMENT_BOX_SIZE:
		g_value_set_int (value, segmented_bar_get_SegmentBoxSize (self));
		break;
		case SEGMENTED_BAR_SEGMENT_BOX_SPACING:
		g_value_set_int (value, segmented_bar_get_SegmentBoxSpacing (self));
		break;
		case SEGMENTED_BAR_BAR_LABEL_SPACING:
		g_value_set_int (value, segmented_bar_get_BarLabelSpacing (self));
		break;
		case SEGMENTED_BAR_HORIZONTAL_PADDING:
		g_value_set_int (value, segmented_bar_get_HorizontalPadding (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_segmented_bar_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SegmentedBar * self;
	self = SEGMENTED_BAR (object);
	switch (property_id) {
		case SEGMENTED_BAR_REMAINDER_COLOR:
		segmented_bar_set_RemainderColor (self, g_value_get_boxed (value));
		break;
		case SEGMENTED_BAR_BAR_HEIGHT:
		segmented_bar_set_BarHeight (self, g_value_get_int (value));
		break;
		case SEGMENTED_BAR_SHOW_REFLECTION:
		segmented_bar_set_ShowReflection (self, g_value_get_boolean (value));
		break;
		case SEGMENTED_BAR_SHOW_LABELS:
		segmented_bar_set_ShowLabels (self, g_value_get_boolean (value));
		break;
		case SEGMENTED_BAR_SEGMENT_LABEL_SPACING:
		segmented_bar_set_SegmentLabelSpacing (self, g_value_get_int (value));
		break;
		case SEGMENTED_BAR_SEGMENT_BOX_SIZE:
		segmented_bar_set_SegmentBoxSize (self, g_value_get_int (value));
		break;
		case SEGMENTED_BAR_SEGMENT_BOX_SPACING:
		segmented_bar_set_SegmentBoxSpacing (self, g_value_get_int (value));
		break;
		case SEGMENTED_BAR_BAR_LABEL_SPACING:
		segmented_bar_set_BarLabelSpacing (self, g_value_get_int (value));
		break;
		case SEGMENTED_BAR_HORIZONTAL_PADDING:
		segmented_bar_set_HorizontalPadding (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



